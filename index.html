<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HardwareOne Map Converter</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 20px;
        }
        
        header h1 {
            font-size: 1.8em;
            color: #4cc9f0;
            margin-bottom: 5px;
        }
        
        header p {
            color: #888;
            font-size: 0.9em;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        #map {
            height: 500px;
            border-radius: 8px;
            border: 2px solid #333;
        }
        
        .sidebar {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
        }
        
        .sidebar h2 {
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #4cc9f0;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }
        
        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #1a1a2e;
            color: #eee;
            font-size: 0.95em;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #4cc9f0;
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85em;
        }
        
        .checkbox-item input {
            width: 16px;
            height: 16px;
        }
        
        .section-title {
            font-size: 0.8em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 10px;
            margin-bottom: 6px;
            padding-top: 8px;
            border-top: 1px solid #333;
        }
        
        .section-title:first-child {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }
        
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-row input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        
        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4cc9f0;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider-value {
            min-width: 60px;
            text-align: right;
            font-size: 0.85em;
            color: #4cc9f0;
        }
        
        .size-warning {
            background: #3a2a1a;
            border: 1px solid #ff9800;
            color: #ff9800;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-bottom: 10px;
            display: none;
        }
        
        .size-warning.active {
            display: block;
        }
        
        .size-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .size-bar-fill {
            height: 100%;
            background: #4caf50;
            transition: width 0.3s, background 0.3s;
        }
        
        .size-bar-fill.warning {
            background: #ff9800;
        }
        
        .size-bar-fill.danger {
            background: #f44336;
        }
        
        .stats {
            background: #1a1a2e;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 0.85em;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .stats-row:last-child {
            margin-bottom: 0;
        }
        
        .stats-value {
            color: #4cc9f0;
            font-weight: bold;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #4cc9f0;
            color: #1a1a2e;
            font-weight: bold;
        }
        
        .btn-primary:hover {
            background: #7dd8f5;
        }
        
        .btn-primary:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #333;
            color: #eee;
            margin-bottom: 10px;
        }
        
        .btn-secondary:hover {
            background: #444;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.85em;
            text-align: center;
        }
        
        .status.ready {
            background: #1a3a1a;
            color: #4caf50;
        }
        
        .status.working {
            background: #3a3a1a;
            color: #ff9800;
        }
        
        .status.error {
            background: #3a1a1a;
            color: #f44336;
        }
        
        .status.success {
            background: #1a3a1a;
            color: #4caf50;
        }
        
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background: #16213e;
            border-radius: 8px;
        }
        
        .instructions h3 {
            font-size: 1em;
            margin-bottom: 10px;
            color: #4cc9f0;
        }
        
        .instructions ol {
            padding-left: 20px;
            font-size: 0.85em;
            line-height: 1.6;
            color: #aaa;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar.active {
            display: block;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: #4cc9f0;
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üó∫Ô∏è HardwareOne Map Converter</h1>
            <p>Create offline map files for your ESP32 device</p>
        </header>
        
        <div class="main-content">
            <div class="map-container">
                <div id="map"></div>
            </div>
            
            <div class="sidebar">
                <h2>Map Settings</h2>
                
                <button class="btn btn-secondary" onclick="useMyLocation()">
                    üìç Use My Location
                </button>
                
                <div class="form-group">
                    <label>Region Name</label>
                    <input type="text" id="regionName" value="My Area" maxlength="15">
                </div>
                
                <div class="form-group">
                    <label>Include Features</label>
                    <div class="checkbox-group">
                        <div class="section-title">Roads</div>
                        <label class="checkbox-item">
                            <input type="checkbox" id="highways" checked>
                            Highways
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="majorRoads" checked>
                            Major Roads
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="minorRoads">
                            Minor Roads
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="paths">
                            Paths/Trails
                        </label>
                        
                        <div class="section-title">Features</div>
                        <label class="checkbox-item">
                            <input type="checkbox" id="water" checked>
                            Water
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="parks" checked>
                            Parks
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="railways">
                            Railways
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="buildings">
                            Buildings
                        </label>
                    </div>
                </div>
                
                <div class="slider-group">
                    <label>Detail Level (geometry simplification)</label>
                    <div class="slider-row">
                        <input type="range" id="detailLevel" min="1" max="5" value="3">
                        <span class="slider-value" id="detailValue">Medium</span>
                    </div>
                </div>
                
                <div class="slider-group">
                    <label>Target Size Budget</label>
                    <div class="slider-row">
                        <input type="range" id="sizeBudget" min="100" max="1000" step="50" value="600">
                        <span class="slider-value" id="budgetValue">600 KB</span>
                    </div>
                    <div class="size-bar">
                        <div class="size-bar-fill" id="sizeBarFill"></div>
                    </div>
                </div>
                
                <div class="size-warning" id="sizeWarning">
                    ‚ö†Ô∏è Estimated size exceeds budget. Try reducing area or features.
                </div>
                
                <div class="stats">
                    <div class="stats-row">
                        <span>Area Size:</span>
                        <span class="stats-value" id="areaSize">-- √ó -- km</span>
                    </div>
                    <div class="stats-row">
                        <span>Estimated Size:</span>
                        <span class="stats-value" id="estSize">-- KB</span>
                    </div>
                    <div class="stats-row">
                        <span>Features:</span>
                        <span class="stats-value" id="featureCount">--</span>
                    </div>
                </div>
                
                <button class="btn btn-primary" id="generateBtn" onclick="generateMap()" disabled>
                    üó∫Ô∏è Generate Map File
                </button>
                
                <div class="progress-bar" id="progressBar">
                    <div class="progress-bar-fill" id="progressFill"></div>
                </div>
                
                <div class="status ready" id="status">
                    Draw a rectangle on the map to select area
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h3>How to Use</h3>
            <ol>
                <li>Click the rectangle tool on the map (top-left) and draw your desired area</li>
                <li>Adjust the region name and feature options</li>
                <li>Click "Generate Map File" to create the .hwmap file</li>
                <li>Upload the file to your device via the web file manager at <code>/maps/</code></li>
            </ol>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    
    <script>
        // =============================================================================
        // MAP INITIALIZATION
        // =============================================================================
        
        const map = L.map('map').setView([40.7128, -74.0060], 13);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);
        
        // Drawing layer
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
        
        // Draw control
        const drawControl = new L.Control.Draw({
            draw: {
                rectangle: {
                    shapeOptions: {
                        color: '#4cc9f0',
                        fillOpacity: 0.2
                    }
                },
                polygon: false,
                circle: false,
                circlemarker: false,
                marker: false,
                polyline: false
            },
            edit: {
                featureGroup: drawnItems,
                remove: true
            }
        });
        map.addControl(drawControl);
        
        // Current selection bounds
        let selectedBounds = null;
        
        // Handle drawing events
        map.on(L.Draw.Event.CREATED, function(e) {
            drawnItems.clearLayers();
            drawnItems.addLayer(e.layer);
            selectedBounds = e.layer.getBounds();
            updateStats();
            document.getElementById('generateBtn').disabled = false;
            setStatus('ready', 'Ready to generate map');
        });
        
        map.on(L.Draw.Event.DELETED, function(e) {
            selectedBounds = null;
            document.getElementById('generateBtn').disabled = true;
            setStatus('ready', 'Draw a rectangle on the map to select area');
            clearStats();
        });
        
        // =============================================================================
        // UI FUNCTIONS
        // =============================================================================
        
        function useMyLocation() {
            if (!navigator.geolocation) {
                setStatus('error', 'Geolocation not supported');
                return;
            }
            
            setStatus('working', 'Getting location...');
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    map.setView([lat, lon], 14);
                    setStatus('ready', 'Centered on your location');
                },
                (error) => {
                    setStatus('error', 'Could not get location: ' + error.message);
                }
            );
        }
        
        function setStatus(type, message) {
            const status = document.getElementById('status');
            status.className = 'status ' + type;
            status.textContent = message;
        }
        
        function setProgress(percent) {
            const bar = document.getElementById('progressBar');
            const fill = document.getElementById('progressFill');
            bar.classList.add('active');
            fill.style.width = percent + '%';
        }
        
        function hideProgress() {
            document.getElementById('progressBar').classList.remove('active');
        }
        
        function updateStats() {
            if (!selectedBounds) return;
            
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            
            // Calculate area in km
            const widthKm = haversineDistance(sw.lat, sw.lng, sw.lat, ne.lng);
            const heightKm = haversineDistance(sw.lat, sw.lng, ne.lat, sw.lng);
            
            document.getElementById('areaSize').textContent = 
                widthKm.toFixed(1) + ' √ó ' + heightKm.toFixed(1) + ' km';
            
            // Estimate size
            const areaKm2 = widthKm * heightKm;
            const estKB = estimateSize(areaKm2);
            document.getElementById('estSize').textContent = estKB + ' KB';
            
            // Update size warning
            updateSizeWarning(estKB);
            
            // Feature count will be updated after fetch
            document.getElementById('featureCount').textContent = '~' + Math.round(areaKm2 * 50);
        }
        
        function clearStats() {
            document.getElementById('areaSize').textContent = '-- √ó -- km';
            document.getElementById('estSize').textContent = '-- KB';
            document.getElementById('featureCount').textContent = '--';
        }
        
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function estimateSize(areaKm2) {
            let bytesPerKm2 = 0;
            if (document.getElementById('highways').checked) bytesPerKm2 += 5000;
            if (document.getElementById('majorRoads').checked) bytesPerKm2 += 12000;
            if (document.getElementById('minorRoads').checked) bytesPerKm2 += 35000;
            if (document.getElementById('paths').checked) bytesPerKm2 += 15000;
            if (document.getElementById('water').checked) bytesPerKm2 += 8000;
            if (document.getElementById('parks').checked) bytesPerKm2 += 5000;
            if (document.getElementById('railways').checked) bytesPerKm2 += 3000;
            if (document.getElementById('buildings').checked) bytesPerKm2 += 80000;
            
            // Adjust for detail level (simplification)
            const detailLevel = parseInt(document.getElementById('detailLevel').value);
            const detailMultiplier = [0.4, 0.6, 1.0, 1.5, 2.0][detailLevel - 1];
            bytesPerKm2 *= detailMultiplier;
            
            return Math.round(areaKm2 * bytesPerKm2 / 1024);
        }
        
        function updateSizeWarning(estKB) {
            const budget = parseInt(document.getElementById('sizeBudget').value);
            const warning = document.getElementById('sizeWarning');
            const barFill = document.getElementById('sizeBarFill');
            const percent = Math.min(100, (estKB / budget) * 100);
            
            barFill.style.width = percent + '%';
            barFill.className = 'size-bar-fill';
            
            if (estKB > budget * 1.5) {
                barFill.classList.add('danger');
                warning.classList.add('active');
            } else if (estKB > budget) {
                barFill.classList.add('warning');
                warning.classList.add('active');
            } else {
                warning.classList.remove('active');
            }
        }
        
        function updateDetailLabel() {
            const level = parseInt(document.getElementById('detailLevel').value);
            const labels = ['Minimal', 'Low', 'Medium', 'High', 'Maximum'];
            document.getElementById('detailValue').textContent = labels[level - 1];
        }
        
        function updateBudgetLabel() {
            const budget = document.getElementById('sizeBudget').value;
            document.getElementById('budgetValue').textContent = budget + ' KB';
        }
        
        // =============================================================================
        // MAP GENERATION
        // =============================================================================
        
        // Debug mode - set to true to enable verbose logging
        const DEBUG = true;
        
        function debugLog(category, message, data = null) {
            if (!DEBUG) return;
            const timestamp = new Date().toISOString().substr(11, 12);
            const prefix = `[${timestamp}] [${category}]`;
            if (data !== null) {
                console.log(prefix, message, data);
            } else {
                console.log(prefix, message);
            }
        }
        
        async function generateMap() {
            if (!selectedBounds) {
                setStatus('error', 'Please select an area first');
                return;
            }
            
            const btn = document.getElementById('generateBtn');
            btn.disabled = true;
            setStatus('working', 'Fetching map data from OpenStreetMap...');
            setProgress(10);
            
            debugLog('INIT', '=== Starting map generation ===');
            debugLog('BOUNDS', 'Selected bounds:', {
                sw: selectedBounds.getSouthWest(),
                ne: selectedBounds.getNorthEast()
            });
            
            try {
                // Build Overpass query
                const query = buildOverpassQuery();
                debugLog('QUERY', 'Overpass query:', query);
                setProgress(20);
                
                // Fetch data
                debugLog('FETCH', 'Fetching from Overpass API...');
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                
                if (!response.ok) {
                    throw new Error('Overpass API error: ' + response.status);
                }
                
                setStatus('working', 'Parsing response...');
                setProgress(50);
                
                const data = await response.json();
                debugLog('FETCH', 'Received elements:', data.elements?.length || 0);
                
                setStatus('working', 'Converting to binary format...');
                setProgress(70);
                
                // Convert to binary
                const hwmapBlob = convertToHWMap(data);
                debugLog('OUTPUT', 'Generated blob size:', hwmapBlob.size + ' bytes');
                
                setProgress(90);
                
                // Download file
                const regionName = document.getElementById('regionName').value || 'map';
                const filename = regionName.toLowerCase().replace(/[^a-z0-9]/g, '_') + '.hwmap';
                
                downloadBlob(hwmapBlob, filename);
                
                setProgress(100);
                setStatus('success', 'Download started! Upload to device at /maps/');
                debugLog('DONE', '=== Map generation complete ===');
                
            } catch (error) {
                debugLog('ERROR', 'Generation failed:', {
                    message: error.message,
                    stack: error.stack
                });
                setStatus('error', 'Error: ' + error.message);
                console.error(error);
            } finally {
                btn.disabled = false;
                setTimeout(hideProgress, 1000);
            }
        }
        
        function buildOverpassQuery() {
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            const bbox = `${sw.lat},${sw.lng},${ne.lat},${ne.lng}`;
            
            let query = `[out:json][bbox:${bbox}];(\n`;
            
            // Roads
            if (document.getElementById('highways').checked) {
                query += `way["highway"~"motorway|motorway_link|trunk|trunk_link"];\n`;
            }
            if (document.getElementById('majorRoads').checked) {
                query += `way["highway"~"primary|secondary|primary_link|secondary_link"];\n`;
            }
            if (document.getElementById('minorRoads').checked) {
                query += `way["highway"~"tertiary|residential|unclassified|service"];\n`;
            }
            if (document.getElementById('paths').checked) {
                query += `way["highway"~"footway|path|cycleway|track|pedestrian"];\n`;
            }
            
            // Features
            if (document.getElementById('water').checked) {
                query += `way["natural"="water"];\nway["waterway"~"river|stream|canal"];\n`;
            }
            if (document.getElementById('parks').checked) {
                query += `way["leisure"="park"];\nway["landuse"~"grass|forest|meadow"];\n`;
            }
            if (document.getElementById('railways').checked) {
                query += `way["railway"~"rail|light_rail|subway|tram"];\n`;
            }
            if (document.getElementById('buildings').checked) {
                query += `way["building"];\n`;
            }
            
            query += `);out geom;`;
            return query;
        }
        
        // =============================================================================
        // BINARY CONVERSION
        // =============================================================================
        
        // Feature types matching device-side enum
        const FEATURE_TYPES = {
            ROAD_HIGHWAY: 0x00,
            ROAD_MAJOR: 0x01,
            ROAD_MINOR: 0x02,
            ROAD_PATH: 0x03,
            WATER: 0x10,
            PARK: 0x11,
            RAILWAY: 0x20,
            BUILDING: 0x30
        };
        
        function convertToHWMap(osmData) {
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            const regionName = document.getElementById('regionName').value.substring(0, 15);
            
            debugLog('CONVERT', 'Starting conversion...');
            debugLog('CONVERT', 'Input elements:', osmData.elements?.length || 0);
            
            // Process features
            const features = [];
            const detailLevel = parseInt(document.getElementById('detailLevel').value);
            const tolerances = [0.0005, 0.0003, 0.0001, 0.00005, 0.00002];
            const tolerance = tolerances[detailLevel - 1];
            
            debugLog('CONVERT', 'Detail level:', detailLevel, 'Tolerance:', tolerance);
            
            let skippedNoGeom = 0;
            let skippedNoType = 0;
            let skippedTooShort = 0;
            
            for (const element of osmData.elements) {
                if (element.type !== 'way' || !element.geometry) {
                    skippedNoGeom++;
                    continue;
                }
                
                const featureType = classifyFeature(element.tags);
                if (featureType === null) {
                    skippedNoType++;
                    continue;
                }
                
                // Simplify geometry based on detail level
                let points = simplifyPoints(element.geometry, tolerance);
                if (points.length < 2) {
                    skippedTooShort++;
                    continue;
                }
                
                // Split features with more than 255 points (uint8 limit)
                while (points.length > 0) {
                    const chunk = points.slice(0, 255);
                    if (chunk.length >= 2) {
                        features.push({
                            type: featureType,
                            points: chunk
                        });
                    }
                    if (points.length <= 255) break;
                    // Keep last point as first of next chunk for continuity
                    points = points.slice(254);
                }
            }
            
            debugLog('CONVERT', 'Skipped - no geometry:', skippedNoGeom);
            debugLog('CONVERT', 'Skipped - no type match:', skippedNoType);
            debugLog('CONVERT', 'Skipped - too short:', skippedTooShort);
            debugLog('CONVERT', 'Final feature count:', features.length);
            
            // Log point distribution
            let totalPoints = 0;
            let maxPoints = 0;
            for (const f of features) {
                totalPoints += f.points.length;
                if (f.points.length > maxPoints) maxPoints = f.points.length;
            }
            debugLog('CONVERT', 'Total points:', totalPoints, 'Max points per feature:', maxPoints);
            
            // Update feature count display
            document.getElementById('featureCount').textContent = features.length;
            
            // Calculate buffer size
            // Header: 4 (magic) + 2 (version) + 2 (flags) + 16 (bounds) + 4 (count) + 8 (name) = 36
            let bufferSize = 36; // Header
            for (const f of features) {
                bufferSize += 2 + 8 + (f.points.length - 1) * 4; // type + count + first point + deltas
            }
            
            debugLog('BUFFER', 'Calculated buffer size:', bufferSize + ' bytes');
            
            // Create buffer
            const buffer = new ArrayBuffer(bufferSize);
            const view = new DataView(buffer);
            let offset = 0;
            
            // Write header
            // Magic "HWMP"
            view.setUint8(offset++, 0x48); // H
            view.setUint8(offset++, 0x57); // W
            view.setUint8(offset++, 0x4D); // M
            view.setUint8(offset++, 0x50); // P
            
            // Version
            view.setUint16(offset, 1, true);
            offset += 2;
            
            // Flags (reserved)
            view.setUint16(offset, 0, true);
            offset += 2;
            
            // Bounds (microdegrees)
            view.setInt32(offset, Math.round(sw.lat * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(sw.lng * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(ne.lat * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(ne.lng * 1000000), true);
            offset += 4;
            
            // Feature count
            view.setUint32(offset, features.length, true);
            offset += 4;
            
            // Region name (null-padded to 8 bytes)
            for (let i = 0; i < 8; i++) {
                view.setUint8(offset++, i < regionName.length ? regionName.charCodeAt(i) : 0);
            }
            
            debugLog('BUFFER', 'Header written, offset now:', offset);
            
            // Write features
            let featureIdx = 0;
            for (const feature of features) {
                const featureStartOffset = offset;
                const expectedSize = 2 + 8 + (feature.points.length - 1) * 4;
                
                // Type
                view.setUint8(offset++, feature.type);
                
                // Point count
                view.setUint8(offset++, feature.points.length);
                
                // First point (absolute, microdegrees)
                const firstLat = Math.round(feature.points[0].lat * 1000000);
                const firstLon = Math.round(feature.points[0].lon * 1000000);
                view.setInt32(offset, firstLat, true);
                offset += 4;
                view.setInt32(offset, firstLon, true);
                offset += 4;
                
                // Remaining points (delta encoded)
                let prevLat = firstLat;
                let prevLon = firstLon;
                
                for (let i = 1; i < feature.points.length; i++) {
                    // Check buffer bounds before writing
                    if (offset + 4 > bufferSize) {
                        debugLog('ERROR', 'Buffer overflow!', {
                            featureIdx,
                            pointIdx: i,
                            offset,
                            bufferSize,
                            featurePoints: feature.points.length,
                            expectedSize,
                            featureStartOffset
                        });
                        throw new Error(`Buffer overflow at feature ${featureIdx}, point ${i}`);
                    }
                    
                    const lat = Math.round(feature.points[i].lat * 1000000);
                    const lon = Math.round(feature.points[i].lon * 1000000);
                    
                    // Clamp deltas to int16 range
                    const deltaLat = Math.max(-32768, Math.min(32767, lat - prevLat));
                    const deltaLon = Math.max(-32768, Math.min(32767, lon - prevLon));
                    
                    view.setInt16(offset, deltaLat, true);
                    offset += 2;
                    view.setInt16(offset, deltaLon, true);
                    offset += 2;
                    
                    prevLat = lat;
                    prevLon = lon;
                }
                
                featureIdx++;
            }
            
            debugLog('BUFFER', 'All features written, final offset:', offset, 'buffer size:', bufferSize);
            
            return new Blob([buffer], { type: 'application/octet-stream' });
        }
        
        function classifyFeature(tags) {
            if (!tags) return null;
            
            // Roads
            if (tags.highway) {
                if (['motorway', 'motorway_link', 'trunk', 'trunk_link'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_HIGHWAY;
                }
                if (['primary', 'secondary', 'primary_link', 'secondary_link'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_MAJOR;
                }
                if (['tertiary', 'residential', 'unclassified', 'service'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_MINOR;
                }
                if (['footway', 'path', 'cycleway', 'track', 'pedestrian'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_PATH;
                }
            }
            
            // Railways
            if (tags.railway) {
                if (['rail', 'light_rail', 'subway', 'tram'].includes(tags.railway)) {
                    return FEATURE_TYPES.RAILWAY;
                }
            }
            
            // Water
            if (tags.natural === 'water' || tags.waterway) {
                return FEATURE_TYPES.WATER;
            }
            
            // Parks and green areas
            if (tags.leisure === 'park' || ['grass', 'forest', 'meadow'].includes(tags.landuse)) {
                return FEATURE_TYPES.PARK;
            }
            
            // Buildings
            if (tags.building) {
                return FEATURE_TYPES.BUILDING;
            }
            
            return null;
        }
        
        function simplifyPoints(geometry, tolerance) {
            // Douglas-Peucker simplification
            if (geometry.length <= 2) return geometry;
            
            const points = geometry.map(p => ({ lat: p.lat, lon: p.lon }));
            return douglasPeucker(points, tolerance);
        }
        
        function douglasPeucker(points, tolerance) {
            if (points.length <= 2) return points;
            
            let maxDist = 0;
            let maxIndex = 0;
            
            const start = points[0];
            const end = points[points.length - 1];
            
            for (let i = 1; i < points.length - 1; i++) {
                const dist = perpendicularDistance(points[i], start, end);
                if (dist > maxDist) {
                    maxDist = dist;
                    maxIndex = i;
                }
            }
            
            if (maxDist > tolerance) {
                const left = douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
                const right = douglasPeucker(points.slice(maxIndex), tolerance);
                return left.slice(0, -1).concat(right);
            }
            
            return [start, end];
        }
        
        function perpendicularDistance(point, lineStart, lineEnd) {
            const dx = lineEnd.lon - lineStart.lon;
            const dy = lineEnd.lat - lineStart.lat;
            
            const norm = Math.sqrt(dx * dx + dy * dy);
            if (norm === 0) return Math.sqrt(
                Math.pow(point.lon - lineStart.lon, 2) + 
                Math.pow(point.lat - lineStart.lat, 2)
            );
            
            return Math.abs(dy * point.lon - dx * point.lat + 
                          lineEnd.lon * lineStart.lat - lineEnd.lat * lineStart.lon) / norm;
        }
        
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Update stats when checkboxes change
        document.querySelectorAll('.checkbox-group input').forEach(cb => {
            cb.addEventListener('change', updateStats);
        });
        
        // Slider event listeners
        document.getElementById('detailLevel').addEventListener('input', () => {
            updateDetailLabel();
            updateStats();
        });
        
        document.getElementById('sizeBudget').addEventListener('input', () => {
            updateBudgetLabel();
            updateStats();
        });
    </script>
</body>
</html>
