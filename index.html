<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HardwareOne Map Converter</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        
        .container {
            max-width: 90%;
            width: 90%;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 20px;
        }
        
        header h1 {
            font-size: 1.8em;
            color: #4cc9f0;
            margin-bottom: 5px;
        }
        
        header p {
            color: #888;
            font-size: 0.9em;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        .map-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        #map {
            height: 650px;
            border-radius: 8px;
            border: 2px solid #333;
            flex-shrink: 0;
        }
        
        .sidebar {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
        }
        
        .sidebar h2 {
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #4cc9f0;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }
        
        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #1a1a2e;
            color: #eee;
            font-size: 0.95em;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #4cc9f0;
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85em;
        }
        
        .checkbox-item input {
            width: 16px;
            height: 16px;
        }
        
        .section-title {
            font-size: 0.8em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 8px;
            margin-bottom: 4px;
            padding: 6px 8px;
            background: #1a1a2e;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        
        .section-title:hover {
            background: #222;
        }
        
        .section-count {
            color: #4cc9f0;
            font-size: 0.9em;
            margin-left: auto;
            margin-right: 8px;
        }
        
        .feature-size {
            color: #888;
            font-size: 0.8em;
            margin-left: 4px;
        }
        
        .feature-size.large {
            color: #ff6b6b;
        }
        
        .feature-size.medium {
            color: #ffd93d;
        }
        
        .feature-size.small {
            color: #69db7c;
        }
        
        .section-title::after {
            content: '▼';
            font-size: 0.7em;
            transition: transform 0.2s;
            flex-shrink: 0;
        }
        
        .section-title.collapsed::after {
            transform: rotate(-90deg);
        }
        
        .section-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            padding: 6px 0;
            overflow: hidden;
            transition: max-height 0.2s, opacity 0.2s;
        }
        
        .section-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding: 0;
        }
        
        /* Nested sections container - display as block, not grid */
        #allFeaturesContent {
            display: block;
        }
        
        #allFeaturesContent .section-title {
            margin-top: 4px;
        }
        
        #allFeaturesContent .section-content {
            margin-bottom: 4px;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }
        
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* All range sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #555;
            border-radius: 3px;
            outline: none;
            margin: 8px 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4cc9f0;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -5px;
        }
        
        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: #555;
            border-radius: 3px;
        }
        
        input[type="range"]::-moz-range-track {
            height: 6px;
            background: #555;
            border-radius: 3px;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #4cc9f0;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .slider-row input[type="range"] {
            flex: 1;
        }
        
        .slider-value {
            min-width: 60px;
            text-align: right;
            font-size: 0.85em;
            color: #4cc9f0;
        }
        
        .size-warning {
            background: #3a2a1a;
            border: 1px solid #ff9800;
            color: #ff9800;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-bottom: 10px;
            display: none;
        }
        
        .size-warning.active {
            display: block;
        }
        
        .size-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .size-bar-fill {
            height: 100%;
            background: #4caf50;
            transition: width 0.3s, background 0.3s;
        }
        
        .size-bar-fill.warning {
            background: #ff9800;
        }
        
        .size-bar-fill.danger {
            background: #f44336;
        }
        
        .stats {
            background: #1a1a2e;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 0.85em;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .stats-row:last-child {
            margin-bottom: 0;
        }
        
        .stats-value {
            color: #4cc9f0;
            font-weight: bold;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #4cc9f0;
            color: #1a1a2e;
            font-weight: bold;
        }
        
        .btn-primary:hover {
            background: #7dd8f5;
        }
        
        .btn-primary:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #333;
            color: #eee;
            margin-bottom: 10px;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #444;
        }
        
        .btn-secondary:disabled {
            background: #222;
            color: #555;
            cursor: not-allowed;
        }
        
        .btn-clear {
            background: #3a2020;
            color: #f44336;
            border: 1px solid #f44336;
            margin-top: 10px;
        }
        
        .btn-clear:hover {
            background: #4a2a2a;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.85em;
            text-align: center;
        }
        
        .status.ready {
            background: #1a3a1a;
            color: #4caf50;
        }
        
        .status.working {
            background: #3a3a1a;
            color: #ff9800;
        }
        
        .status.error {
            background: #3a1a1a;
            color: #f44336;
        }
        
        .status.success {
            background: #1a3a1a;
            color: #4caf50;
        }
        
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background: #16213e;
            border-radius: 8px;
        }
        
        .instructions h3 {
            font-size: 1em;
            margin-bottom: 10px;
            color: #4cc9f0;
        }
        
        .instructions ol {
            padding-left: 20px;
            font-size: 0.85em;
            line-height: 1.6;
            color: #aaa;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar.active {
            display: block;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: #4cc9f0;
            width: 0%;
            transition: width 0.3s;
        }
        
        .preview-panel {
            background: #16213e;
            border-radius: 8px;
            padding: 12px;
            display: none;
        }
        
        .preview-panel.active {
            display: block;
        }
        
        .instructions-banner {
            background: #16213e;
            border-radius: 8px;
            padding: 10px 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        
        .instructions-banner.hidden {
            display: none;
        }
        
        .instructions-banner h3 {
            color: #4cc9f0;
            font-size: 0.9em;
            margin: 0 0 6px 0;
        }
        
        .instructions-banner ol {
            margin: 0;
            padding-left: 18px;
            font-size: 0.8em;
            color: #aaa;
            line-height: 1.5;
        }
        
        .instructions-banner ol li {
            margin-bottom: 2px;
        }
        
        .instructions-content {
            flex: 1;
        }
        
        .instructions-close {
            background: none;
            border: none;
            color: #666;
            font-size: 1.2em;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .instructions-close:hover {
            color: #fff;
        }
        
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .preview-header h3 {
            color: #4cc9f0;
            font-size: 1em;
            margin: 0;
        }
        
        .preview-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.2em;
            cursor: pointer;
        }
        
        .preview-close:hover {
            color: #fff;
        }
        
        .map-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 6px 10px;
            background: #16213e;
            border-radius: 4px;
            font-size: 0.75em;
        }
        
        .preview-canvas-container {
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            cursor: grab;
        }
        
        .preview-canvas-container:active {
            cursor: grabbing;
        }
        
        #previewCanvas {
            display: block;
            width: 100%;
            height: 400px;
        }
        
        .preview-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .preview-control-btn {
            width: 32px;
            height: 32px;
            background: rgba(22, 33, 62, 0.9);
            border: 1px solid #4cc9f0;
            border-radius: 4px;
            color: #4cc9f0;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .preview-control-btn:hover {
            background: #4cc9f0;
            color: #0f1419;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .legend-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>HardwareOne Map Converter</h1>
            <p>Create offline map files for your ESP32 device</p>
        </header>
        
        <div class="main-content">
            <div class="map-row">
                <div class="instructions-banner" id="instructionsBanner">
                    <div class="instructions-content">
                        <h3>How to Use</h3>
                        <ol>
                            <li>Draw a rectangle or polygon on the map to select your area</li>
                            <li>Adjust features and settings in the sidebar</li>
                            <li>Click "Preview" to see what will be included, then "Generate" to download</li>
                        </ol>
                    </div>
                    <button class="instructions-close" onclick="document.getElementById('instructionsBanner').classList.add('hidden')">✕</button>
                </div>
                <div id="map"></div>
                <div class="map-legend">
                    <div class="legend-item"><span class="legend-color" style="background:#ff6b6b"></span> Highways</div>
                    <div class="legend-item"><span class="legend-color" style="background:#ffd93d"></span> Major Roads</div>
                    <div class="legend-item"><span class="legend-color" style="background:#ffffff"></span> Minor Roads</div>
                    <div class="legend-item"><span class="legend-color" style="background:#4dabf7"></span> Water</div>
                    <div class="legend-item"><span class="legend-color" style="background:#69db7c"></span> Parks/Land</div>
                    <div class="legend-item"><span class="legend-color" style="background:#da77f2"></span> Railways</div>
                </div>
                <div class="preview-panel" id="previewPanel">
                    <div class="preview-header">
                        <h3>Preview</h3>
                        <button class="preview-close" onclick="closePreview()">✕</button>
                    </div>
                    <div class="preview-canvas-container" id="previewContainer">
                        <canvas id="previewCanvas"></canvas>
                        <div class="preview-controls">
                            <button class="preview-control-btn" onclick="zoomPreview(1.2)" title="Zoom in">+</button>
                            <button class="preview-control-btn" onclick="zoomPreview(0.8)" title="Zoom out">−</button>
                            <button class="preview-control-btn" onclick="resetPreviewZoom()" title="Reset view">⟲</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="sidebar">
                <h2>Map Settings</h2>
                
                <button class="btn btn-secondary" onclick="useMyLocation()">
                    Use My Location
                </button>
                
                <div class="form-group">
                    <label>Region Name</label>
                    <input type="text" id="regionName" value="My Area" maxlength="15">
                </div>
                
                <!-- Waypoints Section - Near top for easy access -->
                <div class="section-title" onclick="toggleSection(this)" data-section="waypoints" style="margin-bottom:0;">
                    Waypoints <span class="section-count" id="countWaypoints">(0)</span>
                </div>
                <div class="section-content" style="padding:8px;background:#1a1a2e;border-radius:0 0 4px 4px;margin-bottom:12px;">
                    <label class="checkbox-item" style="margin-bottom:8px;">
                        <input type="checkbox" id="waypointAddMode" onchange="toggleWaypointMode()">
                        <span>Click map to add waypoint</span>
                    </label>
                    <div id="waypointList" style="max-height:120px;overflow-y:auto;margin-bottom:8px;"></div>
                    <div style="display:flex;gap:4px;">
                        <button class="btn btn-secondary" onclick="exportWaypoints()" style="flex:1;padding:4px 6px;font-size:0.8em;">Export</button>
                        <button class="btn btn-secondary" onclick="importWaypoints()" style="flex:1;padding:4px 6px;font-size:0.8em;">Import</button>
                        <button class="btn btn-secondary" onclick="clearAllWaypoints()" style="flex:1;padding:4px 6px;font-size:0.8em;">Clear</button>
                    </div>
                </div>

                <!-- Features Section - All feature categories nested inside -->
                <div class="section-title" onclick="toggleSection(this)" data-section="allfeatures" style="background:#2a2a4e;margin-bottom:0;">
                    Features <span class="section-count" id="countAllFeatures"></span>
                </div>
                <div class="section-content" id="allFeaturesContent" style="padding:4px 8px;background:#1a1a2e;border-radius:0 0 4px 4px;margin-bottom:12px;">
                    <div class="section-title" onclick="toggleSection(this)" data-section="highways" style="font-size:0.9em;">Highways <span class="section-count" id="countHighways">(2/2)</span></div>
                    <div class="section-content">
                        <label class="checkbox-item">
                            <input type="checkbox" id="motorways" checked onchange="updateSectionCounts()">
                            Motorways <span class="feature-size" id="size-motorways"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="trunkRoads" checked onchange="updateSectionCounts()">
                            Trunk/US Routes <span class="feature-size" id="size-trunkRoads"></span>
                        </label>
                    </div>
                    
                    <div class="section-title" onclick="toggleSection(this)" data-section="roads" style="font-size:0.9em;">Roads <span class="section-count" id="countRoads">(2/5)</span></div>
                    <div class="section-content">
                        <label class="checkbox-item">
                            <input type="checkbox" id="primaryRoads" checked onchange="updateSectionCounts()">
                            Primary <span class="feature-size" id="size-primaryRoads"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="secondaryRoads" checked onchange="updateSectionCounts()">
                            Secondary <span class="feature-size" id="size-secondaryRoads"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="tertiaryRoads" onchange="updateSectionCounts()">
                            Tertiary <span class="feature-size" id="size-tertiaryRoads"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="residentialRoads" onchange="updateSectionCounts()">
                            Residential <span class="feature-size" id="size-residentialRoads"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="serviceRoads" onchange="updateSectionCounts()">
                            Service <span class="feature-size" id="size-serviceRoads"></span>
                        </label>
                    </div>
                    
                    <div class="section-title collapsed" onclick="toggleSection(this)" data-section="paths" style="font-size:0.9em;">Paths <span class="section-count" id="countPaths">(0/3)</span></div>
                    <div class="section-content collapsed">
                        <label class="checkbox-item">
                            <input type="checkbox" id="footways" onchange="updateSectionCounts()">
                            Footways <span class="feature-size" id="size-footways"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="cycleways" onchange="updateSectionCounts()">
                            Bike Paths <span class="feature-size" id="size-cycleways"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="tracks" onchange="updateSectionCounts()">
                            Trails <span class="feature-size" id="size-tracks"></span>
                        </label>
                    </div>
                    
                    <div class="section-title" onclick="toggleSection(this)" data-section="water" style="font-size:0.9em;">Water <span class="section-count" id="countWater">(1/3)</span></div>
                    <div class="section-content">
                        <label class="checkbox-item">
                            <input type="checkbox" id="waterBodies" checked onchange="updateSectionCounts()">
                            Lakes/Ponds <span class="feature-size" id="size-waterBodies"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="waterways" onchange="updateSectionCounts()">
                            Rivers <span class="feature-size" id="size-waterways"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="coastlines" onchange="updateSectionCounts()">
                            Coastlines <span class="feature-size" id="size-coastlines"></span>
                        </label>
                    </div>
                    
                    <div class="section-title collapsed" onclick="toggleSection(this)" data-section="nature" style="font-size:0.9em;">Nature <span class="section-count" id="countNature">(0/3)</span></div>
                    <div class="section-content collapsed">
                        <label class="checkbox-item">
                            <input type="checkbox" id="parks" onchange="updateSectionCounts()">
                            Parks <span class="feature-size" id="size-parks"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="forests" onchange="updateSectionCounts()">
                            Forests <span class="feature-size" id="size-forests"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="grassland" onchange="updateSectionCounts()">
                            Grassland <span class="feature-size" id="size-grassland"></span>
                        </label>
                    </div>
                    
                    <div class="section-title collapsed" onclick="toggleSection(this)" data-section="infrastructure" style="font-size:0.9em;">Infrastructure <span class="section-count" id="countInfrastructure">(0/4)</span></div>
                    <div class="section-content collapsed">
                        <label class="checkbox-item">
                            <input type="checkbox" id="railways" onchange="updateSectionCounts()">
                            Railways <span class="feature-size" id="size-railways"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="subways" onchange="updateSectionCounts()">
                            Subways <span class="feature-size" id="size-subways"></span>
                        </label>
                        <div id="subwayRoutesList" style="display:none;grid-column:span 2;font-size:0.75em;max-height:120px;overflow-y:auto;background:#0d0d1a;border-radius:4px;padding:6px;margin:4px 0;"></div>
                        <label class="checkbox-item">
                            <input type="checkbox" id="bridges" onchange="updateSectionCounts()">
                            Bridges <span class="feature-size" id="size-bridges"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="powerlines" onchange="updateSectionCounts()">
                            Power Lines <span class="feature-size" id="size-powerlines"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="buildings" onchange="updateSectionCounts(); updateBuildingSubOptions();">
                            Buildings <span class="feature-size" id="size-buildings"></span>
                        </label>
                        <label class="checkbox-item building-sub-option" id="buildingsLargeOnlyLabel" style="grid-column: span 2; font-size: 0.85em; padding-left: 20px; opacity: 0.4;">
                            <input type="checkbox" id="buildingsLargeOnly" onchange="updateSectionCounts()" disabled>
                            Large only <span class="feature-size" id="size-buildingsLargeOnly"></span>
                        </label>
                        <label class="checkbox-item building-sub-option" id="buildingNamesLabel" style="grid-column: span 2; font-size: 0.85em; padding-left: 20px; opacity: 0.4;">
                            <input type="checkbox" id="buildingNames" onchange="updateSectionCounts()" disabled>
                            Include names
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="industrial" onchange="updateSectionCounts()">
                            Industrial <span class="feature-size" id="size-industrial"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="commercial" onchange="updateSectionCounts()">
                            Commercial <span class="feature-size" id="size-commercial"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="residential" onchange="updateSectionCounts()">
                            Residential <span class="feature-size" id="size-residential"></span>
                        </label>
                    </div>
                </div>
                
                <!-- Post-Processing Section -->
                <div class="section-title" onclick="toggleSection(this)" data-section="postprocessing" style="background:#2a2a4e;margin-bottom:0;">
                    Output Settings
                </div>
                <div class="section-content" id="outputSettingsContent" style="display:block;padding:10px 12px;background:#1a1a2e;border-radius:0 0 4px 4px;margin-bottom:12px;">
                    <div class="slider-group" style="margin-bottom:12px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                            <label style="font-size:0.85em;color:#aaa;">Detail Level</label>
                            <span class="slider-value" id="detailValue" style="font-size:0.85em;color:#4cc9f0;">Low</span>
                        </div>
                        <input type="range" id="detailLevel" min="1" max="5" value="2" style="width:100%;">
                    </div>
                    
                    <div class="slider-group" style="margin-bottom:12px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                            <label style="font-size:0.85em;color:#aaa;">Max Points per Feature</label>
                            <span class="slider-value" id="maxPointsValue" style="font-size:0.85em;color:#4cc9f0;">15</span>
                        </div>
                        <input type="range" id="maxPoints" min="5" max="50" step="5" value="15" style="width:100%;">
                    </div>
                    
                    <div class="slider-group" style="margin-bottom:12px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                            <label style="font-size:0.85em;color:#aaa;">Max Features</label>
                            <span class="slider-value" id="maxFeaturesValue" style="font-size:0.85em;color:#4cc9f0;">20000</span>
                        </div>
                        <input type="range" id="maxFeatures" min="100" max="20000" step="100" value="20000" style="width:100%;">
                        <div style="font-size:0.7em;color:#666;margin-top:4px;">
                            Limit total features (drops least important first)
                        </div>
                    </div>
                    
                    <div class="slider-group" style="margin-bottom:8px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                            <label style="font-size:0.85em;color:#aaa;">Name Detail</label>
                            <span class="slider-value" id="nameDetailValue" style="font-size:0.85em;color:#4cc9f0;">Major Roads</span>
                        </div>
                        <input type="range" id="nameDetail" min="0" max="4" value="2" style="width:100%;">
                        <div style="font-size:0.7em;color:#666;margin-top:4px;" id="nameDetailDesc">
                            Highways + major roads get names for "where am I" context
                        </div>
                    </div>
                    
                    <div style="margin:16px 0 12px 0;padding-top:12px;border-top:1px solid #333;">
                        <div style="font-size:0.85em;color:#aaa;margin-bottom:8px;font-weight:bold;">Geometry Simplification</div>
                        <div style="font-size:0.7em;color:#666;margin-bottom:8px;">Reduce file size by simplifying complex shapes (recommended for memory-constrained devices)</div>
                        <div style="font-size:0.65em;color:#888;margin-bottom:8px;font-style:italic;">Note: Preview shows original OSM data. Simplification is applied during map generation.</div>
                        <label class="checkbox-item" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyBuildings" onchange="updateStats()">
                                <span>Buildings (rectangles only)</span>
                            </div>
                            <span id="simplifyBuildingsSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <label class="checkbox-item" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyResidential" onchange="updateStats()">
                                <span>Residential roads (straighter lines)</span>
                            </div>
                            <span id="simplifyResidentialSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <label class="checkbox-item" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyWater" onchange="updateStats()">
                                <span>Water bodies (simpler outlines)</span>
                            </div>
                            <span id="simplifyWaterSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <label class="checkbox-item" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:0;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyParks" onchange="updateStats()">
                                <span>Parks & nature (simpler boundaries)</span>
                            </div>
                            <span id="simplifyParksSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                    </div>
                    
                    <div class="slider-group" style="margin-bottom:12px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                            <label style="font-size:0.85em;color:#aaa;">Target Size Budget</label>
                            <span class="slider-value" id="budgetValue" style="font-size:0.85em;color:#4cc9f0;">500 KB</span>
                        </div>
                        <input type="range" id="sizeBudget" min="50" max="25000" step="50" value="500" style="width:100%;">
                        <div class="size-bar" style="margin-top:6px;">
                            <div class="size-bar-fill" id="sizeBarFill"></div>
                        </div>
                    </div>
                    
                    <label class="checkbox-item" style="font-size:0.85em;display:flex;align-items:center;gap:6px;margin-bottom:0;">
                        <input type="checkbox" id="autoFitBudget">
                        <span>Auto-trim to fit budget</span>
                    </label>
                </div>
                
                <div class="size-warning" id="sizeWarning">
                    Estimated size exceeds budget. Try reducing area or features.
                </div>
                
                <div class="stats">
                    <div class="stats-row">
                        <span>Area Size:</span>
                        <span class="stats-value" id="areaSize">-- × -- km</span>
                    </div>
                    <div class="stats-row">
                        <span>Estimated Size:</span>
                        <span class="stats-value" id="estSize">-- KB</span>
                    </div>
                    <div class="stats-row">
                        <span>Features:</span>
                        <span class="stats-value" id="featureCount">--</span>
                    </div>
                </div>
                
                <div id="sizeBreakdown" class="size-breakdown" style="display:none;margin-top:10px;padding:8px;background:#1a1a2e;border-radius:4px;font-size:0.8em;">
                    <div style="color:#888;margin-bottom:4px;">Size breakdown (est.):</div>
                    <div id="breakdownContent"></div>
                </div>
                
                <div id="mapFeaturesPanel" style="display:none;margin-top:10px;margin-bottom:12px;padding:10px;background:#1a1a2e;border-radius:4px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                        <span style="color:#4cc9f0;font-size:0.9em;font-weight:bold;">Names Found</span>
                        <span id="metadataSizeEst" style="font-size:0.75em;color:#888;"></span>
                    </div>
                    <div id="mapFeaturesList" style="font-size:0.8em;max-height:200px;overflow-y:auto;"></div>
                    <div id="nameSummary" style="margin-top:8px;padding-top:8px;border-top:1px solid #333;font-size:0.75em;color:#888;"></div>
                    <div id="buildingNameSummary" style="margin-top:4px;font-size:0.75em;color:#b197fc;"></div>
                </div>
                
                <div id="actualResults" class="size-breakdown" style="display:none;margin-top:10px;padding:8px;background:#1a2e1a;border:1px solid #69db7c;border-radius:4px;font-size:0.8em;">
                    <div style="color:#69db7c;margin-bottom:8px;font-weight:bold;display:flex;align-items:center;gap:4px;">
                        <span>✓</span>
                        <span>Generated Map File</span>
                    </div>
                    <div style="display:grid;grid-template-columns:auto 1fr;gap:4px 8px;color:#ddd;">
                        <span style="color:#888;">File Size:</span>
                        <span id="actualFileSize" style="color:#69db7c;font-weight:bold;">--</span>
                        
                        <span style="color:#888;">Features:</span>
                        <span id="actualFeatureCount">--</span>
                        
                        <span style="color:#888;">Named Features:</span>
                        <span id="actualNamedCount">--</span>
                        
                        <span style="color:#888;">Unique Names:</span>
                        <span id="actualNameCount">--</span>
                        
                        <span style="color:#888;">Total Points:</span>
                        <span id="actualPointCount">--</span>
                        
                        <span style="color:#888;">Max Points/Feature:</span>
                        <span id="actualMaxPoints">--</span>
                    </div>
                    <div style="margin-top:8px;padding-top:8px;border-top:1px solid #2a5a2a;">
                        <div style="color:#888;margin-bottom:4px;font-size:0.9em;">Size by Type:</div>
                        <div id="actualBreakdown"></div>
                    </div>
                </div>
                
                <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;">
                    <button class="btn btn-secondary" id="previewBtn" onclick="previewMap()" disabled style="flex:1;margin-bottom:0;">
                        Preview Selection
                    </button>
                    <label class="checkbox-item" style="font-size:0.8em;white-space:nowrap;" title="Auto-refresh preview when settings change">
                        <input type="checkbox" id="autoPreview" onchange="handleAutoPreviewToggle()">
                        Auto
                    </label>
                </div>
                
                <button class="btn btn-primary" id="generateBtn" onclick="generateMap()" disabled>
                    Generate Map File
                </button>
                
                <div class="progress-bar" id="progressBar">
                    <div class="progress-bar-fill" id="progressFill"></div>
                </div>
                
                <div class="status ready" id="status">
                    Draw a rectangle or polygon on the map to select area
                </div>
                
                <button class="btn btn-clear" id="clearBtn" onclick="clearSelection()" style="display:none;">
                    Clear Selection
                </button>
            </div>
        </div>
        
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    
    <script>
        // =============================================================================
        // MAP INITIALIZATION
        // =============================================================================
        
        const map = L.map('map').setView([40.7128, -74.0060], 13);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);
        
        // Drawing layer
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
        
        // Draw control - rectangle and polygon (click-to-place vertices)
        const drawControl = new L.Control.Draw({
            draw: {
                rectangle: {
                    shapeOptions: {
                        color: '#ff6b35',
                        weight: 5,
                        fillOpacity: 0.25,
                        fillColor: '#ffd93d',
                        dashArray: '10, 5'
                    }
                },
                polygon: {
                    allowIntersection: false,
                    shapeOptions: {
                        color: '#ff6b35',
                        weight: 5,
                        fillOpacity: 0.25,
                        fillColor: '#ffd93d',
                        dashArray: '10, 5'
                    },
                    showArea: true,
                    metric: true
                },
                circle: false,
                circlemarker: false,
                marker: false,
                polyline: false
            },
            edit: false
        });
        map.addControl(drawControl);
        
        // Current selection - can be bounds (rect) or polygon
        let selectedBounds = null;
        let selectedPolygon = null;
        
        // Preview layer for showing selected features
        let previewLayer = new L.LayerGroup();
        map.addLayer(previewLayer);
        
        // =============================================================================
        // WAYPOINT MANAGEMENT
        // =============================================================================
        
        let waypoints = [];
        let waypointMarkers = [];
        let waypointAddMode = false;
        let waypointIdCounter = 0;
        
        // Load waypoints from localStorage on startup
        function loadWaypointsFromStorage() {
            try {
                const stored = localStorage.getItem('mapgen_waypoints');
                if (stored) {
                    const data = JSON.parse(stored);
                    waypoints = data.waypoints || [];
                    waypointIdCounter = data.nextId || waypoints.length;
                    renderWaypointMarkers();
                    updateWaypointList();
                }
            } catch (e) {
                console.error('Failed to load waypoints:', e);
            }
        }
        
        // Save waypoints to localStorage
        function saveWaypointsToStorage() {
            try {
                const data = {
                    waypoints: waypoints,
                    nextId: waypointIdCounter,
                    savedAt: new Date().toISOString()
                };
                localStorage.setItem('mapgen_waypoints', JSON.stringify(data));
            } catch (e) {
                console.error('Failed to save waypoints:', e);
            }
        }
        
        // Toggle waypoint add mode
        function toggleWaypointMode() {
            waypointAddMode = document.getElementById('waypointAddMode').checked;
            if (waypointAddMode) {
                map.getContainer().style.cursor = 'crosshair';
                setStatus('Click on the map to add a waypoint', 'ready');
            } else {
                map.getContainer().style.cursor = '';
                setStatus('Draw a rectangle on the map to select area', 'ready');
            }
        }
        
        // Add waypoint at clicked location
        function addWaypoint(lat, lon, name) {
            const id = waypointIdCounter++;
            const waypoint = {
                id: id,
                name: name || `WP${waypoints.length + 1}`,
                lat: lat,
                lon: lon
            };
            waypoints.push(waypoint);
            saveWaypointsToStorage();
            renderWaypointMarkers();
            updateWaypointList();
            return waypoint;
        }
        
        // Delete waypoint by id
        function deleteWaypoint(id) {
            waypoints = waypoints.filter(wp => wp.id !== id);
            saveWaypointsToStorage();
            renderWaypointMarkers();
            updateWaypointList();
        }
        
        // Rename waypoint
        function renameWaypoint(id) {
            const wp = waypoints.find(w => w.id === id);
            if (!wp) return;
            
            const newName = prompt('Enter waypoint name:', wp.name);
            if (newName && newName.trim()) {
                wp.name = newName.trim().substring(0, 11);
                saveWaypointsToStorage();
                renderWaypointMarkers();
                updateWaypointList();
            }
        }
        
        // Clear all waypoints
        function clearAllWaypoints() {
            if (!waypoints.length) return;
            if (!confirm(`Delete all ${waypoints.length} waypoint(s)?`)) return;
            
            waypoints = [];
            saveWaypointsToStorage();
            renderWaypointMarkers();
            updateWaypointList();
        }
        
        // Render waypoint markers on map
        function renderWaypointMarkers() {
            // Clear existing markers
            waypointMarkers.forEach(marker => map.removeLayer(marker));
            waypointMarkers = [];
            
            // Add new markers
            waypoints.forEach(wp => {
                const marker = L.marker([wp.lat, wp.lon], {
                    icon: L.divIcon({
                        className: 'waypoint-marker',
                        html: `<div style="background:#ffd93d;width:12px;height:12px;border-radius:50%;border:2px solid #fff;box-shadow:0 2px 4px rgba(0,0,0,0.3);"></div>`,
                        iconSize: [16, 16],
                        iconAnchor: [8, 8]
                    })
                }).addTo(map);
                
                marker.bindPopup(`
                    <div style="font-family:system-ui,sans-serif;">
                        <strong>${wp.name}</strong><br>
                        <small>${wp.lat.toFixed(5)}, ${wp.lon.toFixed(5)}</small><br>
                        <button onclick="renameWaypoint(${wp.id})" style="margin-top:4px;padding:2px 6px;font-size:0.8em;">Rename</button>
                        <button onclick="deleteWaypoint(${wp.id})" style="margin-top:4px;padding:2px 6px;font-size:0.8em;background:#f44336;color:#fff;border:none;border-radius:3px;cursor:pointer;">Delete</button>
                    </div>
                `);
                
                waypointMarkers.push(marker);
            });
        }
        
        // Update waypoint list in sidebar
        function updateWaypointList() {
            const listEl = document.getElementById('waypointList');
            const countEl = document.getElementById('countWaypoints');
            
            countEl.textContent = `(${waypoints.length})`;
            
            if (waypoints.length === 0) {
                listEl.innerHTML = '<p style="color:#666;font-size:0.85em;text-align:center;padding:10px 0;">No waypoints yet</p>';
                return;
            }
            
            let html = '<div style="font-size:0.85em;">';
            waypoints.forEach(wp => {
                html += `
                    <div style="display:flex;justify-content:space-between;align-items:center;padding:4px 0;border-bottom:1px solid #333;">
                        <div style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${wp.name}">
                            📍 ${wp.name}
                        </div>
                        <div style="display:flex;gap:4px;">
                            <button onclick="renameWaypoint(${wp.id})" style="padding:2px 6px;font-size:0.75em;background:#2196F3;color:#fff;border:none;border-radius:3px;cursor:pointer;">✏️</button>
                            <button onclick="deleteWaypoint(${wp.id})" style="padding:2px 6px;font-size:0.75em;background:#f44336;color:#fff;border:none;border-radius:3px;cursor:pointer;">🗑️</button>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            listEl.innerHTML = html;
        }
        
        // Export waypoints to JSON file
        function exportWaypoints() {
            if (waypoints.length === 0) {
                alert('No waypoints to export');
                return;
            }
            
            const data = {
                waypoints: waypoints.map(wp => ({
                    name: wp.name,
                    lat: wp.lat,
                    lon: wp.lon
                })),
                exportedAt: new Date().toISOString(),
                version: 1
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const filename = `waypoints_${new Date().toISOString().split('T')[0]}.json`;
            downloadBlob(blob, filename);
        }
        
        // Import waypoints from JSON file
        function importWaypoints() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(evt) {
                    try {
                        const data = JSON.parse(evt.target.result);
                        if (!data.waypoints || !Array.isArray(data.waypoints)) {
                            alert('Invalid waypoint file format');
                            return;
                        }
                        
                        const importCount = data.waypoints.length;
                        if (!confirm(`Import ${importCount} waypoint(s)? This will add to existing waypoints.`)) {
                            return;
                        }
                        
                        data.waypoints.forEach(wp => {
                            if (wp.lat && wp.lon) {
                                addWaypoint(wp.lat, wp.lon, wp.name || 'Imported');
                            }
                        });
                        
                        alert(`Successfully imported ${importCount} waypoint(s)`);
                    } catch (err) {
                        alert('Failed to parse waypoint file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // Map click handler for adding waypoints
        map.on('click', function(e) {
            if (waypointAddMode) {
                const name = prompt('Enter waypoint name:', `WP${waypoints.length + 1}`);
                if (name !== null) {
                    addWaypoint(e.latlng.lat, e.latlng.lng, name || `WP${waypoints.length + 1}`);
                }
            }
        });
        
        // Load waypoints on startup
        loadWaypointsFromStorage();
        
        // Handle drawing events
        map.on(L.Draw.Event.CREATED, function(e) {
            drawnItems.clearLayers();
            previewLayer.clearLayers();
            drawnItems.addLayer(e.layer);
            selectedBounds = e.layer.getBounds();
            
            // Store polygon coordinates if it's a polygon
            if (e.layerType === 'polygon') {
                selectedPolygon = e.layer.getLatLngs()[0].map(ll => [ll.lat, ll.lng]);
            } else {
                selectedPolygon = null;
            }
            
            updateStats();
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('previewBtn').disabled = false;
            document.getElementById('clearBtn').style.display = 'block';
            setStatus('ready', 'Ready to preview or generate');
        });
        
        map.on(L.Draw.Event.DELETED, function(e) {
            selectedBounds = null;
            selectedPolygon = null;
            previewLayer.clearLayers();
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('previewBtn').disabled = true;
            document.getElementById('clearBtn').style.display = 'none';
            setStatus('ready', 'Draw a shape on the map to select area');
            clearStats();
        });
        
        // =============================================================================
        // UI FUNCTIONS
        // =============================================================================
        
        function toggleSection(titleEl) {
            titleEl.classList.toggle('collapsed');
            const content = titleEl.nextElementSibling;
            if (content && content.classList.contains('section-content')) {
                content.classList.toggle('collapsed');
            }
        }
        
        const AUTO_PREVIEW_DEBOUNCE_MS = 5000;
        let autoPreviewTimeout = null;
        let autoPreviewEnabled = false;
        
        function handleAutoPreviewToggle() {
            autoPreviewEnabled = document.getElementById('autoPreview').checked;
            if (!autoPreviewEnabled && autoPreviewTimeout) {
                clearTimeout(autoPreviewTimeout);
                autoPreviewTimeout = null;
            }
            if (autoPreviewEnabled && selectedBounds) {
                triggerAutoPreview();
            }
        }
        
        function triggerAutoPreview() {
            if (!autoPreviewEnabled || !selectedBounds) return;
            
            // Debounce - wait for changes to settle before contacting the API
            if (autoPreviewTimeout) {
                clearTimeout(autoPreviewTimeout);
            }
            autoPreviewTimeout = setTimeout(() => {
                previewMap();
            }, AUTO_PREVIEW_DEBOUNCE_MS);
        }
        
        function updateSimplificationStates() {
            // Map simplification checkboxes to their corresponding feature checkboxes
            const simplifyMapping = {
                simplifyBuildings: ['buildings', 'buildingsLargeOnly'],
                simplifyResidential: ['residentialRoads'],
                simplifyWater: ['waterBodies', 'waterways', 'coastlines'],
                simplifyParks: ['parks', 'forests', 'grassland']
            };
            
            for (const [simplifyId, featureIds] of Object.entries(simplifyMapping)) {
                const simplifyCheckbox = document.getElementById(simplifyId);
                if (!simplifyCheckbox) continue;
                
                // Check if ANY of the related features are checked
                const anyFeatureChecked = featureIds.some(id => document.getElementById(id)?.checked);
                
                // Enable/disable and style accordingly
                simplifyCheckbox.disabled = !anyFeatureChecked;
                const label = simplifyCheckbox.closest('label');
                if (label) {
                    if (anyFeatureChecked) {
                        label.style.opacity = '1';
                        label.style.cursor = 'pointer';
                    } else {
                        label.style.opacity = '0.4';
                        label.style.cursor = 'not-allowed';
                        // Uncheck if disabled
                        simplifyCheckbox.checked = false;
                    }
                }
            }
        }
        
        function updateBuildingSubOptions() {
            const buildingsChecked = document.getElementById('buildings')?.checked;
            const largeOnlyLabel = document.getElementById('buildingsLargeOnlyLabel');
            const largeOnlyCheckbox = document.getElementById('buildingsLargeOnly');
            const namesLabel = document.getElementById('buildingNamesLabel');
            const namesCheckbox = document.getElementById('buildingNames');
            
            if (largeOnlyLabel && largeOnlyCheckbox) {
                largeOnlyCheckbox.disabled = !buildingsChecked;
                largeOnlyLabel.style.opacity = buildingsChecked ? '1' : '0.4';
                largeOnlyLabel.style.cursor = buildingsChecked ? 'pointer' : 'not-allowed';
                if (!buildingsChecked) largeOnlyCheckbox.checked = false;
            }
            if (namesLabel && namesCheckbox) {
                namesCheckbox.disabled = !buildingsChecked;
                namesLabel.style.opacity = buildingsChecked ? '1' : '0.4';
                namesLabel.style.cursor = buildingsChecked ? 'pointer' : 'not-allowed';
                if (!buildingsChecked) namesCheckbox.checked = false;
            }
        }
        
        function updateSectionCounts() {
            const sections = {
                highways: ['motorways', 'trunkRoads'],
                roads: ['primaryRoads', 'secondaryRoads', 'tertiaryRoads', 'residentialRoads', 'serviceRoads'],
                paths: ['footways', 'cycleways', 'tracks'],
                water: ['waterBodies', 'waterways', 'coastlines'],
                nature: ['parks', 'forests', 'grassland'],
                infrastructure: ['railways', 'subways', 'bridges', 'powerlines', 'buildings', 'buildingsLargeOnly', 'industrial', 'commercial', 'residential']
            };
            
            for (const [section, ids] of Object.entries(sections)) {
                const checked = ids.filter(id => document.getElementById(id)?.checked).length;
                const total = ids.length;
                const el = document.getElementById('count' + section.charAt(0).toUpperCase() + section.slice(1));
                if (el) {
                    el.textContent = `(${checked}/${total})`;
                }
            }
            
            // Update simplification checkbox states
            updateSimplificationStates();
            
            // Also update stats when checkboxes change
            if (selectedBounds) {
                updateStats();
            }
            
            // Trigger auto-preview if enabled
            triggerAutoPreview();
        }
        
        function displayActualResults(result) {
            const { stats } = result;
            
            // Show the results panel
            document.getElementById('actualResults').style.display = 'block';
            
            // Format file size
            let sizeText;
            if (stats.fileSize >= 1024 * 1024) {
                sizeText = (stats.fileSize / (1024 * 1024)).toFixed(2) + ' MB';
            } else {
                sizeText = (stats.fileSize / 1024).toFixed(1) + ' KB';
            }
            
            // Update all fields
            document.getElementById('actualFileSize').textContent = sizeText;
            document.getElementById('actualFeatureCount').textContent = stats.featureCount.toLocaleString();
            document.getElementById('actualNamedCount').textContent = stats.namedCount.toLocaleString();
            document.getElementById('actualNameCount').textContent = stats.nameCount.toLocaleString();
            document.getElementById('actualPointCount').textContent = stats.totalPoints.toLocaleString();
            document.getElementById('actualMaxPoints').textContent = stats.maxPoints;
            
            // Build type breakdown HTML
            let breakdownHtml = '';
            if (stats.typeBreakdown) {
                // Sort by bytes descending
                const sorted = Object.entries(stats.typeBreakdown).sort((a, b) => b[1].bytes - a[1].bytes);
                for (const [typeName, data] of sorted) {
                    const kb = (data.bytes / 1024).toFixed(1);
                    const color = data.bytes > 50000 ? '#ff6b6b' : data.bytes > 20000 ? '#ffd93d' : '#69db7c';
                    breakdownHtml += `<div style="display:flex;justify-content:space-between;"><span>${typeName} <span style="color:#666;">(${data.count.toLocaleString()})</span></span><span style="color:${color}">${kb} KB</span></div>`;
                }
                // Add name table
                if (stats.nameTableSize > 0) {
                    const nameKb = (stats.nameTableSize / 1024).toFixed(1);
                    breakdownHtml += `<div style="display:flex;justify-content:space-between;margin-top:4px;border-top:1px solid #333;padding-top:4px;"><span style="color:#b197fc;">Name Table</span><span style="color:#b197fc;">${nameKb} KB</span></div>`;
                }
            }
            document.getElementById('actualBreakdown').innerHTML = breakdownHtml;
        }
        
        function clearSelection() {
            drawnItems.clearLayers();
            previewLayer.clearLayers();
            selectedBounds = null;
            selectedPolygon = null;
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('previewBtn').disabled = true;
            document.getElementById('clearBtn').style.display = 'none';
            document.getElementById('actualResults').style.display = 'none';
            setStatus('ready', 'Draw a shape on the map to select area');
            clearStats();
        }
        
        function useMyLocation() {
            if (!navigator.geolocation) {
                setStatus('error', 'Geolocation not supported');
                return;
            }
            
            setStatus('working', 'Getting location...');
            
            const options = {
                enableHighAccuracy: false,  // false is faster and works better on desktop
                timeout: 10000,             // 10 second timeout
                maximumAge: 300000          // Accept cached position up to 5 min old
            };
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    map.setView([lat, lon], 14);
                    setStatus('ready', 'Centered on your location');
                },
                (error) => {
                    let msg = 'Could not get location';
                    if (error.code === 1) {
                        msg = 'Location access denied. Check browser settings.';
                    } else if (error.code === 2) {
                        msg = 'Location unavailable. Try again.';
                    } else if (error.code === 3) {
                        msg = 'Location request timed out. Try again.';
                    }
                    setStatus('error', msg);
                },
                options
            );
        }
        
        function setStatus(type, message) {
            const status = document.getElementById('status');
            status.className = 'status ' + type;
            status.textContent = message;
        }
        
        function setProgress(percent) {
            const bar = document.getElementById('progressBar');
            const fill = document.getElementById('progressFill');
            bar.classList.add('active');
            fill.style.width = percent + '%';
        }
        
        function hideProgress() {
            document.getElementById('progressBar').classList.remove('active');
        }
        
        function updateStats() {
            if (!selectedBounds) return;
            
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            
            // Calculate area in km
            const widthKm = haversineDistance(sw.lat, sw.lng, sw.lat, ne.lng);
            const heightKm = haversineDistance(sw.lat, sw.lng, ne.lat, sw.lng);
            
            document.getElementById('areaSize').textContent = 
                widthKm.toFixed(1) + ' × ' + heightKm.toFixed(1) + ' km';
            
            // Estimate size
            const areaKm2 = widthKm * heightKm;
            const estKB = estimateSize(areaKm2);
            if (estKB >= 1024) {
                document.getElementById('estSize').textContent = (estKB / 1024).toFixed(2) + ' MB';
            } else {
                document.getElementById('estSize').textContent = estKB + ' KB';
            }
            
            // Update size warning
            updateSizeWarning(estKB);
            
            // Feature count - cap by max features limit
            const maxFeaturesLimit = parseInt(document.getElementById('maxFeatures').value);
            const rawEstimate = Math.round(areaKm2 * 50);
            const cappedEstimate = Math.min(rawEstimate, maxFeaturesLimit);
            document.getElementById('featureCount').textContent = rawEstimate > maxFeaturesLimit 
                ? `~${cappedEstimate} (limited)` 
                : `~${cappedEstimate}`;
        }
        
        function clearStats() {
            document.getElementById('areaSize').textContent = '-- × -- km';
            document.getElementById('estSize').textContent = '-- KB';
            document.getElementById('featureCount').textContent = '--';
        }
        
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function estimateSize(areaKm2) {
            const detailLevel = parseInt(document.getElementById('detailLevel').value);
            const maxPoints = parseInt(document.getElementById('maxPoints').value);
            const nameDetailLevel = parseInt(document.getElementById('nameDetail').value);
            const maxFeaturesLimit = parseInt(document.getElementById('maxFeatures').value);
            const detailMultiplier = [0.4, 0.6, 1.0, 1.5, 2.0][detailLevel - 1];
            
            // Name overhead percentages by level
            const namePercent = [0, 0.05, 0.15, 0.40, 0.80][nameDetailLevel];
            const avgNameLen = 18;
            
            // Binary format: 13 bytes base + (avgPts-1)*4 for deltas
            // With maxPoints limiting, avgPts is typically ~2 for maxPoints=5
            const avgPtsActual = Math.max(2, Math.min(maxPoints, 3)); // Most features end up with 2-3 points after limiting
            const bytesPerFeature = 13 + (avgPtsActual - 1) * 4; // ~17 bytes for maxPoints=5
            
            // Feature type density per km² (independent estimates) - calibrated to match actual output
            const featureDensity = {
                motorways: { density: 1, name: 'Motorways' },
                trunkRoads: { density: 3, name: 'Trunk Roads' },
                primaryRoads: { density: 8, name: 'Primary Roads' },
                secondaryRoads: { density: 15, name: 'Secondary Roads' },
                tertiaryRoads: { density: 30, name: 'Tertiary Roads' },
                serviceRoads: { density: 60, name: 'Service Roads' },
                footways: { density: 45, name: 'Footways' },
                cycleways: { density: 15, name: 'Cycleways' },
                tracks: { density: 25, name: 'Tracks' },
                waterBodies: { density: 6, name: 'Lakes/Ponds', simplifyCheckbox: 'simplifyWater' },
                waterways: { density: 10, name: 'Rivers', simplifyCheckbox: 'simplifyWater' },
                coastlines: { density: 3, name: 'Coastlines', simplifyCheckbox: 'simplifyWater' },
                parks: { density: 10, name: 'Parks', simplifyCheckbox: 'simplifyParks' },
                forests: { density: 6, name: 'Forests', simplifyCheckbox: 'simplifyParks' },
                grassland: { density: 6, name: 'Grassland', simplifyCheckbox: 'simplifyParks' },
                railways: { density: 6, name: 'Railways' },
                subways: { density: 10, name: 'Subways' },
                bridges: { density: 3, name: 'Bridges' },
                powerlines: { density: 10, name: 'Power Lines' },
                buildings: { density: 300, name: 'Buildings', simplifyCheckbox: 'simplifyBuildings' },
                buildingsLargeOnly: { density: 30, name: 'Buildings (Large)', simplifyCheckbox: 'simplifyBuildings' },
                residentialRoads: { density: 120, name: 'Residential', simplifyCheckbox: 'simplifyResidential' },
                industrial: { density: 6, name: 'Industrial' },
                commercial: { density: 6, name: 'Commercial' },
                residential: { density: 6, name: 'Residential Areas' }
            };
            
            // Calculate bytes for each feature type independently
            let breakdownHtml = '';
            let totalBytes = 0;
            let totalFeatures = 0;
            const simplifySavings = {
                simplifyBuildings: 0,
                simplifyResidential: 0,
                simplifyWater: 0,
                simplifyParks: 0
            };
            
            for (const [id, info] of Object.entries(featureDensity)) {
                const el = document.getElementById(id);
                const sizeEl = document.getElementById('size-' + id);
                
                // Calculate feature count for this type based on area and density
                const featureCount = Math.round(areaKm2 * info.density * detailMultiplier);
                let featureBytes = featureCount * bytesPerFeature;
                
                // Track simplification savings (always calculate for display)
                if (info.simplifyCheckbox) {
                    const simplifyChecked = document.getElementById(info.simplifyCheckbox)?.checked;
                    const unsimplifiedBytes = featureBytes;
                    if (simplifyChecked) {
                        const reductionFactor = (info.simplifyCheckbox === 'simplifyWater' || info.simplifyCheckbox === 'simplifyParks') ? 0.7 : 0.5;
                        featureBytes = Math.round(featureBytes * reductionFactor);
                    }
                    // Calculate potential savings for this feature type
                    if (el && el.checked) {
                        const potentialSavings = Math.round(unsimplifiedBytes * (info.simplifyCheckbox === 'simplifyWater' || info.simplifyCheckbox === 'simplifyParks' ? 0.3 : 0.5));
                        simplifySavings[info.simplifyCheckbox] += potentialSavings;
                    }
                }
                
                const kb = Math.round(featureBytes / 1024);
                
                // Update inline size indicator (always, for all features)
                if (sizeEl && areaKm2 > 0) {
                    const sizeClass = kb > 50 ? 'large' : kb > 20 ? 'medium' : 'small';
                    sizeEl.textContent = kb > 0 ? `(${kb}KB)` : '';
                    sizeEl.className = 'feature-size ' + sizeClass;
                } else if (sizeEl) {
                    sizeEl.textContent = '';
                }
                
                // Add to total only if checked
                if (el && el.checked) {
                    totalBytes += featureBytes;
                    totalFeatures += featureCount;
                    
                    if (kb > 0) {
                        const color = kb > 50 ? '#ff6b6b' : kb > 20 ? '#ffd93d' : '#69db7c';
                        breakdownHtml += `<div style="display:flex;justify-content:space-between;"><span>${info.name}</span><span style="color:${color}">${kb} KB</span></div>`;
                        
                        // Add building names sub-item
                        if ((id === 'buildings' || id === 'buildingsLargeOnly') && document.getElementById('buildingNames')?.checked) {
                            if (window.extractedMetadata?.namedFeatures?.buildings) {
                                let nameBytes = 0;
                                for (const f of window.extractedMetadata.namedFeatures.buildings) nameBytes += (f.bytes || 20);
                                const nameKB = (nameBytes / 1024).toFixed(1);
                                if (nameBytes > 0) {
                                    breakdownHtml += `<div style="display:flex;justify-content:space-between;padding-left:12px;"><span style="color:#b197fc;">+ names</span><span style="color:#b197fc;">${nameKB} KB</span></div>`;
                                }
                            } else {
                                breakdownHtml += '<div style="display:flex;justify-content:space-between;padding-left:12px;"><span style="color:#888;">+ names</span><span style="color:#888;">preview to see</span></div>';
                            }
                        }
                    }
                }
            }
            
            // Add road/terrain names entry based on Name Detail level
            const currentNameLevel = parseInt(document.getElementById('nameDetail').value);
            if (currentNameLevel > 0 && window.extractedMetadata?.namedFeatures) {
                const nf = window.extractedMetadata.namedFeatures;
                let roadNameBytes = 0;
                let roadNameCount = 0;
                
                // Level 1: Highways only
                if (currentNameLevel >= 1 && nf.highways) {
                    for (const f of nf.highways) roadNameBytes += (f.bytes || 20);
                    roadNameCount += nf.highways.length;
                }
                // Level 2+: Major roads
                if (currentNameLevel >= 2 && nf.roads) {
                    for (const f of nf.roads) roadNameBytes += (f.bytes || 20);
                    roadNameCount += nf.roads.length;
                }
                // Level 4: Everything (water, parks, railways)
                if (currentNameLevel >= 4) {
                    if (nf.water) { for (const f of nf.water) roadNameBytes += (f.bytes || 20); roadNameCount += nf.water.length; }
                    if (nf.parks) { for (const f of nf.parks) roadNameBytes += (f.bytes || 20); roadNameCount += nf.parks.length; }
                    if (nf.railways) { for (const f of nf.railways) roadNameBytes += (f.bytes || 20); roadNameCount += nf.railways.length; }
                }
                
                if (roadNameBytes > 0) {
                    const roadNameKB = (roadNameBytes / 1024).toFixed(1);
                    breakdownHtml += `<div style="display:flex;justify-content:space-between;"><span style="color:#ffd93d;">+ names</span><span style="color:#ffd93d;">${roadNameKB} KB</span></div>`;
                    totalBytes += roadNameBytes;
                }
            }
            
            // Apply max features limit - scale down if over limit
            let estFeatures = totalFeatures;
            let scale = 1;
            if (estFeatures > maxFeaturesLimit) {
                scale = maxFeaturesLimit / estFeatures;
                totalBytes = Math.round(totalBytes * scale);
                // Scale savings too
                for (const key of Object.keys(simplifySavings)) {
                    simplifySavings[key] = Math.round(simplifySavings[key] * scale);
                }
                estFeatures = maxFeaturesLimit;
            }
            
            // Add name table overhead
            const estNamedFeatures = Math.round(estFeatures * namePercent);
            const estUniqueNames = Math.round(estNamedFeatures * 0.15); // ~15% unique names among named features
            const nameTableBytes = estUniqueNames * (avgNameLen + 1);
            const nameIndexBytes = estFeatures * 2;
            totalBytes += nameTableBytes + nameIndexBytes;
            
            // Scale breakdown values if limited
            let scaledBreakdownHtml = '';
            if (breakdownHtml && areaKm2 > 0) {
                // Parse the breakdown HTML and scale values
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = breakdownHtml;
                const rows = tempDiv.querySelectorAll('div[style*="display:flex"]');
                
                for (const row of rows) {
                    const spans = row.querySelectorAll('span');
                    if (spans.length === 2) {
                        const name = spans[0].textContent;
                        const sizeText = spans[1].textContent;
                        const kb = parseFloat(sizeText);
                        if (!isNaN(kb)) {
                            const scaledKb = Math.round(kb * scale);
                            const color = scaledKb > 50 ? '#ff6b6b' : scaledKb > 20 ? '#ffd93d' : '#69db7c';
                            scaledBreakdownHtml += `<div style="display:flex;justify-content:space-between;"><span>${name}</span><span style="color:${color}">${scaledKb} KB</span></div>`;
                        } else {
                            scaledBreakdownHtml += `<div style="display:flex;justify-content:space-between;"><span>${name}</span><span>${sizeText}</span></div>`;
                        }
                    }
                }
            }
            
            // Show breakdown
            const breakdownDiv = document.getElementById('sizeBreakdown');
            const contentDiv = document.getElementById('breakdownContent');
            if (scaledBreakdownHtml && areaKm2 > 0) {
                contentDiv.innerHTML = scaledBreakdownHtml;
                breakdownDiv.style.display = 'block';
            } else {
                breakdownDiv.style.display = 'none';
            }
            
            // Update simplification savings displays - show potential savings even when unchecked
            const simplifyMapping = {
                simplifyBuildings: ['buildings', 'buildingsLargeOnly'],
                simplifyResidential: ['residentialRoads'],
                simplifyWater: ['waterBodies', 'waterways', 'coastlines'],
                simplifyParks: ['parks', 'forests', 'grassland']
            };
            
            for (const [checkboxId, savingsBytes] of Object.entries(simplifySavings)) {
                const savingsEl = document.getElementById(checkboxId + 'Savings');
                const checkbox = document.getElementById(checkboxId);
                if (savingsEl && checkbox) {
                    // Check if any related features are checked
                    const featureIds = simplifyMapping[checkboxId] || [];
                    const anyFeatureChecked = featureIds.some(id => document.getElementById(id)?.checked);
                    
                    if (anyFeatureChecked && savingsBytes > 0) {
                        const savingsKB = Math.round(savingsBytes / 1024);
                        // Show in gray if not checked, green if checked
                        if (checkbox.checked) {
                            savingsEl.textContent = `-${savingsKB} KB`;
                            savingsEl.style.color = '#69db7c';
                        } else {
                            savingsEl.textContent = `save ${savingsKB} KB`;
                            savingsEl.style.color = '#888';
                        }
                    } else {
                        savingsEl.textContent = '';
                    }
                }
            }
            
            return Math.round(totalBytes / 1024);
        }
        
        function updateSizeWarning(estKB) {
            const budget = parseInt(document.getElementById('sizeBudget').value);
            const warning = document.getElementById('sizeWarning');
            const barFill = document.getElementById('sizeBarFill');
            const percent = Math.min(100, (estKB / budget) * 100);
            
            barFill.style.width = percent + '%';
            barFill.className = 'size-bar-fill';
            
            if (estKB > budget * 1.5) {
                barFill.classList.add('danger');
                warning.classList.add('active');
            } else if (estKB > budget) {
                barFill.classList.add('warning');
                warning.classList.add('active');
            } else {
                warning.classList.remove('active');
            }
        }
        
        function updateDetailLabel() {
            const level = parseInt(document.getElementById('detailLevel').value);
            const labels = ['Minimal', 'Low', 'Medium', 'High', 'Maximum'];
            document.getElementById('detailValue').textContent = labels[level - 1];
        }
        
        function updateBudgetLabel() {
            const budget = parseInt(document.getElementById('sizeBudget').value);
            if (budget >= 1000) {
                document.getElementById('budgetValue').textContent = (budget / 1000).toFixed(1) + ' MB';
            } else {
                document.getElementById('budgetValue').textContent = budget + ' KB';
            }
        }
        
        // =============================================================================
        // API RETRY HELPER
        // =============================================================================
        
        // Multiple Overpass API servers for fallback
        const OVERPASS_SERVERS = [
            'https://overpass-api.de/api/interpreter',
            'https://overpass.kumi.systems/api/interpreter'
  
        ];
        let currentServerIndex = 0;
        
        async function fetchWithRetry(url, options, maxRetries = 2) {
            let lastError;
            
            // Try current server first
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        // 429 = rate limit, 504 = timeout
                        if (response.status === 429 || response.status === 504) {
                            throw new Error('Server overloaded: ' + response.status);
                        }
                        throw new Error('API error: ' + response.status);
                    }
                    return response;
                } catch (error) {
                    lastError = error;
                    console.warn(`Attempt ${attempt}/${maxRetries} on server ${currentServerIndex + 1} failed:`, error.message);
                    if (attempt < maxRetries) {
                        setStatus('working', `Retry ${attempt}/${maxRetries}... Server busy`);
                        await new Promise(r => setTimeout(r, 2000 * attempt)); // Longer backoff
                    }
                }
            }
            
            // If all retries failed, try next server
            if (currentServerIndex < OVERPASS_SERVERS.length - 1) {
                currentServerIndex++;
                console.warn(`Switching to backup server ${currentServerIndex + 1}/${OVERPASS_SERVERS.length}`);
                setStatus('working', `Trying backup server ${currentServerIndex + 1}...`);
                await new Promise(r => setTimeout(r, 1000)); // Brief pause before switching
                return fetchWithRetry(OVERPASS_SERVERS[currentServerIndex], options, maxRetries);
            }
            
            // All servers failed
            currentServerIndex = 0; // Reset for next time
            throw new Error('All API servers are currently overloaded. Please wait a few minutes and try again.');
        }
        
        // =============================================================================
        // PREVIEW FUNCTION
        // =============================================================================
        
        // Colors for preview matching the device viewer
        const PREVIEW_COLORS = {
            highway: { color: '#ff6b6b', weight: 4 },      // Motorways, trunk
            major: { color: '#ffd93d', weight: 3 },        // Primary, secondary
            minor: { color: '#ffffff', weight: 2 },        // Tertiary, residential
            path: { color: '#aaaaaa', weight: 1, dashArray: '4,4' },  // Footways, etc.
            water: { color: '#4dabf7', weight: 2 },
            park: { color: '#69db7c', weight: 2 },
            railway: { color: '#da77f2', weight: 2, dashArray: '8,4' },
            building: { color: '#868e96', weight: 1, fillColor: '#495057', fillOpacity: 0.5 }
        };
        
        function closePreview() {
            document.getElementById('previewPanel').classList.remove('active');
        }
        
        function renderPreview() {
            if (!window.previewData || !selectedBounds) return;
            
            const canvas = document.getElementById('previewCanvas');
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');
            
            // Black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Use bounds stored WITH the data to ensure consistency
            const storedBounds = window.previewData.bounds;
            const storedPolygon = window.previewData.polygon;
            const minLat = storedBounds.minLat;
            const maxLat = storedBounds.maxLat;
            const minLon = storedBounds.minLon;
            const maxLon = storedBounds.maxLon;
            
            console.log('Using stored bounds:', storedBounds);
            console.log('Using stored polygon:', storedPolygon ? storedPolygon.length + ' points' : 'none');
            
            // Point-in-polygon test (same as in filter)
            function pointInPolygon(lon, lat, polygon) {
                if (!polygon || polygon.length < 3) return true;
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const yi = polygon[i][0], xi = polygon[i][1];
                    const yj = polygon[j][0], xj = polygon[j][1];
                    if (((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }
                return inside;
            }
            
            function inSelection(lon, lat) {
                if (lon < minLon || lon > maxLon || lat < minLat || lat > maxLat) return false;
                if (storedPolygon) return pointInPolygon(lon, lat, storedPolygon);
                return true;
            }
            
            // Padding
            const padding = 20;
            const drawWidth = canvas.width - padding * 2;
            const drawHeight = canvas.height - padding * 2;
            
            // Scale to fit while maintaining aspect ratio
            const latRange = maxLat - minLat;
            const lonRange = maxLon - minLon;
            const latScale = drawHeight / latRange;
            const lonScale = drawWidth / lonRange;
            const baseScale = Math.min(latScale, lonScale);
            const scale = baseScale * window.previewZoom;
            
            // Center offset with pan
            const offsetX = padding + (drawWidth - lonRange * scale) / 2 + window.previewPanX;
            const offsetY = padding + (drawHeight - latRange * scale) / 2 + window.previewPanY;
            
            function toCanvasX(lon) {
                return offsetX + (lon - minLon) * scale;
            }
            function toCanvasY(lat) {
                return canvas.height - (offsetY + (lat - minLat) * scale);
            }
            
            // HARD CLIP using canvas - this WILL work
            const clipX = toCanvasX(minLon);
            const clipY = toCanvasY(maxLat);
            const clipW = toCanvasX(maxLon) - clipX;
            const clipH = toCanvasY(minLat) - clipY;
            
            // Draw features - MANUALLY clip by not drawing outside bounds
            let featureCount = 0;
            for (const element of window.previewData.elements) {
                if (element.type !== 'way' || !element.geometry) continue;
                
                const coords = element.geometry;
                if (coords.length < 2) continue;
                
                const style = getPreviewStyle(element.tags);
                if (!style) continue;
                
                ctx.strokeStyle = style.color;
                // Don't scale line width with zoom - keep lines thin when zoomed in
                ctx.lineWidth = Math.max(1, Math.min(style.weight || 1, 2));
                if (style.dashArray) {
                    ctx.setLineDash(style.dashArray.split(',').map(n => Number(n)));
                } else {
                    ctx.setLineDash([]);
                }
                
                // Only draw points that are STRICTLY inside selection (polygon or bounds)
                ctx.beginPath();
                let inPath = false;
                for (const p of coords) {
                    // STRICT selection check (polygon or bounds)
                    if (!inSelection(p.lon, p.lat)) {
                        // Outside selection - end current path segment
                        if (inPath) {
                            ctx.stroke();
                            ctx.beginPath();
                            inPath = false;
                        }
                        continue;
                    }
                    
                    const cx = toCanvasX(p.lon), cy = toCanvasY(p.lat);
                    if (!inPath) {
                        ctx.moveTo(cx, cy);
                        inPath = true;
                    } else {
                        ctx.lineTo(cx, cy);
                    }
                }
                if (inPath) ctx.stroke();
                featureCount++;
            }
            
            console.log('Features rendered:', featureCount);
            
            // Draw text labels for named features (buildings, roads) with collision avoidance
            const buildingNamesChecked = document.getElementById('buildingNames')?.checked;
            const nameDetailLevel = parseInt(document.getElementById('nameDetail').value);
            
            if (buildingNamesChecked || nameDetailLevel > 0) {
                const labelRects = []; // Track placed labels to avoid overlap
                const minZoomForLabels = 5.0; // Only show labels when zoomed in enough
                
                // Font size scales slightly with zoom but caps out
                const baseFontSize = Math.min(12, 8 + window.previewZoom);
                ctx.font = `${baseFontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Check if a new label would overlap existing ones
                function wouldOverlap(x, y, width, height) {
                    const padding = 4;
                    const newRect = { 
                        x: x - width/2 - padding, 
                        y: y - height/2 - padding, 
                        w: width + padding*2, 
                        h: height + padding*2 
                    };
                    for (const rect of labelRects) {
                        if (newRect.x < rect.x + rect.w && newRect.x + newRect.w > rect.x &&
                            newRect.y < rect.y + rect.h && newRect.y + newRect.h > rect.y) {
                            return true;
                        }
                    }
                    return false;
                }
                
                // Only render labels if zoomed in enough
                if (window.previewZoom >= minZoomForLabels) {
                    for (const element of window.previewData.elements) {
                        if (element.type !== 'way' || !element.geometry || !element.tags) continue;
                        
                        const name = element.tags.name;
                        if (!name) continue;
                        
                        // Check if this feature type should show labels
                        const isBuilding = element.tags.building;
                        const isRoad = element.tags.highway;
                        
                        if (isBuilding && !buildingNamesChecked) continue;
                        if (isRoad && nameDetailLevel === 0) continue;
                        
                        // Calculate centroid of the feature
                        let sumLon = 0, sumLat = 0, count = 0;
                        for (const p of element.geometry) {
                            if (inSelection(p.lon, p.lat)) {
                                sumLon += p.lon;
                                sumLat += p.lat;
                                count++;
                            }
                        }
                        if (count === 0) continue;
                        
                        const cx = toCanvasX(sumLon / count);
                        const cy = toCanvasY(sumLat / count);
                        
                        // Skip if centroid is outside canvas
                        if (cx < 0 || cx > canvas.width || cy < 0 || cy > canvas.height) continue;
                        
                        // Truncate long names
                        const displayName = name.length > 20 ? name.substring(0, 18) + '...' : name;
                        const textWidth = ctx.measureText(displayName).width;
                        const textHeight = baseFontSize;
                        
                        // Skip if would overlap
                        if (wouldOverlap(cx, cy, textWidth, textHeight)) continue;
                        
                        // Draw label with background
                        const bgColor = isBuilding ? 'rgba(177, 151, 252, 0.85)' : 'rgba(255, 217, 61, 0.85)';
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(cx - textWidth/2 - 3, cy - textHeight/2 - 2, textWidth + 6, textHeight + 4);
                        
                        ctx.fillStyle = '#000';
                        ctx.fillText(displayName, cx, cy);
                        
                        // Record this label's position
                        labelRects.push({ x: cx - textWidth/2, y: cy - textHeight/2, w: textWidth, h: textHeight });
                    }
                }
                
                console.log('Labels rendered:', labelRects.length);
            }
            
            // Draw bounds border (cyan) to show exact clip region
            ctx.strokeStyle = '#4cc9f0';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            const bx1 = toCanvasX(minLon), by1 = toCanvasY(maxLat);
            const bx2 = toCanvasX(maxLon), by2 = toCanvasY(minLat);
            ctx.strokeRect(bx1, by1, bx2 - bx1, by2 - by1);
            
            // Debug log bounds
            console.log('Preview bounds:', {minLat, maxLat, minLon, maxLon});
            console.log('Canvas clip rect:', {bx1, by1, width: bx2-bx1, height: by2-by1});
            
            window.previewFeatureCount = featureCount;
        }
        
        function zoomPreview(factor) {
            if (!window.previewData) return;
            window.previewZoom *= factor;
            window.previewZoom = Math.max(0.5, Math.min(20.0, window.previewZoom)); // Limit 0.5x to 20x
            renderPreview();
        }
        
        function resetPreviewZoom() {
            if (!window.previewData) return;
            window.previewZoom = 1.0;
            window.previewPanX = 0;
            window.previewPanY = 0;
            renderPreview();
        }
        
        // Pan support with mouse drag
        (function setupPreviewPan() {
            let isDragging = false;
            let lastX, lastY;
            
            const container = document.getElementById('previewContainer');
            if (!container) return;
            
            container.addEventListener('mousedown', (e) => {
                if (!window.previewData) return;
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!isDragging || !window.previewData) return;
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                window.previewPanX += dx;
                window.previewPanY -= dy;
                lastX = e.clientX;
                lastY = e.clientY;
                renderPreview();
            });
            
            container.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            container.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // Mouse wheel zoom with cursor tracking
            container.addEventListener('wheel', (e) => {
                if (!window.previewData) return;
                e.preventDefault();
                
                const canvas = document.getElementById('previewCanvas');
                const rect = canvas.getBoundingClientRect();
                
                // Get mouse position relative to canvas center
                const mouseX = e.clientX - rect.left - rect.width / 2;
                const mouseY = e.clientY - rect.top - rect.height / 2;
                
                // Calculate zoom factor
                const factor = e.deltaY < 0 ? 1.1 : 0.9;
                const oldZoom = window.previewZoom;
                const newZoom = Math.max(0.5, Math.min(20.0, oldZoom * factor));
                
                // Adjust pan to keep mouse position stable
                if (newZoom !== oldZoom) {
                    const zoomRatio = newZoom / oldZoom;
                    window.previewPanX = mouseX + (window.previewPanX - mouseX) * zoomRatio;
                    window.previewPanY = mouseY + (window.previewPanY - mouseY) * zoomRatio;
                    window.previewZoom = newZoom;
                    renderPreview();
                }
            });
        })();
        
        function extractMetadataFromData(data) {
            // Extract all named features for the Map Features panel
            const namedFeatures = {
                highways: [],
                roads: [],
                water: [],
                parks: [],
                railways: [],
                buildings: []
            };
            let totalMetadataBytes = 0;
            
            // Extract subway route relations
            const subwayRoutes = [];
            for (const el of (data.elements || [])) {
                if (el.type === 'relation' && el.tags && el.tags.route === 'subway') {
                    subwayRoutes.push({
                        ref: el.tags.ref || '?',
                        name: el.tags.name || 'Unknown',
                        colour: el.tags.colour || el.tags.color || '#da77f2',
                        network: el.tags.network || '',
                        operator: el.tags.operator || ''
                    });
                }
            }
            
            for (const el of (data.elements || [])) {
                if (el.type !== 'way' || !el.tags) continue;
                
                const name = el.tags.name;
                const ref = el.tags.ref;
                if (!name && !ref) continue;
                
                const label = ref ? (name ? `${ref} - ${name}` : ref) : name;
                const bytes = (label || '').length + 1;
                
                if (el.tags.highway) {
                    if (['motorway', 'trunk', 'motorway_link', 'trunk_link'].includes(el.tags.highway)) {
                        if (!namedFeatures.highways.find(f => f.label === label)) {
                            namedFeatures.highways.push({ label, ref, name, bytes });
                            totalMetadataBytes += bytes;
                        }
                    } else if (['primary', 'secondary', 'tertiary', 'residential'].includes(el.tags.highway)) {
                        if (!namedFeatures.roads.find(f => f.label === label)) {
                            namedFeatures.roads.push({ label, ref, name, bytes });
                            totalMetadataBytes += bytes;
                        }
                    }
                } else if (el.tags.natural === 'water' || el.tags.waterway) {
                    if (!namedFeatures.water.find(f => f.label === label)) {
                        namedFeatures.water.push({ label, ref, name, bytes });
                        totalMetadataBytes += bytes;
                    }
                } else if (el.tags.leisure === 'park' || el.tags.landuse === 'grass') {
                    if (!namedFeatures.parks.find(f => f.label === label)) {
                        namedFeatures.parks.push({ label, ref, name, bytes });
                        totalMetadataBytes += bytes;
                    }
                } else if (el.tags.railway) {
                    if (!namedFeatures.railways.find(f => f.label === label)) {
                        namedFeatures.railways.push({ label, ref, name, bytes });
                        totalMetadataBytes += bytes;
                    }
                } else if (el.tags.building) {
                    if (!namedFeatures.buildings.find(f => f.label === label)) {
                        namedFeatures.buildings.push({ label, ref, name, bytes });
                        totalMetadataBytes += bytes;
                    }
                }
            }
            
            // Add subway routes to metadata size
            for (const r of subwayRoutes) {
                totalMetadataBytes += (r.name || '').length + (r.ref || '').length + 2;
            }
            
            // Display Map Features panel
            const featuresPanel = document.getElementById('mapFeaturesPanel');
            const featuresList = document.getElementById('mapFeaturesList');
            const nameDetailLevel = parseInt(document.getElementById('nameDetail').value);
            const buildingNamesChecked = document.getElementById('buildingNames')?.checked || false;
            const totalNamedFeatures = namedFeatures.highways.length + namedFeatures.roads.length + 
                namedFeatures.water.length + namedFeatures.parks.length + namedFeatures.railways.length + 
                namedFeatures.buildings.length + subwayRoutes.length;
            
            if (totalNamedFeatures > 0 && (nameDetailLevel > 0 || buildingNamesChecked)) {
                const indexOverhead = totalNamedFeatures * 4;
                const totalWithOverhead = totalMetadataBytes + indexOverhead;
                
                document.getElementById('metadataSizeEst').textContent = 
                    `+${(totalWithOverhead / 1024).toFixed(1)} KB if included`;
                
                let html = '';
                const addSection = (title, items, color) => {
                    if (items.length === 0) return;
                    html += `<div style="margin-bottom:8px;">`;
                    html += `<div style="color:${color};font-weight:bold;margin-bottom:4px;">${title} (${items.length})</div>`;
                    html += `<div style="color:#aaa;padding-left:8px;">`;
                    const shown = items.slice(0, 10);
                    html += shown.map(f => `<div style="margin:1px 0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${f.label}">${f.label}</div>`).join('');
                    if (items.length > 10) {
                        html += `<div style="color:#666;font-style:italic;">...and ${items.length - 10} more</div>`;
                    }
                    html += `</div></div>`;
                };
                
                addSection('Highways', namedFeatures.highways, '#ff6b6b');
                addSection('Roads', namedFeatures.roads, '#ffd93d');
                addSection('Water', namedFeatures.water, '#4dabf7');
                addSection('Parks', namedFeatures.parks, '#69db7c');
                addSection('Railways', namedFeatures.railways, '#da77f2');
                
                featuresList.innerHTML = html;
                featuresPanel.style.display = 'block';
                
                // Store for use in binary generation and size estimates
                window.extractedMetadata = {
                    namedFeatures,
                    subwayRoutes: subwayRoutes,
                    totalBytes: totalWithOverhead
                };
            } else {
                featuresPanel.style.display = 'none';
                window.extractedMetadata = null;
            }
            
            // Display subway routes if any found
            const routesList = document.getElementById('subwayRoutesList');
            if (subwayRoutes.length > 0) {
                subwayRoutes.sort((a, b) => a.ref.localeCompare(b.ref, undefined, {numeric: true}));
                const seen = new Set();
                const uniqueRoutes = subwayRoutes.filter(r => {
                    if (seen.has(r.ref)) return false;
                    seen.add(r.ref);
                    return true;
                });
                
                routesList.innerHTML = '<div style="color:#4cc9f0;margin-bottom:4px;">Detected Routes:</div>' +
                    uniqueRoutes.map(r => 
                        `<div style="display:flex;align-items:center;gap:6px;margin:2px 0;">` +
                        `<span style="background:${r.colour};color:#fff;padding:1px 6px;border-radius:3px;font-weight:bold;min-width:24px;text-align:center;">${r.ref}</span>` +
                        `<span style="color:#aaa;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${r.name}">${r.name}</span>` +
                        `</div>`
                    ).join('');
                routesList.style.display = 'block';
            } else {
                routesList.style.display = 'none';
            }
            
            return { namedFeatures, subwayRoutes, totalMetadataBytes };
        }
        
        async function previewMap() {
            if (!selectedBounds) {
                setStatus('error', 'Please select an area first');
                return;
            }
            
            const btn = document.getElementById('previewBtn');
            btn.disabled = true;
            btn.textContent = '⏳ Loading...';
            setStatus('working', 'Fetching preview from OpenStreetMap...');
            
            try {
                const query = buildOverpassQuery();
                const response = await fetchWithRetry(OVERPASS_SERVERS[currentServerIndex], {
                    method: 'POST',
                    body: query
                });
                
                const data = await response.json();
                
                // Extract metadata using shared function
                extractMetadataFromData(data);
                
                // CLIP ALL GEOMETRY TO BOUNDS (and polygon if drawn) before storing
                const bounds = selectedBounds;
                const minLat = bounds.getSouth(), maxLat = bounds.getNorth();
                const minLon = bounds.getWest(), maxLon = bounds.getEast();
                
                console.log('=== CLIPPING DEBUG ===');
                console.log('Clip bounds:', {minLat, maxLat, minLon, maxLon});
                console.log('Polygon selection:', selectedPolygon ? selectedPolygon.length + ' points' : 'none (rectangle)');
                
                // Point-in-polygon test using ray casting
                function pointInPolygon(lon, lat, polygon) {
                    if (!polygon || polygon.length < 3) return true; // No polygon = use bounds only
                    let inside = false;
                    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                        const yi = polygon[i][0], xi = polygon[i][1]; // [lat, lng]
                        const yj = polygon[j][0], xj = polygon[j][1];
                        if (((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
                            inside = !inside;
                        }
                    }
                    return inside;
                }
                
                // Check if point is inside selection (polygon or bounds)
                function inSelection(lon, lat) {
                    // First check bounding box (fast)
                    if (lon < minLon || lon > maxLon || lat < minLat || lat > maxLat) return false;
                    // Then check polygon if exists
                    if (selectedPolygon) {
                        return pointInPolygon(lon, lat, selectedPolygon);
                    }
                    return true;
                }
                
                const clippedElements = [];
                let stats = {total: 0, kept: 0, dropped: 0, badAfter: 0};
                
                for (const el of (data.elements || [])) {
                    if (el.type !== 'way' || !el.geometry || el.geometry.length < 2) continue;
                    
                    // STRICT: Only keep points inside selection (polygon or bounds)
                    const filteredGeom = [];
                    for (const p of el.geometry) {
                        stats.total++;
                        if (inSelection(p.lon, p.lat)) {
                            filteredGeom.push({lon: p.lon, lat: p.lat});
                            stats.kept++;
                        } else {
                            stats.dropped++;
                        }
                    }
                    
                    if (filteredGeom.length >= 2) {
                        clippedElements.push({...el, geometry: filteredGeom});
                    }
                }
                
                // VERIFY no bad points remain
                for (const el of clippedElements) {
                    for (const p of el.geometry) {
                        if (!inSelection(p.lon, p.lat)) {
                            stats.badAfter++;
                            console.error('BAD POINT AFTER FILTER:', p);
                        }
                    }
                }
                
                console.log('Stats:', stats);
                console.log('Elements kept:', clippedElements.length);
                
                // Clear any old data and store filtered data (include polygon if exists)
                window.previewData = null;
                window.previewData = {
                    elements: clippedElements, 
                    bounds: {minLon, maxLon, minLat, maxLat},
                    polygon: selectedPolygon ? [...selectedPolygon] : null
                };
                window.previewZoom = 1.0;
                window.previewPanX = 0;
                window.previewPanY = 0;
                
                // Show preview panel FIRST so canvas has proper dimensions
                document.getElementById('previewPanel').classList.add('active');
                
                // Render after panel is visible (use requestAnimationFrame to ensure layout is complete)
                requestAnimationFrame(() => {
                    renderPreview();
                    document.getElementById('featureCount').textContent = window.previewFeatureCount || 0;
                    setStatus('ready', 'Preview: ' + (window.previewFeatureCount || 0) + ' features. Adjust settings and regenerate, or generate file.');
                    
                    // Update stats to refresh size breakdown with actual building names data
                    updateStats();
                });
                
            } catch (error) {
                setStatus('error', 'Preview error: ' + error.message);
                console.error(error);
            } finally {
                btn.disabled = false;
                btn.textContent = '👁️ Preview Selection';
            }
        }
        
        function getPreviewStyle(tags) {
            if (!tags) return null;
            
            if (tags.highway) {
                if (['motorway', 'motorway_link', 'trunk', 'trunk_link'].includes(tags.highway)) {
                    return PREVIEW_COLORS.highway;
                }
                if (['primary', 'secondary', 'primary_link', 'secondary_link'].includes(tags.highway)) {
                    return PREVIEW_COLORS.major;
                }
                if (['tertiary', 'tertiary_link', 'residential', 'unclassified', 'service', 'living_street'].includes(tags.highway)) {
                    return PREVIEW_COLORS.minor;
                }
                if (['footway', 'path', 'cycleway', 'track', 'pedestrian', 'steps', 'bridleway'].includes(tags.highway)) {
                    return PREVIEW_COLORS.path;
                }
            }
            if (tags.railway) return PREVIEW_COLORS.railway;
            if (tags.natural === 'water' || tags.waterway) return PREVIEW_COLORS.water;
            if (tags.leisure === 'park' || tags.landuse) return PREVIEW_COLORS.park;
            if (tags.building) return PREVIEW_COLORS.building;
            
            return null;
        }
        
        // =============================================================================
        // MAP GENERATION
        // =============================================================================
        
        // Debug mode - set to true to enable verbose logging
        const DEBUG = true;
        
        function debugLog(category, message, data = null) {
            if (!DEBUG) return;
            const timestamp = new Date().toISOString().substr(11, 12);
            const prefix = `[${timestamp}] [${category}]`;
            if (data !== null) {
                console.log(prefix, message, data);
            } else {
                console.log(prefix, message);
            }
        }
        
        async function generateMap() {
            if (!selectedBounds) {
                setStatus('error', 'Please select an area first');
                return;
            }
            
            const btn = document.getElementById('generateBtn');
            btn.disabled = true;
            setStatus('working', 'Fetching map data from OpenStreetMap...');
            setProgress(10);
            
            debugLog('INIT', '=== Starting map generation ===');
            debugLog('BOUNDS', 'Selected bounds:', {
                sw: selectedBounds.getSouthWest(),
                ne: selectedBounds.getNorthEast()
            });
            
            try {
                // Build Overpass query
                const query = buildOverpassQuery();
                debugLog('QUERY', 'Overpass query:', query);
                setProgress(20);
                
                // Fetch data with retry
                debugLog('FETCH', 'Fetching from Overpass API...');
                const response = await fetchWithRetry(OVERPASS_SERVERS[currentServerIndex], {
                    method: 'POST',
                    body: query
                });
                
                setStatus('working', 'Parsing response...');
                setProgress(50);
                
                const data = await response.json();
                debugLog('FETCH', 'Received elements:', data.elements?.length || 0);
                
                // Extract metadata for display (same as preview)
                extractMetadataFromData(data);
                updateStats();
                
                setStatus('working', 'Converting to binary format...');
                setProgress(70);
                
                // Convert to binary
                const hwmapResult = convertToHWMap(data);
                debugLog('OUTPUT', 'Generated blob size:', hwmapResult.blob.size + ' bytes');
                
                setProgress(90);
                
                // Download file
                const regionName = document.getElementById('regionName').value || 'map';
                const filename = regionName.toLowerCase().replace(/[^a-z0-9]/g, '_') + '.hwmap';
                
                downloadBlob(hwmapResult.blob, filename);
                
                // Display actual results
                displayActualResults(hwmapResult);
                
                setProgress(100);
                setStatus('success', 'Download started! Upload to device at /maps/');
                debugLog('DONE', '=== Map generation complete ===');
                
            } catch (error) {
                debugLog('ERROR', 'Generation failed:', {
                    message: error.message,
                    stack: error.stack
                });
                setStatus('error', 'Error: ' + error.message);
                console.error(error);
            } finally {
                btn.disabled = false;
                setTimeout(hideProgress, 1000);
            }
        }
        
        function buildOverpassQuery() {
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            const bbox = `${sw.lat},${sw.lng},${ne.lat},${ne.lng}`;
            
            let query = `[out:json][bbox:${bbox}];(\n`;
            
            // Highways
            if (document.getElementById('motorways').checked) {
                query += `way["highway"~"motorway|motorway_link"];\n`;
            }
            if (document.getElementById('trunkRoads').checked) {
                query += `way["highway"~"trunk|trunk_link"];\n`;
            }
            
            // Roads
            if (document.getElementById('primaryRoads').checked) {
                query += `way["highway"~"primary|primary_link"];\n`;
            }
            if (document.getElementById('secondaryRoads').checked) {
                query += `way["highway"~"secondary|secondary_link"];\n`;
            }
            if (document.getElementById('tertiaryRoads').checked) {
                query += `way["highway"~"tertiary|tertiary_link"];\n`;
            }
            if (document.getElementById('residentialRoads').checked) {
                query += `way["highway"~"residential|unclassified"];\n`;
            }
            if (document.getElementById('serviceRoads').checked) {
                query += `way["highway"="service"];\n`;
            }
            
            // Paths
            if (document.getElementById('footways').checked) {
                query += `way["highway"~"footway|pedestrian|steps"];\n`;
            }
            if (document.getElementById('cycleways').checked) {
                query += `way["highway"="cycleway"];\n`;
            }
            if (document.getElementById('tracks').checked) {
                query += `way["highway"~"track|path"];\n`;
            }
            
            // Water
            if (document.getElementById('waterBodies').checked) {
                query += `way["natural"="water"];\n`;
            }
            if (document.getElementById('waterways').checked) {
                query += `way["waterway"~"river|stream|canal"];\n`;
            }
            if (document.getElementById('coastlines').checked) {
                query += `way["natural"="coastline"];\n`;
            }
            
            // Nature
            if (document.getElementById('parks').checked) {
                query += `way["leisure"="park"];\nway["landuse"="grass"];\n`;
            }
            if (document.getElementById('forests').checked) {
                query += `way["landuse"~"forest|wood"];\nway["natural"="wood"];\n`;
            }
            if (document.getElementById('grassland').checked) {
                query += `way["landuse"~"meadow|grassland"];\nway["natural"~"grassland|heath"];\n`;
            }
            
            // Infrastructure
            if (document.getElementById('railways').checked) {
                query += `way["railway"~"rail|light_rail|tram"];\n`;
            }
            if (document.getElementById('subways').checked) {
                // Direct subway track ways
                query += `way["railway"="subway"];\n`;
                // Subway route relations (NYC, London, etc store routes as relations)
                query += `relation["route"="subway"];\n`;
            }
            if (document.getElementById('bridges').checked) {
                query += `way["bridge"="yes"];\n`;
            }
            if (document.getElementById('powerlines').checked) {
                query += `way["power"~"line|minor_line"];\n`;
            }
            
            // Land Use
            if (document.getElementById('buildings').checked) {
                query += `way["building"];\n`;
            }
            if (document.getElementById('buildingsLargeOnly').checked) {
                // Filter for large buildings: 3+ floors OR 200m²+ area
                query += `way["building"]["building:levels"~"^[3-9]$|^[1-9][0-9]+$"];\n`;
                query += `way["building"](if:number(t["building:levels"])>=3);\n`;
                query += `way["building"](if:area()>=200);\n`;
            }
            if (document.getElementById('industrial').checked) {
                query += `way["landuse"="industrial"];\n`;
            }
            if (document.getElementById('commercial').checked) {
                query += `way["landuse"~"commercial|retail"];\n`;
            }
            if (document.getElementById('residential').checked) {
                query += `way["landuse"="residential"];\n`;
            }
            
            // Use recursion to expand relation members into ways
            query += `);(._;>;);out geom;`;
            return query;
        }
        
        // =============================================================================
        // BINARY CONVERSION - HWMAP v2 FORMAT
        // =============================================================================
        // 
        // v2 Format:
        //   Header (40 bytes):
        //     Magic: "HWMP" (4), Version: uint16 (2), Flags: uint16 (2)
        //     Bounds: minLat, minLon, maxLat, maxLon (4×int32 = 16)
        //     FeatureCount: uint32 (4), NameCount: uint16 (2)
        //     RegionName: char[8] (8), Padding: 2 bytes
        //   
        //   Name Table (variable):
        //     For each name: Length: uint8, String: char[Length]
        //   
        //   Features (variable):
        //     Type: uint8, NameIndex: uint16 (0xFFFF = unnamed), PointCount: uint8
        //     FirstPoint: lat + lon (2×int32), DeltaPoints: (N-1) × (dLat + dLon as int16)
        //
        // =============================================================================
        
        // Feature types matching device-side enum
        const FEATURE_TYPES = {
            ROAD_HIGHWAY: 0x00,
            ROAD_MAJOR: 0x01,
            ROAD_MINOR: 0x02,
            ROAD_PATH: 0x03,
            WATER: 0x10,
            PARK: 0x11,
            RAILWAY: 0x20,
            BUILDING: 0x30
        };
        
        const HWMAP_NO_NAME = 0xFFFF;  // Marker for unnamed features
        
        function convertToHWMap(osmData) {
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            const regionName = document.getElementById('regionName').value.substring(0, 7); // Max 7 chars + null
            
            debugLog('CONVERT', '=== Starting HWMAP v2 conversion ===');
            debugLog('CONVERT', 'Input elements:', osmData.elements?.length || 0);
            
            // Process features
            let features = [];
            const detailLevel = parseInt(document.getElementById('detailLevel').value);
            const maxPointsPerFeature = parseInt(document.getElementById('maxPoints').value);
            const autoFitBudget = document.getElementById('autoFitBudget').checked;
            const budgetBytes = parseInt(document.getElementById('sizeBudget').value) * 1024;
            
            // More aggressive tolerances for smaller files
            const tolerances = [0.001, 0.0005, 0.0002, 0.0001, 0.00005];
            const tolerance = tolerances[detailLevel - 1];
            
            debugLog('CONVERT', 'Detail level:', detailLevel, 'Tolerance:', tolerance);
            debugLog('CONVERT', 'Max points per feature:', maxPointsPerFeature);
            debugLog('CONVERT', 'Auto-fit budget:', autoFitBudget, 'Budget:', budgetBytes, 'bytes');
            
            // Name detail level: 0=none, 1=highways, 2=major roads, 3=all roads, 4=everything
            const nameDetailLevel = parseInt(document.getElementById('nameDetail').value);
            debugLog('CONVERT', 'Name detail level:', nameDetailLevel);
            
            // Name table: map name string -> index, and list of unique names
            const nameMap = new Map();  // name -> index
            const nameList = [];        // ordered list of unique names
            
            // Check if a feature type should get a name based on name detail level
            const includeBuildingNames = document.getElementById('buildingNames')?.checked || false;
            
            function shouldIncludeName(featureType) {
                // Building names controlled by separate checkbox
                if (featureType === FEATURE_TYPES.BUILDING) {
                    return includeBuildingNames;
                }
                
                if (nameDetailLevel === 0) return false;  // None
                if (nameDetailLevel === 1) {
                    // Highways only
                    return featureType === FEATURE_TYPES.ROAD_HIGHWAY;
                }
                if (nameDetailLevel === 2) {
                    // Major roads (highways + major)
                    return featureType === FEATURE_TYPES.ROAD_HIGHWAY || 
                           featureType === FEATURE_TYPES.ROAD_MAJOR;
                }
                if (nameDetailLevel === 3) {
                    // All roads
                    return featureType === FEATURE_TYPES.ROAD_HIGHWAY || 
                           featureType === FEATURE_TYPES.ROAD_MAJOR ||
                           featureType === FEATURE_TYPES.ROAD_MINOR ||
                           featureType === FEATURE_TYPES.ROAD_PATH;
                }
                // Level 4 = everything (except buildings, handled above)
                return true;
            }
            
            function getOrAddName(name, featureType) {
                if (!name || name.length === 0) return HWMAP_NO_NAME;
                if (!shouldIncludeName(featureType)) return HWMAP_NO_NAME;
                
                // Truncate to 63 chars max (stored as uint8 length)
                const truncated = name.substring(0, 63);
                if (nameMap.has(truncated)) {
                    return nameMap.get(truncated);
                }
                const idx = nameList.length;
                nameMap.set(truncated, idx);
                nameList.push(truncated);
                return idx;
            }
            
            let skippedNoGeom = 0;
            let skippedNoType = 0;
            let skippedTooShort = 0;
            
            // Feature priority (lower = more important, keep first)
            const typePriority = {
                0x00: 1,  // Highway - most important
                0x01: 2,  // Major road
                0x10: 3,  // Water (landmarks)
                0x20: 4,  // Railway
                0x02: 5,  // Minor road
                0x11: 6,  // Park
                0x03: 7,  // Path - least important road
                0x30: 8   // Building - least important
            };
            
            for (const element of osmData.elements) {
                if (element.type !== 'way' || !element.geometry) {
                    skippedNoGeom++;
                    continue;
                }
                
                const featureType = classifyFeature(element.tags);
                if (featureType === null) {
                    skippedNoType++;
                    continue;
                }
                
                // Simplify geometry based on detail level
                let points = simplifyPoints(element.geometry, tolerance);
                if (points.length < 2) {
                    skippedTooShort++;
                    continue;
                }
                
                // Extra aggressive simplification for buildings (reduce to 4-6 points max)
                const simplifyBuildingsChecked = document.getElementById('simplifyBuildings')?.checked;
                if (featureType === FEATURE_TYPES.BUILDING && simplifyBuildingsChecked) {
                    // Buildings are usually rectangles - simplify to bounding box or minimal polygon
                    if (points.length > 6) {
                        // Use more aggressive tolerance for buildings
                        points = simplifyPoints(element.geometry, tolerance * 5);
                        // If still too many points, reduce to 4 (bounding box)
                        if (points.length > 6) {
                            points = resamplePoints(points, 4);
                        }
                    }
                }
                
                // Aggressive simplification for residential roads (reduce to 3-4 points)
                const simplifyResidentialChecked = document.getElementById('simplifyResidential')?.checked;
                if (featureType === FEATURE_TYPES.ROAD_MINOR && simplifyResidentialChecked) {
                    // Residential roads often have many small curves - simplify aggressively
                    if (points.length > 4) {
                        // Use 3x more aggressive tolerance for residential roads
                        points = simplifyPoints(element.geometry, tolerance * 3);
                        // If still too many points, reduce to 4 max
                        if (points.length > 4) {
                            points = resamplePoints(points, 4);
                        }
                    }
                }
                
                // Simplification for water bodies (reduce to 6-8 points)
                const simplifyWaterChecked = document.getElementById('simplifyWater')?.checked;
                if (featureType === FEATURE_TYPES.WATER && simplifyWaterChecked) {
                    // Water bodies can have very complex coastlines - simplify moderately
                    if (points.length > 8) {
                        // Use 2x more aggressive tolerance for water
                        points = simplifyPoints(element.geometry, tolerance * 2);
                        // If still too many points, reduce to 8 max
                        if (points.length > 8) {
                            points = resamplePoints(points, 8);
                        }
                    }
                }
                
                // Simplification for parks/nature (reduce to 6-8 points)
                const simplifyParksChecked = document.getElementById('simplifyParks')?.checked;
                if (featureType === FEATURE_TYPES.PARK && simplifyParksChecked) {
                    // Parks often have irregular boundaries - simplify moderately
                    if (points.length > 8) {
                        // Use 2x more aggressive tolerance for parks
                        points = simplifyPoints(element.geometry, tolerance * 2);
                        // If still too many points, reduce to 8 max
                        if (points.length > 8) {
                            points = resamplePoints(points, 8);
                        }
                    }
                }
                
                // Limit points per feature
                if (points.length > maxPointsPerFeature) {
                    points = resamplePoints(points, maxPointsPerFeature);
                }
                
                // Extract name from OSM tags (ref takes priority for highways)
                let featureName = null;
                if (element.tags) {
                    if (element.tags.ref && element.tags.name) {
                        featureName = element.tags.ref + ' ' + element.tags.name;
                    } else {
                        featureName = element.tags.ref || element.tags.name || null;
                    }
                }
                const nameIndex = getOrAddName(featureName, featureType);
                
                // Calculate feature length for priority sorting
                let length = 0;
                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].lon - points[i-1].lon;
                    const dy = points[i].lat - points[i-1].lat;
                    length += Math.sqrt(dx*dx + dy*dy);
                }
                
                features.push({
                    type: featureType,
                    points: points,
                    nameIndex: nameIndex,
                    priority: typePriority[featureType] || 99,
                    length: length
                });
            }
            
            debugLog('CONVERT', 'Skipped - no geometry:', skippedNoGeom);
            debugLog('CONVERT', 'Skipped - no type match:', skippedNoType);
            debugLog('CONVERT', 'Skipped - too short:', skippedTooShort);
            debugLog('CONVERT', 'Features before trimming:', features.length);
            debugLog('CONVERT', 'Unique names collected:', nameList.length);
            
            // Sort by priority (important first), then by length (longer = more important)
            features.sort((a, b) => {
                if (a.priority !== b.priority) return a.priority - b.priority;
                return b.length - a.length; // Longer roads first within same priority
            });
            
            // Apply max features limit (drops least important)
            const maxFeatures = parseInt(document.getElementById('maxFeatures').value);
            if (features.length > maxFeatures) {
                debugLog('CONVERT', 'Limiting from', features.length, 'to', maxFeatures, 'features');
                features = features.slice(0, maxFeatures);
            }
            
            // Calculate name table size
            let nameTableSize = 0;
            for (const name of nameList) {
                nameTableSize += 1 + name.length; // length byte + string bytes
            }
            
            // Auto-fit to budget by dropping least important features
            // v2 feature size: type(1) + nameIndex(2) + pointCount(1) + firstPoint(8) + deltas((n-1)*4)
            let trimmedFeatures = features;
            if (autoFitBudget) {
                let currentSize = 40 + nameTableSize; // Header + name table
                trimmedFeatures = [];
                for (const f of features) {
                    const featureSize = 4 + 8 + (f.points.length - 1) * 4; // type + nameIdx + count + points
                    if (currentSize + featureSize <= budgetBytes) {
                        trimmedFeatures.push(f);
                        currentSize += featureSize;
                    }
                }
                debugLog('CONVERT', 'Trimmed to budget:', trimmedFeatures.length, 'features,', currentSize, 'bytes');
            }
            
            debugLog('CONVERT', 'Final feature count:', trimmedFeatures.length);
            
            // Rebuild name table with only names used by trimmed features
            const usedNameIndices = new Set();
            for (const f of trimmedFeatures) {
                if (f.nameIndex !== HWMAP_NO_NAME) {
                    usedNameIndices.add(f.nameIndex);
                }
            }
            
            // Create compact name list and remap indices
            const finalNameList = [];
            const indexRemap = new Map();
            for (const oldIdx of Array.from(usedNameIndices).sort((a, b) => a - b)) {
                indexRemap.set(oldIdx, finalNameList.length);
                finalNameList.push(nameList[oldIdx]);
            }
            
            // Update feature name indices
            for (const f of trimmedFeatures) {
                if (f.nameIndex !== HWMAP_NO_NAME) {
                    f.nameIndex = indexRemap.get(f.nameIndex);
                }
            }
            
            debugLog('CONVERT', 'Names after trimming:', finalNameList.length);
            
            // Log point distribution and track bytes per feature type
            let totalPoints = 0;
            let maxPts = 0;
            let namedCount = 0;
            const typeBreakdown = {};
            const typeNames = {
                [FEATURE_TYPES.ROAD_HIGHWAY]: 'Highways',
                [FEATURE_TYPES.ROAD_MAJOR]: 'Major Roads',
                [FEATURE_TYPES.ROAD_MINOR]: 'Minor Roads',
                [FEATURE_TYPES.ROAD_PATH]: 'Paths',
                [FEATURE_TYPES.WATER]: 'Water',
                [FEATURE_TYPES.PARK]: 'Parks/Nature',
                [FEATURE_TYPES.RAILWAY]: 'Railways',
                [FEATURE_TYPES.BUILDING]: 'Buildings'
            };
            for (const f of trimmedFeatures) {
                totalPoints += f.points.length;
                if (f.points.length > maxPts) maxPts = f.points.length;
                if (f.nameIndex !== HWMAP_NO_NAME) namedCount++;
                // Track bytes per type: type(1) + nameIdx(2) + count(1) + firstPt(8) + deltas((n-1)*4)
                const featureBytes = 4 + 8 + (f.points.length - 1) * 4;
                const typeName = typeNames[f.type] || 'Other';
                if (!typeBreakdown[typeName]) typeBreakdown[typeName] = { bytes: 0, count: 0 };
                typeBreakdown[typeName].bytes += featureBytes;
                typeBreakdown[typeName].count++;
            }
            debugLog('CONVERT', 'Total points:', totalPoints, 'Max points per feature:', maxPts);
            debugLog('CONVERT', 'Named features:', namedCount, '/', trimmedFeatures.length);
            
            // Update feature count display
            document.getElementById('featureCount').textContent = trimmedFeatures.length;
            
            // Calculate name table size (final)
            let finalNameTableSize = 0;
            for (const name of finalNameList) {
                finalNameTableSize += 1 + name.length;
            }
            
            // Calculate buffer size for v2 format
            // Header: 4 (magic) + 2 (version) + 2 (flags) + 16 (bounds) + 4 (featureCount) + 2 (nameCount) + 8 (regionName) + 2 (padding) = 40
            let bufferSize = 40; // Header
            bufferSize += finalNameTableSize; // Name table
            for (const f of trimmedFeatures) {
                bufferSize += 4 + 8 + (f.points.length - 1) * 4; // type + nameIdx + count + first point + deltas
            }
            
            debugLog('BUFFER', 'Calculated buffer size:', bufferSize + ' bytes');
            debugLog('BUFFER', 'Header: 40, Names:', finalNameTableSize, 'Features:', bufferSize - 40 - finalNameTableSize);
            
            // Create buffer
            const buffer = new ArrayBuffer(bufferSize);
            const view = new DataView(buffer);
            let offset = 0;
            
            // Write v2 header (40 bytes)
            // Magic "HWMP"
            view.setUint8(offset++, 0x48); // H
            view.setUint8(offset++, 0x57); // W
            view.setUint8(offset++, 0x4D); // M
            view.setUint8(offset++, 0x50); // P
            
            // Version = 2
            view.setUint16(offset, 2, true);
            offset += 2;
            
            // Flags (reserved for future use)
            view.setUint16(offset, 0, true);
            offset += 2;
            
            // Bounds (microdegrees)
            view.setInt32(offset, Math.round(sw.lat * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(sw.lng * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(ne.lat * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(ne.lng * 1000000), true);
            offset += 4;
            
            // Feature count
            view.setUint32(offset, trimmedFeatures.length, true);
            offset += 4;
            
            // Name count (new in v2)
            view.setUint16(offset, finalNameList.length, true);
            offset += 2;
            
            // Region name (null-padded to 8 bytes)
            for (let i = 0; i < 8; i++) {
                view.setUint8(offset++, i < regionName.length ? regionName.charCodeAt(i) : 0);
            }
            
            // Padding to reach 40 bytes
            view.setUint16(offset, 0, true);
            offset += 2;
            
            debugLog('BUFFER', 'Header written (40 bytes), offset now:', offset);
            
            // Write name table
            for (const name of finalNameList) {
                view.setUint8(offset++, name.length);
                for (let i = 0; i < name.length; i++) {
                    view.setUint8(offset++, name.charCodeAt(i) & 0xFF);
                }
            }
            debugLog('BUFFER', 'Name table written, offset now:', offset);
            
            // Write features (v2 format: type + nameIndex + pointCount + points)
            let featureIdx = 0;
            for (const feature of trimmedFeatures) {
                const featureStartOffset = offset;
                const expectedSize = 4 + 8 + (feature.points.length - 1) * 4;
                
                // Type (1 byte)
                view.setUint8(offset++, feature.type);
                
                // Name index (2 bytes, 0xFFFF = unnamed)
                view.setUint16(offset, feature.nameIndex, true);
                offset += 2;
                
                // Point count (1 byte)
                view.setUint8(offset++, feature.points.length);
                
                // First point (absolute, microdegrees)
                const firstLat = Math.round(feature.points[0].lat * 1000000);
                const firstLon = Math.round(feature.points[0].lon * 1000000);
                view.setInt32(offset, firstLat, true);
                offset += 4;
                view.setInt32(offset, firstLon, true);
                offset += 4;
                
                // Remaining points (delta encoded)
                let prevLat = firstLat;
                let prevLon = firstLon;
                
                for (let i = 1; i < feature.points.length; i++) {
                    // Check buffer bounds before writing
                    if (offset + 4 > bufferSize) {
                        debugLog('ERROR', 'Buffer overflow!', {
                            featureIdx,
                            pointIdx: i,
                            offset,
                            bufferSize,
                            featurePoints: feature.points.length,
                            expectedSize,
                            featureStartOffset
                        });
                        throw new Error(`Buffer overflow at feature ${featureIdx}, point ${i}`);
                    }
                    
                    const lat = Math.round(feature.points[i].lat * 1000000);
                    const lon = Math.round(feature.points[i].lon * 1000000);
                    
                    // Clamp deltas to int16 range
                    const deltaLat = Math.max(-32768, Math.min(32767, lat - prevLat));
                    const deltaLon = Math.max(-32768, Math.min(32767, lon - prevLon));
                    
                    view.setInt16(offset, deltaLat, true);
                    offset += 2;
                    view.setInt16(offset, deltaLon, true);
                    offset += 2;
                    
                    prevLat = lat;
                    prevLon = lon;
                }
                
                featureIdx++;
            }
            
            debugLog('BUFFER', 'All features written, final offset:', offset, 'buffer size:', bufferSize);
            debugLog('CONVERT', '=== HWMAP v2 generation complete ===');
            debugLog('CONVERT', 'Final file size:', bufferSize, 'bytes');
            debugLog('CONVERT', 'Named features:', namedCount, '/', trimmedFeatures.length);
            debugLog('CONVERT', 'Unique names:', finalNameList.length);
            
            return {
                blob: new Blob([buffer], { type: 'application/octet-stream' }),
                stats: {
                    fileSize: bufferSize,
                    featureCount: trimmedFeatures.length,
                    namedCount: namedCount,
                    nameCount: finalNameList.length,
                    totalPoints: totalPoints,
                    maxPoints: maxPts,
                    typeBreakdown: typeBreakdown,
                    nameTableSize: finalNameTableSize
                }
            };
        }
        
        function classifyFeature(tags) {
            if (!tags) return null;
            
            // Roads - check highway tag
            if (tags.highway) {
                // Highways (motorways, trunk roads)
                if (['motorway', 'motorway_link', 'trunk', 'trunk_link'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_HIGHWAY;
                }
                // Major roads (primary, secondary)
                if (['primary', 'secondary', 'primary_link', 'secondary_link'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_MAJOR;
                }
                // Minor roads (tertiary, residential, service, unclassified)
                if (['tertiary', 'tertiary_link', 'residential', 'unclassified', 'service', 'living_street'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_MINOR;
                }
                // Paths (footways, cycleways, tracks, etc.)
                if (['footway', 'path', 'cycleway', 'track', 'pedestrian', 'steps', 'bridleway'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_PATH;
                }
            }
            
            // Railways
            if (tags.railway) {
                if (['rail', 'light_rail', 'subway', 'tram', 'narrow_gauge'].includes(tags.railway)) {
                    return FEATURE_TYPES.RAILWAY;
                }
            }
            
            // Water
            if (tags.natural === 'water' || tags.waterway) {
                return FEATURE_TYPES.WATER;
            }
            
            // Parks and green areas
            if (tags.leisure === 'park' || ['grass', 'forest', 'meadow', 'wood'].includes(tags.landuse) || tags.natural === 'wood') {
                return FEATURE_TYPES.PARK;
            }
            
            // Buildings
            if (tags.building) {
                return FEATURE_TYPES.BUILDING;
            }
            
            return null;
        }
        
        function simplifyPoints(geometry, tolerance) {
            // Douglas-Peucker simplification
            if (geometry.length <= 2) return geometry;
            
            const points = geometry.map(p => ({ lat: p.lat, lon: p.lon }));
            return douglasPeucker(points, tolerance);
        }
        
        // Resample points to a maximum count while preserving start/end
        function resamplePoints(points, maxCount) {
            if (points.length <= maxCount) return points;
            
            // Always keep first and last point
            const result = [points[0]];
            const step = (points.length - 1) / (maxCount - 1);
            
            for (let i = 1; i < maxCount - 1; i++) {
                const idx = Math.round(i * step);
                result.push(points[idx]);
            }
            
            result.push(points[points.length - 1]);
            return result;
        }
        
        function douglasPeucker(points, tolerance) {
            if (points.length <= 2) return points;
            
            let maxDist = 0;
            let maxIndex = 0;
            
            const start = points[0];
            const end = points[points.length - 1];
            
            for (let i = 1; i < points.length - 1; i++) {
                const dist = perpendicularDistance(points[i], start, end);
                if (dist > maxDist) {
                    maxDist = dist;
                    maxIndex = i;
                }
            }
            
            if (maxDist > tolerance) {
                const left = douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
                const right = douglasPeucker(points.slice(maxIndex), tolerance);
                return left.slice(0, -1).concat(right);
            }
            
            return [start, end];
        }
        
        function perpendicularDistance(point, lineStart, lineEnd) {
            const dx = lineEnd.lon - lineStart.lon;
            const dy = lineEnd.lat - lineStart.lat;
            
            const norm = Math.sqrt(dx * dx + dy * dy);
            if (norm === 0) return Math.sqrt(
                Math.pow(point.lon - lineStart.lon, 2) + 
                Math.pow(point.lat - lineStart.lat, 2)
            );
            
            return Math.abs(dy * point.lon - dx * point.lat + 
                          lineEnd.lon * lineStart.lat - lineEnd.lat * lineStart.lon) / norm;
        }
        
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Update stats when checkboxes change
        document.querySelectorAll('.checkbox-group input').forEach(cb => {
            cb.addEventListener('change', updateStats);
        });
        
        // Slider event listeners
        document.getElementById('detailLevel').addEventListener('input', () => {
            updateDetailLabel();
            updateStats();
        });
        
        document.getElementById('sizeBudget').addEventListener('input', () => {
            updateBudgetLabel();
            updateStats();
        });
        
        document.getElementById('maxPoints').addEventListener('input', () => {
            document.getElementById('maxPointsValue').textContent = document.getElementById('maxPoints').value + ' pts';
            updateStats();
        });
        
        document.getElementById('maxFeatures').addEventListener('input', () => {
            document.getElementById('maxFeaturesValue').textContent = document.getElementById('maxFeatures').value;
            updateStats();
        });
        
        // Name detail slider
        document.getElementById('nameDetail').addEventListener('input', () => {
            updateNameDetailLabel();
            updateStats();
        });
        
        // Building names checkbox
        document.getElementById('buildingNames')?.addEventListener('change', () => {
            const level = parseInt(document.getElementById('nameDetail').value);
            updateNameDetailLabel();
            updateFilteredFeatureList(level);
            updateStats();
        });
        
        function updateNameDetailLabel() {
            const level = parseInt(document.getElementById('nameDetail').value);
            const labels = ['None', 'Highways Only', 'Major Roads', 'All Roads', 'Everything'];
            const descs = [
                'No names included - smallest file size',
                'Only highway/motorway names for basic context',
                'Highways + major roads get names for "where am I" context',
                'All road types get names for detailed context',
                'All features including parks, water, railways get names'
            ];
            document.getElementById('nameDetailValue').textContent = labels[level];
            document.getElementById('nameDetailDesc').textContent = descs[level];
            
            // Hide/show Map Features panel based on name detail level OR building names checkbox
            const featuresPanel = document.getElementById('mapFeaturesPanel');
            const buildingNamesChecked = document.getElementById('buildingNames')?.checked || false;
            if (featuresPanel) {
                featuresPanel.style.display = (level === 0 && !buildingNamesChecked) ? 'none' : 'block';
            }
            
            // Update the feature list to show only what will be included
            updateFilteredFeatureList(level);
        }
        
        function updateFilteredFeatureList(level) {
            const buildingNamesChecked = document.getElementById('buildingNames')?.checked || false;
            if (!window.extractedMetadata) return;
            // Allow showing list if building names checked even when level is 0
            if (level === 0 && !buildingNamesChecked) return;
            
            const featuresList = document.getElementById('mapFeaturesList');
            const metadataSizeEl = document.getElementById('metadataSizeEst');
            if (!featuresList) return;
            
            const { namedFeatures } = window.extractedMetadata;
            let html = '';
            let totalBytes = 0;
            let totalCount = 0;
            
            // Track unique names to avoid counting duplicates
            const uniqueNames = new Set();
            
            const addSection = (title, items, color) => {
                if (items.length === 0) return;
                totalCount += items.length;
                // Only count bytes for unique names (deduplication)
                for (const f of items) {
                    if (!uniqueNames.has(f.label)) {
                        uniqueNames.add(f.label);
                        totalBytes += (f.bytes || 20);
                    }
                }
                
                html += `<div style="margin-bottom:8px;">`;
                html += `<div style="color:${color};font-weight:bold;margin-bottom:4px;">${title} (${items.length})</div>`;
                html += `<div style="color:#aaa;padding-left:8px;">`;
                const shown = items.slice(0, 10);
                html += shown.map(f => `<div style="margin:1px 0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${f.label}">${f.label}</div>`).join('');
                if (items.length > 10) {
                    html += `<div style="color:#666;font-style:italic;">...and ${items.length - 10} more</div>`;
                }
                html += `</div></div>`;
            };
            
            // Level 1: Highways only
            // Level 2: Highways + major roads  
            // Level 3: All roads
            // Level 4: Everything
            // Building names: separate checkbox
            
            if (level >= 1) addSection('Highways', namedFeatures.highways || [], '#ff6b6b');
            if (level >= 2) addSection('Roads', namedFeatures.roads || [], '#ffd93d');
            if (level >= 4) {
                addSection('Water', namedFeatures.water || [], '#4dabf7');
                addSection('Parks', namedFeatures.parks || [], '#69db7c');
                addSection('Railways', namedFeatures.railways || [], '#da77f2');
            }
            
            // Building names shown if checkbox is checked (use variable from top of function)
            if (buildingNamesChecked && namedFeatures.buildings) {
                addSection('Buildings', namedFeatures.buildings, '#b197fc');
            }
            
            featuresList.innerHTML = html || '<div style="color:#666;font-style:italic;">No names match current settings</div>';
            
            // Calculate building names separately
            let buildingCount = 0;
            let buildingBytes = 0;
            if (buildingNamesChecked && namedFeatures.buildings) {
                buildingCount = namedFeatures.buildings.length;
                for (const f of namedFeatures.buildings) buildingBytes += (f.bytes || 20);
            }
            
            // Non-building totals
            const otherCount = totalCount - buildingCount;
            const otherBytes = totalBytes - buildingBytes;
            
            // Update summary with actual counts - split buildings from others
            const nameSummary = document.getElementById('nameSummary');
            const buildingNameSummary = document.getElementById('buildingNameSummary');
            
            if (otherCount > 0) {
                const otherKB = (otherBytes / 1024).toFixed(1);
                if (metadataSizeEl) metadataSizeEl.textContent = `+${otherKB} KB if included`;
                if (nameSummary) nameSummary.textContent = `Roads/Terrain: ${otherCount} names (~${otherKB} KB)`;
            } else {
                if (metadataSizeEl) metadataSizeEl.textContent = '';
                if (nameSummary) nameSummary.textContent = '';
            }
            
            if (buildingCount > 0) {
                const buildingKB = (buildingBytes / 1024).toFixed(1);
                if (buildingNameSummary) buildingNameSummary.textContent = `Buildings: ${buildingCount} names (+${buildingKB} KB if included)`;
            } else {
                if (buildingNameSummary) buildingNameSummary.textContent = '';
            }
        }
        
        // Initialize label and simplification states
        updateNameDetailLabel();
        updateSimplificationStates();
    </script>
</body>
</html>
