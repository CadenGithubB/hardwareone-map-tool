<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HardwareOne Map Converter</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        
        .container {
            max-width: 90%;
            width: 90%;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 20px;
        }
        
        header h1 {
            font-size: 1.8em;
            color: #4cc9f0;
            margin-bottom: 5px;
        }
        
        header p {
            color: #888;
            font-size: 0.9em;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        .map-row {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }
        
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        #map {
            height: 650px;
            border-radius: 8px;
            border: 2px solid #333;
        }
        
        .sidebar {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
        }
        
        .sidebar h2 {
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #4cc9f0;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }
        
        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #1a1a2e;
            color: #eee;
            font-size: 0.95em;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #4cc9f0;
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85em;
        }
        
        .checkbox-item input {
            width: 16px;
            height: 16px;
        }
        
        .section-title {
            font-size: 0.8em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 8px;
            margin-bottom: 4px;
            padding: 6px 8px;
            background: #1a1a2e;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        
        .section-title:hover {
            background: #222;
        }
        
        .section-count {
            color: #4cc9f0;
            font-size: 0.9em;
            margin-left: auto;
            margin-right: 8px;
        }
        
        .section-title::after {
            content: '‚ñº';
            font-size: 0.7em;
            transition: transform 0.2s;
            flex-shrink: 0;
        }
        
        .section-title.collapsed::after {
            transform: rotate(-90deg);
        }
        
        .section-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            padding: 6px 0;
            overflow: hidden;
            transition: max-height 0.2s, opacity 0.2s;
        }
        
        .section-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding: 0;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }
        
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-row input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        
        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4cc9f0;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider-value {
            min-width: 60px;
            text-align: right;
            font-size: 0.85em;
            color: #4cc9f0;
        }
        
        .size-warning {
            background: #3a2a1a;
            border: 1px solid #ff9800;
            color: #ff9800;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-bottom: 10px;
            display: none;
        }
        
        .size-warning.active {
            display: block;
        }
        
        .size-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .size-bar-fill {
            height: 100%;
            background: #4caf50;
            transition: width 0.3s, background 0.3s;
        }
        
        .size-bar-fill.warning {
            background: #ff9800;
        }
        
        .size-bar-fill.danger {
            background: #f44336;
        }
        
        .stats {
            background: #1a1a2e;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 0.85em;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .stats-row:last-child {
            margin-bottom: 0;
        }
        
        .stats-value {
            color: #4cc9f0;
            font-weight: bold;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #4cc9f0;
            color: #1a1a2e;
            font-weight: bold;
        }
        
        .btn-primary:hover {
            background: #7dd8f5;
        }
        
        .btn-primary:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #333;
            color: #eee;
            margin-bottom: 10px;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #444;
        }
        
        .btn-secondary:disabled {
            background: #222;
            color: #555;
            cursor: not-allowed;
        }
        
        .btn-clear {
            background: #3a2020;
            color: #f44336;
            border: 1px solid #f44336;
            margin-top: 10px;
        }
        
        .btn-clear:hover {
            background: #4a2a2a;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.85em;
            text-align: center;
        }
        
        .status.ready {
            background: #1a3a1a;
            color: #4caf50;
        }
        
        .status.working {
            background: #3a3a1a;
            color: #ff9800;
        }
        
        .status.error {
            background: #3a1a1a;
            color: #f44336;
        }
        
        .status.success {
            background: #1a3a1a;
            color: #4caf50;
        }
        
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background: #16213e;
            border-radius: 8px;
        }
        
        .instructions h3 {
            font-size: 1em;
            margin-bottom: 10px;
            color: #4cc9f0;
        }
        
        .instructions ol {
            padding-left: 20px;
            font-size: 0.85em;
            line-height: 1.6;
            color: #aaa;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar.active {
            display: block;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: #4cc9f0;
            width: 0%;
            transition: width 0.3s;
        }
        
        .preview-panel {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
            display: none;
            margin-top: 15px;
        }
        
        .preview-panel.active {
            display: block;
        }
        
        .instructions-banner {
            background: #16213e;
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 20px;
            display: flex;
            align-items: flex-start;
            gap: 15px;
        }
        
        .instructions-banner.hidden {
            display: none;
        }
        
        .instructions-banner h3 {
            color: #4cc9f0;
            font-size: 0.9em;
            margin: 0 0 6px 0;
        }
        
        .instructions-banner ol {
            margin: 0;
            padding-left: 18px;
            font-size: 0.8em;
            color: #aaa;
            line-height: 1.5;
        }
        
        .instructions-banner ol li {
            margin-bottom: 2px;
        }
        
        .instructions-content {
            flex: 1;
        }
        
        .instructions-close {
            background: none;
            border: none;
            color: #666;
            font-size: 1.2em;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .instructions-close:hover {
            color: #fff;
        }
        
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .preview-header h3 {
            color: #4cc9f0;
            font-size: 1em;
            margin: 0;
        }
        
        .preview-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.2em;
            cursor: pointer;
        }
        
        .preview-close:hover {
            color: #fff;
        }
        
        .map-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
            background: #16213e;
            border-radius: 4px;
            font-size: 0.8em;
            margin-top: 10px;
        }
        
        .preview-canvas-container {
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            cursor: grab;
        }
        
        .preview-canvas-container:active {
            cursor: grabbing;
        }
        
        #previewCanvas {
            display: block;
            width: 100%;
            height: 400px;
        }
        
        .preview-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .preview-control-btn {
            width: 32px;
            height: 32px;
            background: rgba(22, 33, 62, 0.9);
            border: 1px solid #4cc9f0;
            border-radius: 4px;
            color: #4cc9f0;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .preview-control-btn:hover {
            background: #4cc9f0;
            color: #0f1419;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .legend-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üó∫Ô∏è HardwareOne Map Converter</h1>
            <p>Create offline map files for your ESP32 device</p>
        </header>
        
        <div class="instructions-banner" id="instructionsBanner">
            <div class="instructions-content">
                <h3>How to Use</h3>
                <ol>
                    <li>Draw a rectangle on the map to select your area</li>
                    <li>Adjust features and settings in the sidebar</li>
                    <li>Click "Preview" to see what will be included, then "Generate" to download</li>
                </ol>
            </div>
            <button class="instructions-close" onclick="document.getElementById('instructionsBanner').classList.add('hidden')">‚úï</button>
        </div>
        
        <div class="main-content">
            <div class="map-row">
                <div id="map"></div>
                <div class="map-legend">
                    <div class="legend-item"><span class="legend-color" style="background:#ff6b6b"></span> Highways</div>
                    <div class="legend-item"><span class="legend-color" style="background:#ffd93d"></span> Major Roads</div>
                    <div class="legend-item"><span class="legend-color" style="background:#ffffff"></span> Minor Roads</div>
                    <div class="legend-item"><span class="legend-color" style="background:#4dabf7"></span> Water</div>
                    <div class="legend-item"><span class="legend-color" style="background:#69db7c"></span> Parks/Land</div>
                    <div class="legend-item"><span class="legend-color" style="background:#da77f2"></span> Railways</div>
                </div>
                <div class="preview-panel" id="previewPanel">
                    <div class="preview-header">
                        <h3>üì∫ Preview - How it will look on device</h3>
                        <button class="preview-close" onclick="closePreview()">‚úï</button>
                    </div>
                    <div class="preview-canvas-container" id="previewContainer">
                        <canvas id="previewCanvas"></canvas>
                        <div class="preview-controls">
                            <button class="preview-control-btn" onclick="zoomPreview(1.2)" title="Zoom in">+</button>
                            <button class="preview-control-btn" onclick="zoomPreview(0.8)" title="Zoom out">‚àí</button>
                            <button class="preview-control-btn" onclick="resetPreviewZoom()" title="Reset view">‚ü≤</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="sidebar">
                <h2>Map Settings</h2>
                
                <button class="btn btn-secondary" onclick="useMyLocation()">
                    üìç Use My Location
                </button>
                
                <div class="form-group">
                    <label>Region Name</label>
                    <input type="text" id="regionName" value="My Area" maxlength="15">
                </div>
                
                <div class="form-group">
                    <label>Include Features</label>
                    
                    <div class="section-title" onclick="toggleSection(this)" data-section="highways">Highways <span class="section-count" id="countHighways">(2/2)</span></div>
                    <div class="section-content">
                        <label class="checkbox-item">
                            <input type="checkbox" id="motorways" checked onchange="updateSectionCounts()">
                            Motorways
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="trunkRoads" checked onchange="updateSectionCounts()">
                            Trunk/US Routes
                        </label>
                    </div>
                    
                    <div class="section-title" onclick="toggleSection(this)" data-section="roads">Roads <span class="section-count" id="countRoads">(2/5)</span></div>
                    <div class="section-content">
                        <label class="checkbox-item">
                            <input type="checkbox" id="primaryRoads" checked onchange="updateSectionCounts()">
                            Primary
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="secondaryRoads" checked onchange="updateSectionCounts()">
                            Secondary
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="tertiaryRoads" onchange="updateSectionCounts()">
                            Tertiary
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="residentialRoads" onchange="updateSectionCounts()">
                            Residential
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="serviceRoads" onchange="updateSectionCounts()">
                            Service
                        </label>
                    </div>
                    
                    <div class="section-title collapsed" onclick="toggleSection(this)" data-section="paths">Paths <span class="section-count" id="countPaths">(0/3)</span></div>
                    <div class="section-content collapsed">
                        <label class="checkbox-item">
                            <input type="checkbox" id="footways" onchange="updateSectionCounts()">
                            Footways
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="cycleways" onchange="updateSectionCounts()">
                            Bike Paths
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="tracks" onchange="updateSectionCounts()">
                            Trails
                        </label>
                    </div>
                    
                    <div class="section-title" onclick="toggleSection(this)" data-section="water">Water <span class="section-count" id="countWater">(1/3)</span></div>
                    <div class="section-content">
                        <label class="checkbox-item">
                            <input type="checkbox" id="waterBodies" checked onchange="updateSectionCounts()">
                            Lakes/Ponds
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="waterways" onchange="updateSectionCounts()">
                            Rivers
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="coastlines" onchange="updateSectionCounts()">
                            Coastlines
                        </label>
                    </div>
                    
                    <div class="section-title collapsed" onclick="toggleSection(this)" data-section="nature">Nature <span class="section-count" id="countNature">(0/3)</span></div>
                    <div class="section-content collapsed">
                        <label class="checkbox-item">
                            <input type="checkbox" id="parks" onchange="updateSectionCounts()">
                            Parks
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="forests" onchange="updateSectionCounts()">
                            Forests
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="grassland" onchange="updateSectionCounts()">
                            Grassland
                        </label>
                    </div>
                    
                    <div class="section-title collapsed" onclick="toggleSection(this)" data-section="infrastructure">Infrastructure <span class="section-count" id="countInfrastructure">(0/3)</span></div>
                    <div class="section-content collapsed">
                        <label class="checkbox-item">
                            <input type="checkbox" id="railways" onchange="updateSectionCounts()">
                            Railways
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="bridges" onchange="updateSectionCounts()">
                            Bridges
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="powerlines" onchange="updateSectionCounts()">
                            Power Lines
                        </label>
                    </div>
                    
                    <div class="section-title collapsed" onclick="toggleSection(this)" data-section="landuse">Land Use <span class="section-count" id="countLanduse">(0/5)</span></div>
                    <div class="section-content collapsed">
                        <label class="checkbox-item">
                            <input type="checkbox" id="buildings" onchange="updateSectionCounts()">
                            Buildings
                        </label>
                        <label class="checkbox-item" style="grid-column: span 2; font-size: 0.85em; padding-left: 20px;">
                            <input type="checkbox" id="buildingsLargeOnly" onchange="updateSectionCounts()">
                            Large only (3+ floors or 200m¬≤+)
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="industrial" onchange="updateSectionCounts()">
                            Industrial
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="commercial" onchange="updateSectionCounts()">
                            Commercial
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="residential" onchange="updateSectionCounts()">
                            Residential
                        </label>
                    </div>
                </div>
                
                <div class="slider-group">
                    <label>Detail Level (geometry simplification)</label>
                    <div class="slider-row">
                        <input type="range" id="detailLevel" min="1" max="5" value="2">
                        <span class="slider-value" id="detailValue">Low</span>
                    </div>
                </div>
                
                <div class="slider-group">
                    <label>Max Points per Road (more = smoother curves)</label>
                    <div class="slider-row">
                        <input type="range" id="maxPoints" min="5" max="50" step="5" value="15">
                        <span class="slider-value" id="maxPointsValue">15 pts</span>
                    </div>
                </div>
                
                <div class="slider-group">
                    <label>Target Size Budget</label>
                    <div class="slider-row">
                        <input type="range" id="sizeBudget" min="50" max="25000" step="50" value="500">
                        <span class="slider-value" id="budgetValue">500 KB</span>
                    </div>
                    <div class="size-bar">
                        <div class="size-bar-fill" id="sizeBarFill"></div>
                    </div>
                </div>
                
                <label class="checkbox-item" style="margin-bottom:10px;">
                    <input type="checkbox" id="autoFitBudget" checked>
                    <span>Auto-trim to fit budget (drops least important features)</span>
                </label>
                
                <div class="size-warning" id="sizeWarning">
                    ‚ö†Ô∏è Estimated size exceeds budget. Try reducing area or features.
                </div>
                
                <div class="stats">
                    <div class="stats-row">
                        <span>Area Size:</span>
                        <span class="stats-value" id="areaSize">-- √ó -- km</span>
                    </div>
                    <div class="stats-row">
                        <span>Estimated Size:</span>
                        <span class="stats-value" id="estSize">-- KB</span>
                    </div>
                    <div class="stats-row">
                        <span>Features:</span>
                        <span class="stats-value" id="featureCount">--</span>
                    </div>
                </div>
                
                <div id="sizeBreakdown" class="size-breakdown" style="display:none;margin-top:10px;padding:8px;background:#1a1a2e;border-radius:4px;font-size:0.8em;">
                    <div style="color:#888;margin-bottom:4px;">Size breakdown (est.):</div>
                    <div id="breakdownContent"></div>
                </div>
                
                <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;">
                    <button class="btn btn-secondary" id="previewBtn" onclick="previewMap()" disabled style="flex:1;margin-bottom:0;">
                        üëÅÔ∏è Preview
                    </button>
                    <label class="checkbox-item" style="font-size:0.8em;white-space:nowrap;" title="Auto-refresh preview when settings change">
                        <input type="checkbox" id="autoPreview" onchange="handleAutoPreviewToggle()">
                        Auto
                    </label>
                </div>
                
                <button class="btn btn-primary" id="generateBtn" onclick="generateMap()" disabled>
                    üó∫Ô∏è Generate Map File
                </button>
                
                <div class="progress-bar" id="progressBar">
                    <div class="progress-bar-fill" id="progressFill"></div>
                </div>
                
                <div class="status ready" id="status">
                    Draw a rectangle on the map to select area
                </div>
                
                <button class="btn btn-clear" id="clearBtn" onclick="clearSelection()" style="display:none;">
                    üóëÔ∏è Clear Selection
                </button>
            </div>
        </div>
        
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    
    <script>
        // =============================================================================
        // MAP INITIALIZATION
        // =============================================================================
        
        const map = L.map('map').setView([40.7128, -74.0060], 13);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);
        
        // Drawing layer
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
        
        // Draw control - rectangle and polygon (click-to-place vertices)
        const drawControl = new L.Control.Draw({
            draw: {
                rectangle: {
                    shapeOptions: {
                        color: '#4cc9f0',
                        fillOpacity: 0.2
                    }
                },
                polygon: {
                    allowIntersection: false,
                    shapeOptions: {
                        color: '#4cc9f0',
                        fillOpacity: 0.2
                    },
                    showArea: true,
                    metric: true
                },
                circle: false,
                circlemarker: false,
                marker: false,
                polyline: false
            },
            edit: false
        });
        map.addControl(drawControl);
        
        // Current selection - can be bounds (rect) or polygon
        let selectedBounds = null;
        let selectedPolygon = null;
        
        // Preview layer for showing selected features
        let previewLayer = new L.LayerGroup();
        map.addLayer(previewLayer);
        
        // Handle drawing events
        map.on(L.Draw.Event.CREATED, function(e) {
            drawnItems.clearLayers();
            previewLayer.clearLayers();
            drawnItems.addLayer(e.layer);
            selectedBounds = e.layer.getBounds();
            
            // Store polygon coordinates if it's a polygon
            if (e.layerType === 'polygon') {
                selectedPolygon = e.layer.getLatLngs()[0].map(ll => [ll.lat, ll.lng]);
            } else {
                selectedPolygon = null;
            }
            
            updateStats();
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('previewBtn').disabled = false;
            document.getElementById('clearBtn').style.display = 'block';
            setStatus('ready', 'Ready to preview or generate');
        });
        
        map.on(L.Draw.Event.DELETED, function(e) {
            selectedBounds = null;
            selectedPolygon = null;
            previewLayer.clearLayers();
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('previewBtn').disabled = true;
            document.getElementById('clearBtn').style.display = 'none';
            setStatus('ready', 'Draw a shape on the map to select area');
            clearStats();
        });
        
        // =============================================================================
        // UI FUNCTIONS
        // =============================================================================
        
        function toggleSection(titleEl) {
            titleEl.classList.toggle('collapsed');
            const content = titleEl.nextElementSibling;
            if (content && content.classList.contains('section-content')) {
                content.classList.toggle('collapsed');
            }
        }
        
        let autoPreviewTimeout = null;
        let autoPreviewEnabled = false;
        
        function handleAutoPreviewToggle() {
            autoPreviewEnabled = document.getElementById('autoPreview').checked;
            if (autoPreviewEnabled && selectedBounds) {
                triggerAutoPreview();
            }
        }
        
        function triggerAutoPreview() {
            if (!autoPreviewEnabled || !selectedBounds) return;
            
            // Debounce - wait 500ms after last change before refreshing
            if (autoPreviewTimeout) {
                clearTimeout(autoPreviewTimeout);
            }
            autoPreviewTimeout = setTimeout(() => {
                previewMap();
            }, 500);
        }
        
        function updateSectionCounts() {
            const sections = {
                highways: ['motorways', 'trunkRoads'],
                roads: ['primaryRoads', 'secondaryRoads', 'tertiaryRoads', 'residentialRoads', 'serviceRoads'],
                paths: ['footways', 'cycleways', 'tracks'],
                water: ['waterBodies', 'waterways', 'coastlines'],
                nature: ['parks', 'forests', 'grassland'],
                infrastructure: ['railways', 'bridges', 'powerlines'],
                landuse: ['buildings', 'buildingsLargeOnly', 'industrial', 'commercial', 'residential']
            };
            
            for (const [section, ids] of Object.entries(sections)) {
                const checked = ids.filter(id => document.getElementById(id)?.checked).length;
                const total = ids.length;
                const el = document.getElementById('count' + section.charAt(0).toUpperCase() + section.slice(1));
                if (el) {
                    el.textContent = `(${checked}/${total})`;
                }
            }
            
            // Also update stats when checkboxes change
            if (selectedBounds) {
                updateStats();
            }
            
            // Trigger auto-preview if enabled
            triggerAutoPreview();
        }
        
        function clearSelection() {
            drawnItems.clearLayers();
            previewLayer.clearLayers();
            selectedBounds = null;
            selectedPolygon = null;
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('previewBtn').disabled = true;
            document.getElementById('clearBtn').style.display = 'none';
            setStatus('ready', 'Draw a shape on the map to select area');
            clearStats();
        }
        
        function useMyLocation() {
            if (!navigator.geolocation) {
                setStatus('error', 'Geolocation not supported');
                return;
            }
            
            setStatus('working', 'Getting location...');
            
            const options = {
                enableHighAccuracy: false,  // false is faster and works better on desktop
                timeout: 10000,             // 10 second timeout
                maximumAge: 300000          // Accept cached position up to 5 min old
            };
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    map.setView([lat, lon], 14);
                    setStatus('ready', 'Centered on your location');
                },
                (error) => {
                    let msg = 'Could not get location';
                    if (error.code === 1) {
                        msg = 'Location access denied. Check browser settings.';
                    } else if (error.code === 2) {
                        msg = 'Location unavailable. Try again.';
                    } else if (error.code === 3) {
                        msg = 'Location request timed out. Try again.';
                    }
                    setStatus('error', msg);
                },
                options
            );
        }
        
        function setStatus(type, message) {
            const status = document.getElementById('status');
            status.className = 'status ' + type;
            status.textContent = message;
        }
        
        function setProgress(percent) {
            const bar = document.getElementById('progressBar');
            const fill = document.getElementById('progressFill');
            bar.classList.add('active');
            fill.style.width = percent + '%';
        }
        
        function hideProgress() {
            document.getElementById('progressBar').classList.remove('active');
        }
        
        function updateStats() {
            if (!selectedBounds) return;
            
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            
            // Calculate area in km
            const widthKm = haversineDistance(sw.lat, sw.lng, sw.lat, ne.lng);
            const heightKm = haversineDistance(sw.lat, sw.lng, ne.lat, sw.lng);
            
            document.getElementById('areaSize').textContent = 
                widthKm.toFixed(1) + ' √ó ' + heightKm.toFixed(1) + ' km';
            
            // Estimate size
            const areaKm2 = widthKm * heightKm;
            const estKB = estimateSize(areaKm2);
            if (estKB >= 1024) {
                document.getElementById('estSize').textContent = (estKB / 1024).toFixed(2) + ' MB';
            } else {
                document.getElementById('estSize').textContent = estKB + ' KB';
            }
            
            // Update size warning
            updateSizeWarning(estKB);
            
            // Feature count will be updated after fetch
            document.getElementById('featureCount').textContent = '~' + Math.round(areaKm2 * 50);
        }
        
        function clearStats() {
            document.getElementById('areaSize').textContent = '-- √ó -- km';
            document.getElementById('estSize').textContent = '-- KB';
            document.getElementById('featureCount').textContent = '--';
        }
        
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function estimateSize(areaKm2) {
            const detailLevel = parseInt(document.getElementById('detailLevel').value);
            const maxPoints = parseInt(document.getElementById('maxPoints').value);
            const detailMultiplier = [0.4, 0.6, 1.0, 1.5, 2.0][detailLevel - 1];
            
            // Size estimates per km¬≤ for each feature type (base values, avgPoints)
            const estimates = [
                // Highways
                { id: 'motorways', name: 'Motorways', base: 2000, avgPts: 35 },
                { id: 'trunkRoads', name: 'Trunk Roads', base: 3000, avgPts: 30 },
                // Roads
                { id: 'primaryRoads', name: 'Primary Roads', base: 5000, avgPts: 25 },
                { id: 'secondaryRoads', name: 'Secondary Roads', base: 8000, avgPts: 20 },
                { id: 'tertiaryRoads', name: 'Tertiary Roads', base: 12000, avgPts: 15 },
                { id: 'residentialRoads', name: 'Residential', base: 25000, avgPts: 10 },
                { id: 'serviceRoads', name: 'Service Roads', base: 15000, avgPts: 8 },
                // Paths
                { id: 'footways', name: 'Footways', base: 10000, avgPts: 10 },
                { id: 'cycleways', name: 'Cycleways', base: 5000, avgPts: 15 },
                { id: 'tracks', name: 'Tracks', base: 8000, avgPts: 12 },
                // Water
                { id: 'waterBodies', name: 'Lakes/Ponds', base: 5000, avgPts: 25 },
                { id: 'waterways', name: 'Rivers', base: 4000, avgPts: 20 },
                { id: 'coastlines', name: 'Coastlines', base: 6000, avgPts: 30 },
                // Nature
                { id: 'parks', name: 'Parks', base: 3000, avgPts: 20 },
                { id: 'forests', name: 'Forests', base: 4000, avgPts: 25 },
                { id: 'grassland', name: 'Grassland', base: 3500, avgPts: 20 },
                // Infrastructure
                { id: 'railways', name: 'Railways', base: 3000, avgPts: 25 },
                { id: 'bridges', name: 'Bridges', base: 1500, avgPts: 15 },
                { id: 'powerlines', name: 'Power Lines', base: 4000, avgPts: 20 },
                // Land Use
                { id: 'buildings', name: 'Buildings', base: 80000, avgPts: 8 },
                { id: 'buildingsLargeOnly', name: 'Buildings (Large)', base: 8000, avgPts: 12 },
                { id: 'industrial', name: 'Industrial', base: 2000, avgPts: 15 },
                { id: 'commercial', name: 'Commercial', base: 2500, avgPts: 15 },
                { id: 'residential', name: 'Residential Areas', base: 3000, avgPts: 15 }
            ];
            
            let totalBytes = 0;
            let breakdownHtml = '';
            
            for (const est of estimates) {
                const el = document.getElementById(est.id);
                if (el && el.checked) {
                    // Scale by points multiplier - features with more points are affected more
                    const ptsScale = Math.min(1.0, maxPoints / est.avgPts);
                    const bytes = Math.round(areaKm2 * est.base * detailMultiplier * ptsScale);
                    const kb = Math.round(bytes / 1024);
                    totalBytes += bytes;
                    if (kb > 0) {
                        const color = kb > 200 ? '#ff6b6b' : kb > 100 ? '#ffd93d' : '#69db7c';
                        breakdownHtml += '<div style="display:flex;justify-content:space-between;"><span>' + est.name + '</span><span style="color:' + color + '">' + kb + ' KB</span></div>';
                    }
                }
            }
            
            // Show breakdown
            const breakdownDiv = document.getElementById('sizeBreakdown');
            const contentDiv = document.getElementById('breakdownContent');
            if (breakdownHtml && areaKm2 > 0) {
                contentDiv.innerHTML = breakdownHtml;
                breakdownDiv.style.display = 'block';
            } else {
                breakdownDiv.style.display = 'none';
            }
            
            return Math.round(totalBytes / 1024);
        }
        
        function updateSizeWarning(estKB) {
            const budget = parseInt(document.getElementById('sizeBudget').value);
            const warning = document.getElementById('sizeWarning');
            const barFill = document.getElementById('sizeBarFill');
            const percent = Math.min(100, (estKB / budget) * 100);
            
            barFill.style.width = percent + '%';
            barFill.className = 'size-bar-fill';
            
            if (estKB > budget * 1.5) {
                barFill.classList.add('danger');
                warning.classList.add('active');
            } else if (estKB > budget) {
                barFill.classList.add('warning');
                warning.classList.add('active');
            } else {
                warning.classList.remove('active');
            }
        }
        
        function updateDetailLabel() {
            const level = parseInt(document.getElementById('detailLevel').value);
            const labels = ['Minimal', 'Low', 'Medium', 'High', 'Maximum'];
            document.getElementById('detailValue').textContent = labels[level - 1];
        }
        
        function updateBudgetLabel() {
            const budget = parseInt(document.getElementById('sizeBudget').value);
            if (budget >= 1000) {
                document.getElementById('budgetValue').textContent = (budget / 1000).toFixed(1) + ' MB';
            } else {
                document.getElementById('budgetValue').textContent = budget + ' KB';
            }
        }
        
        // =============================================================================
        // API RETRY HELPER
        // =============================================================================
        
        // Multiple Overpass API servers for fallback
        const OVERPASS_SERVERS = [
            'https://overpass-api.de/api/interpreter',
            'https://overpass.kumi.systems/api/interpreter'
  
        ];
        let currentServerIndex = 0;
        
        async function fetchWithRetry(url, options, maxRetries = 2) {
            let lastError;
            
            // Try current server first
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        // 429 = rate limit, 504 = timeout
                        if (response.status === 429 || response.status === 504) {
                            throw new Error('Server overloaded: ' + response.status);
                        }
                        throw new Error('API error: ' + response.status);
                    }
                    return response;
                } catch (error) {
                    lastError = error;
                    console.warn(`Attempt ${attempt}/${maxRetries} on server ${currentServerIndex + 1} failed:`, error.message);
                    if (attempt < maxRetries) {
                        setStatus('working', `Retry ${attempt}/${maxRetries}... Server busy`);
                        await new Promise(r => setTimeout(r, 2000 * attempt)); // Longer backoff
                    }
                }
            }
            
            // If all retries failed, try next server
            if (currentServerIndex < OVERPASS_SERVERS.length - 1) {
                currentServerIndex++;
                console.warn(`Switching to backup server ${currentServerIndex + 1}/${OVERPASS_SERVERS.length}`);
                setStatus('working', `Trying backup server ${currentServerIndex + 1}...`);
                await new Promise(r => setTimeout(r, 1000)); // Brief pause before switching
                return fetchWithRetry(OVERPASS_SERVERS[currentServerIndex], options, maxRetries);
            }
            
            // All servers failed
            currentServerIndex = 0; // Reset for next time
            throw new Error('All API servers are currently overloaded. Please wait a few minutes and try again.');
        }
        
        // =============================================================================
        // PREVIEW FUNCTION
        // =============================================================================
        
        // Colors for preview matching the device viewer
        const PREVIEW_COLORS = {
            highway: { color: '#ff6b6b', weight: 4 },      // Motorways, trunk
            major: { color: '#ffd93d', weight: 3 },        // Primary, secondary
            minor: { color: '#ffffff', weight: 2 },        // Tertiary, residential
            path: { color: '#aaaaaa', weight: 1, dashArray: '4,4' },  // Footways, etc.
            water: { color: '#4dabf7', weight: 2 },
            park: { color: '#69db7c', weight: 2 },
            railway: { color: '#da77f2', weight: 2, dashArray: '8,4' },
            building: { color: '#868e96', weight: 1, fillColor: '#495057', fillOpacity: 0.5 }
        };
        
        function closePreview() {
            document.getElementById('previewPanel').classList.remove('active');
        }
        
        function renderPreview() {
            if (!window.previewData || !selectedBounds) return;
            
            const canvas = document.getElementById('previewCanvas');
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');
            
            // Black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate bounds for coordinate transformation
            const bounds = selectedBounds;
            const minLat = bounds.getSouth();
            const maxLat = bounds.getNorth();
            const minLon = bounds.getWest();
            const maxLon = bounds.getEast();
            
            // Padding
            const padding = 20;
            const drawWidth = canvas.width - padding * 2;
            const drawHeight = canvas.height - padding * 2;
            
            // Scale to fit while maintaining aspect ratio
            const latRange = maxLat - minLat;
            const lonRange = maxLon - minLon;
            const latScale = drawHeight / latRange;
            const lonScale = drawWidth / lonRange;
            const baseScale = Math.min(latScale, lonScale);
            const scale = baseScale * window.previewZoom;
            
            // Center offset with pan
            const offsetX = padding + (drawWidth - lonRange * scale) / 2 + window.previewPanX;
            const offsetY = padding + (drawHeight - latRange * scale) / 2 + window.previewPanY;
            
            function toCanvasX(lon) {
                return offsetX + (lon - minLon) * scale;
            }
            function toCanvasY(lat) {
                return canvas.height - (offsetY + (lat - minLat) * scale);
            }
            
            // Draw features
            let featureCount = 0;
            for (const element of window.previewData.elements) {
                if (element.type !== 'way' || !element.geometry) continue;
                
                const coords = element.geometry;
                if (coords.length < 2) continue;
                
                const style = getPreviewStyle(element.tags);
                if (!style) continue;
                
                ctx.beginPath();
                ctx.moveTo(toCanvasX(coords[0].lon), toCanvasY(coords[0].lat));
                for (let i = 1; i < coords.length; i++) {
                    ctx.lineTo(toCanvasX(coords[i].lon), toCanvasY(coords[i].lat));
                }
                ctx.strokeStyle = style.color;
                ctx.lineWidth = (style.weight || 1) * window.previewZoom;
                if (style.dashArray) {
                    ctx.setLineDash(style.dashArray.split(',').map(n => Number(n) * window.previewZoom));
                } else {
                    ctx.setLineDash([]);
                }
                ctx.stroke();
                featureCount++;
            }
            
            // Draw border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            ctx.strokeRect(padding, padding, drawWidth, drawHeight);
            
            window.previewFeatureCount = featureCount;
        }
        
        function zoomPreview(factor) {
            if (!window.previewData) return;
            window.previewZoom *= factor;
            window.previewZoom = Math.max(0.5, Math.min(5.0, window.previewZoom)); // Limit 0.5x to 5x
            renderPreview();
        }
        
        function resetPreviewZoom() {
            if (!window.previewData) return;
            window.previewZoom = 1.0;
            window.previewPanX = 0;
            window.previewPanY = 0;
            renderPreview();
        }
        
        // Pan support with mouse drag
        (function setupPreviewPan() {
            let isDragging = false;
            let lastX, lastY;
            
            const container = document.getElementById('previewContainer');
            if (!container) return;
            
            container.addEventListener('mousedown', (e) => {
                if (!window.previewData) return;
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!isDragging || !window.previewData) return;
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                window.previewPanX += dx;
                window.previewPanY += dy;
                lastX = e.clientX;
                lastY = e.clientY;
                renderPreview();
            });
            
            container.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            container.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // Mouse wheel zoom
            container.addEventListener('wheel', (e) => {
                if (!window.previewData) return;
                e.preventDefault();
                const factor = e.deltaY < 0 ? 1.1 : 0.9;
                zoomPreview(factor);
            });
        })();
        
        async function previewMap() {
            if (!selectedBounds) {
                setStatus('error', 'Please select an area first');
                return;
            }
            
            const btn = document.getElementById('previewBtn');
            btn.disabled = true;
            btn.textContent = '‚è≥ Loading...';
            setStatus('working', 'Fetching preview from OpenStreetMap...');
            
            try {
                const query = buildOverpassQuery();
                const response = await fetchWithRetry(OVERPASS_SERVERS[currentServerIndex], {
                    method: 'POST',
                    body: query
                });
                
                const data = await response.json();
                
                // Store data for zoom/pan
                window.previewData = data;
                window.previewZoom = 1.0;
                window.previewPanX = 0;
                window.previewPanY = 0;
                
                // Render preview
                renderPreview();
                
                // Show preview panel
                document.getElementById('previewPanel').classList.add('active');
                
                document.getElementById('featureCount').textContent = window.previewFeatureCount || 0;
                setStatus('ready', 'Preview: ' + (window.previewFeatureCount || 0) + ' features. Adjust settings and regenerate, or generate file.');
                
            } catch (error) {
                setStatus('error', 'Preview error: ' + error.message);
                console.error(error);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üëÅÔ∏è Preview Selection';
            }
        }
        
        function getPreviewStyle(tags) {
            if (!tags) return null;
            
            if (tags.highway) {
                if (['motorway', 'motorway_link', 'trunk', 'trunk_link'].includes(tags.highway)) {
                    return PREVIEW_COLORS.highway;
                }
                if (['primary', 'secondary', 'primary_link', 'secondary_link'].includes(tags.highway)) {
                    return PREVIEW_COLORS.major;
                }
                if (['tertiary', 'tertiary_link', 'residential', 'unclassified', 'service', 'living_street'].includes(tags.highway)) {
                    return PREVIEW_COLORS.minor;
                }
                if (['footway', 'path', 'cycleway', 'track', 'pedestrian', 'steps', 'bridleway'].includes(tags.highway)) {
                    return PREVIEW_COLORS.path;
                }
            }
            if (tags.railway) return PREVIEW_COLORS.railway;
            if (tags.natural === 'water' || tags.waterway) return PREVIEW_COLORS.water;
            if (tags.leisure === 'park' || tags.landuse) return PREVIEW_COLORS.park;
            if (tags.building) return PREVIEW_COLORS.building;
            
            return null;
        }
        
        // =============================================================================
        // MAP GENERATION
        // =============================================================================
        
        // Debug mode - set to true to enable verbose logging
        const DEBUG = true;
        
        function debugLog(category, message, data = null) {
            if (!DEBUG) return;
            const timestamp = new Date().toISOString().substr(11, 12);
            const prefix = `[${timestamp}] [${category}]`;
            if (data !== null) {
                console.log(prefix, message, data);
            } else {
                console.log(prefix, message);
            }
        }
        
        async function generateMap() {
            if (!selectedBounds) {
                setStatus('error', 'Please select an area first');
                return;
            }
            
            const btn = document.getElementById('generateBtn');
            btn.disabled = true;
            setStatus('working', 'Fetching map data from OpenStreetMap...');
            setProgress(10);
            
            debugLog('INIT', '=== Starting map generation ===');
            debugLog('BOUNDS', 'Selected bounds:', {
                sw: selectedBounds.getSouthWest(),
                ne: selectedBounds.getNorthEast()
            });
            
            try {
                // Build Overpass query
                const query = buildOverpassQuery();
                debugLog('QUERY', 'Overpass query:', query);
                setProgress(20);
                
                // Fetch data with retry
                debugLog('FETCH', 'Fetching from Overpass API...');
                const response = await fetchWithRetry(OVERPASS_SERVERS[currentServerIndex], {
                    method: 'POST',
                    body: query
                });
                
                setStatus('working', 'Parsing response...');
                setProgress(50);
                
                const data = await response.json();
                debugLog('FETCH', 'Received elements:', data.elements?.length || 0);
                
                setStatus('working', 'Converting to binary format...');
                setProgress(70);
                
                // Convert to binary
                const hwmapBlob = convertToHWMap(data);
                debugLog('OUTPUT', 'Generated blob size:', hwmapBlob.size + ' bytes');
                
                setProgress(90);
                
                // Download file
                const regionName = document.getElementById('regionName').value || 'map';
                const filename = regionName.toLowerCase().replace(/[^a-z0-9]/g, '_') + '.hwmap';
                
                downloadBlob(hwmapBlob, filename);
                
                setProgress(100);
                setStatus('success', 'Download started! Upload to device at /maps/');
                debugLog('DONE', '=== Map generation complete ===');
                
            } catch (error) {
                debugLog('ERROR', 'Generation failed:', {
                    message: error.message,
                    stack: error.stack
                });
                setStatus('error', 'Error: ' + error.message);
                console.error(error);
            } finally {
                btn.disabled = false;
                setTimeout(hideProgress, 1000);
            }
        }
        
        function buildOverpassQuery() {
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            const bbox = `${sw.lat},${sw.lng},${ne.lat},${ne.lng}`;
            
            let query = `[out:json][bbox:${bbox}];(\n`;
            
            // Highways
            if (document.getElementById('motorways').checked) {
                query += `way["highway"~"motorway|motorway_link"];\n`;
            }
            if (document.getElementById('trunkRoads').checked) {
                query += `way["highway"~"trunk|trunk_link"];\n`;
            }
            
            // Roads
            if (document.getElementById('primaryRoads').checked) {
                query += `way["highway"~"primary|primary_link"];\n`;
            }
            if (document.getElementById('secondaryRoads').checked) {
                query += `way["highway"~"secondary|secondary_link"];\n`;
            }
            if (document.getElementById('tertiaryRoads').checked) {
                query += `way["highway"~"tertiary|tertiary_link"];\n`;
            }
            if (document.getElementById('residentialRoads').checked) {
                query += `way["highway"~"residential|unclassified"];\n`;
            }
            if (document.getElementById('serviceRoads').checked) {
                query += `way["highway"="service"];\n`;
            }
            
            // Paths
            if (document.getElementById('footways').checked) {
                query += `way["highway"~"footway|pedestrian|steps"];\n`;
            }
            if (document.getElementById('cycleways').checked) {
                query += `way["highway"="cycleway"];\n`;
            }
            if (document.getElementById('tracks').checked) {
                query += `way["highway"~"track|path"];\n`;
            }
            
            // Water
            if (document.getElementById('waterBodies').checked) {
                query += `way["natural"="water"];\n`;
            }
            if (document.getElementById('waterways').checked) {
                query += `way["waterway"~"river|stream|canal"];\n`;
            }
            if (document.getElementById('coastlines').checked) {
                query += `way["natural"="coastline"];\n`;
            }
            
            // Nature
            if (document.getElementById('parks').checked) {
                query += `way["leisure"="park"];\nway["landuse"="grass"];\n`;
            }
            if (document.getElementById('forests').checked) {
                query += `way["landuse"~"forest|wood"];\nway["natural"="wood"];\n`;
            }
            if (document.getElementById('grassland').checked) {
                query += `way["landuse"~"meadow|grassland"];\nway["natural"~"grassland|heath"];\n`;
            }
            
            // Infrastructure
            if (document.getElementById('railways').checked) {
                query += `way["railway"~"rail|light_rail|subway|tram"];\n`;
            }
            if (document.getElementById('bridges').checked) {
                query += `way["bridge"="yes"];\n`;
            }
            if (document.getElementById('powerlines').checked) {
                query += `way["power"~"line|minor_line"];\n`;
            }
            
            // Land Use
            if (document.getElementById('buildings').checked) {
                query += `way["building"];\n`;
            }
            if (document.getElementById('buildingsLargeOnly').checked) {
                // Filter for large buildings: 3+ floors OR 200m¬≤+ area
                query += `way["building"]["building:levels"~"^[3-9]$|^[1-9][0-9]+$"];\n`;
                query += `way["building"](if:number(t["building:levels"])>=3);\n`;
                query += `way["building"](if:area()>=200);\n`;
            }
            if (document.getElementById('industrial').checked) {
                query += `way["landuse"="industrial"];\n`;
            }
            if (document.getElementById('commercial').checked) {
                query += `way["landuse"~"commercial|retail"];\n`;
            }
            if (document.getElementById('residential').checked) {
                query += `way["landuse"="residential"];\n`;
            }
            
            query += `);out geom;`;
            return query;
        }
        
        // =============================================================================
        // BINARY CONVERSION
        // =============================================================================
        
        // Feature types matching device-side enum
        const FEATURE_TYPES = {
            ROAD_HIGHWAY: 0x00,
            ROAD_MAJOR: 0x01,
            ROAD_MINOR: 0x02,
            ROAD_PATH: 0x03,
            WATER: 0x10,
            PARK: 0x11,
            RAILWAY: 0x20,
            BUILDING: 0x30
        };
        
        function convertToHWMap(osmData) {
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            const regionName = document.getElementById('regionName').value.substring(0, 15);
            
            debugLog('CONVERT', 'Starting conversion...');
            debugLog('CONVERT', 'Input elements:', osmData.elements?.length || 0);
            
            // Process features
            const features = [];
            const detailLevel = parseInt(document.getElementById('detailLevel').value);
            const maxPointsPerFeature = parseInt(document.getElementById('maxPoints').value);
            const autoFitBudget = document.getElementById('autoFitBudget').checked;
            const budgetBytes = parseInt(document.getElementById('sizeBudget').value) * 1024;
            
            // More aggressive tolerances for smaller files
            const tolerances = [0.001, 0.0005, 0.0002, 0.0001, 0.00005];
            const tolerance = tolerances[detailLevel - 1];
            
            debugLog('CONVERT', 'Detail level:', detailLevel, 'Tolerance:', tolerance);
            debugLog('CONVERT', 'Max points per feature:', maxPointsPerFeature);
            debugLog('CONVERT', 'Auto-fit budget:', autoFitBudget, 'Budget:', budgetBytes, 'bytes');
            
            let skippedNoGeom = 0;
            let skippedNoType = 0;
            let skippedTooShort = 0;
            
            // Feature priority (lower = more important, keep first)
            const typePriority = {
                0x00: 1,  // Highway - most important
                0x01: 2,  // Major road
                0x10: 3,  // Water (landmarks)
                0x20: 4,  // Railway
                0x02: 5,  // Minor road
                0x11: 6,  // Park
                0x03: 7,  // Path - least important road
                0x30: 8   // Building - least important
            };
            
            for (const element of osmData.elements) {
                if (element.type !== 'way' || !element.geometry) {
                    skippedNoGeom++;
                    continue;
                }
                
                const featureType = classifyFeature(element.tags);
                if (featureType === null) {
                    skippedNoType++;
                    continue;
                }
                
                // Simplify geometry based on detail level
                let points = simplifyPoints(element.geometry, tolerance);
                if (points.length < 2) {
                    skippedTooShort++;
                    continue;
                }
                
                // Limit points per feature
                if (points.length > maxPointsPerFeature) {
                    points = resamplePoints(points, maxPointsPerFeature);
                }
                
                // Calculate feature length for priority sorting
                let length = 0;
                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].lon - points[i-1].lon;
                    const dy = points[i].lat - points[i-1].lat;
                    length += Math.sqrt(dx*dx + dy*dy);
                }
                
                features.push({
                    type: featureType,
                    points: points,
                    priority: typePriority[featureType] || 99,
                    length: length
                });
            }
            
            debugLog('CONVERT', 'Skipped - no geometry:', skippedNoGeom);
            debugLog('CONVERT', 'Skipped - no type match:', skippedNoType);
            debugLog('CONVERT', 'Skipped - too short:', skippedTooShort);
            debugLog('CONVERT', 'Features before trimming:', features.length);
            
            // Sort by priority (important first), then by length (longer = more important)
            features.sort((a, b) => {
                if (a.priority !== b.priority) return a.priority - b.priority;
                return b.length - a.length; // Longer roads first within same priority
            });
            
            // Auto-fit to budget by dropping least important features
            let trimmedFeatures = features;
            if (autoFitBudget) {
                let currentSize = 36; // Header
                trimmedFeatures = [];
                for (const f of features) {
                    const featureSize = 2 + 8 + (f.points.length - 1) * 4;
                    if (currentSize + featureSize <= budgetBytes) {
                        trimmedFeatures.push(f);
                        currentSize += featureSize;
                    }
                }
                debugLog('CONVERT', 'Trimmed to budget:', trimmedFeatures.length, 'features,', currentSize, 'bytes');
            }
            
            debugLog('CONVERT', 'Final feature count:', trimmedFeatures.length);
            
            // Log point distribution
            let totalPoints = 0;
            let maxPts = 0;
            for (const f of trimmedFeatures) {
                totalPoints += f.points.length;
                if (f.points.length > maxPts) maxPts = f.points.length;
            }
            debugLog('CONVERT', 'Total points:', totalPoints, 'Max points per feature:', maxPts);
            
            // Update feature count display
            document.getElementById('featureCount').textContent = trimmedFeatures.length;
            
            // Calculate buffer size
            // Header: 4 (magic) + 2 (version) + 2 (flags) + 16 (bounds) + 4 (count) + 8 (name) = 36
            let bufferSize = 36; // Header
            for (const f of trimmedFeatures) {
                bufferSize += 2 + 8 + (f.points.length - 1) * 4; // type + count + first point + deltas
            }
            
            debugLog('BUFFER', 'Calculated buffer size:', bufferSize + ' bytes');
            
            // Create buffer
            const buffer = new ArrayBuffer(bufferSize);
            const view = new DataView(buffer);
            let offset = 0;
            
            // Write header
            // Magic "HWMP"
            view.setUint8(offset++, 0x48); // H
            view.setUint8(offset++, 0x57); // W
            view.setUint8(offset++, 0x4D); // M
            view.setUint8(offset++, 0x50); // P
            
            // Version
            view.setUint16(offset, 1, true);
            offset += 2;
            
            // Flags (reserved)
            view.setUint16(offset, 0, true);
            offset += 2;
            
            // Bounds (microdegrees)
            view.setInt32(offset, Math.round(sw.lat * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(sw.lng * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(ne.lat * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(ne.lng * 1000000), true);
            offset += 4;
            
            // Feature count
            view.setUint32(offset, trimmedFeatures.length, true);
            offset += 4;
            
            // Region name (null-padded to 8 bytes)
            for (let i = 0; i < 8; i++) {
                view.setUint8(offset++, i < regionName.length ? regionName.charCodeAt(i) : 0);
            }
            
            debugLog('BUFFER', 'Header written, offset now:', offset);
            
            // Write features
            let featureIdx = 0;
            for (const feature of trimmedFeatures) {
                const featureStartOffset = offset;
                const expectedSize = 2 + 8 + (feature.points.length - 1) * 4;
                
                // Type
                view.setUint8(offset++, feature.type);
                
                // Point count
                view.setUint8(offset++, feature.points.length);
                
                // First point (absolute, microdegrees)
                const firstLat = Math.round(feature.points[0].lat * 1000000);
                const firstLon = Math.round(feature.points[0].lon * 1000000);
                view.setInt32(offset, firstLat, true);
                offset += 4;
                view.setInt32(offset, firstLon, true);
                offset += 4;
                
                // Remaining points (delta encoded)
                let prevLat = firstLat;
                let prevLon = firstLon;
                
                for (let i = 1; i < feature.points.length; i++) {
                    // Check buffer bounds before writing
                    if (offset + 4 > bufferSize) {
                        debugLog('ERROR', 'Buffer overflow!', {
                            featureIdx,
                            pointIdx: i,
                            offset,
                            bufferSize,
                            featurePoints: feature.points.length,
                            expectedSize,
                            featureStartOffset
                        });
                        throw new Error(`Buffer overflow at feature ${featureIdx}, point ${i}`);
                    }
                    
                    const lat = Math.round(feature.points[i].lat * 1000000);
                    const lon = Math.round(feature.points[i].lon * 1000000);
                    
                    // Clamp deltas to int16 range
                    const deltaLat = Math.max(-32768, Math.min(32767, lat - prevLat));
                    const deltaLon = Math.max(-32768, Math.min(32767, lon - prevLon));
                    
                    view.setInt16(offset, deltaLat, true);
                    offset += 2;
                    view.setInt16(offset, deltaLon, true);
                    offset += 2;
                    
                    prevLat = lat;
                    prevLon = lon;
                }
                
                featureIdx++;
            }
            
            debugLog('BUFFER', 'All features written, final offset:', offset, 'buffer size:', bufferSize);
            
            return new Blob([buffer], { type: 'application/octet-stream' });
        }
        
        function classifyFeature(tags) {
            if (!tags) return null;
            
            // Roads - check highway tag
            if (tags.highway) {
                // Highways (motorways, trunk roads)
                if (['motorway', 'motorway_link', 'trunk', 'trunk_link'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_HIGHWAY;
                }
                // Major roads (primary, secondary)
                if (['primary', 'secondary', 'primary_link', 'secondary_link'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_MAJOR;
                }
                // Minor roads (tertiary, residential, service, unclassified)
                if (['tertiary', 'tertiary_link', 'residential', 'unclassified', 'service', 'living_street'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_MINOR;
                }
                // Paths (footways, cycleways, tracks, etc.)
                if (['footway', 'path', 'cycleway', 'track', 'pedestrian', 'steps', 'bridleway'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_PATH;
                }
            }
            
            // Railways
            if (tags.railway) {
                if (['rail', 'light_rail', 'subway', 'tram', 'narrow_gauge'].includes(tags.railway)) {
                    return FEATURE_TYPES.RAILWAY;
                }
            }
            
            // Water
            if (tags.natural === 'water' || tags.waterway) {
                return FEATURE_TYPES.WATER;
            }
            
            // Parks and green areas
            if (tags.leisure === 'park' || ['grass', 'forest', 'meadow', 'wood'].includes(tags.landuse) || tags.natural === 'wood') {
                return FEATURE_TYPES.PARK;
            }
            
            // Buildings
            if (tags.building) {
                return FEATURE_TYPES.BUILDING;
            }
            
            return null;
        }
        
        function simplifyPoints(geometry, tolerance) {
            // Douglas-Peucker simplification
            if (geometry.length <= 2) return geometry;
            
            const points = geometry.map(p => ({ lat: p.lat, lon: p.lon }));
            return douglasPeucker(points, tolerance);
        }
        
        // Resample points to a maximum count while preserving start/end
        function resamplePoints(points, maxCount) {
            if (points.length <= maxCount) return points;
            
            // Always keep first and last point
            const result = [points[0]];
            const step = (points.length - 1) / (maxCount - 1);
            
            for (let i = 1; i < maxCount - 1; i++) {
                const idx = Math.round(i * step);
                result.push(points[idx]);
            }
            
            result.push(points[points.length - 1]);
            return result;
        }
        
        function douglasPeucker(points, tolerance) {
            if (points.length <= 2) return points;
            
            let maxDist = 0;
            let maxIndex = 0;
            
            const start = points[0];
            const end = points[points.length - 1];
            
            for (let i = 1; i < points.length - 1; i++) {
                const dist = perpendicularDistance(points[i], start, end);
                if (dist > maxDist) {
                    maxDist = dist;
                    maxIndex = i;
                }
            }
            
            if (maxDist > tolerance) {
                const left = douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
                const right = douglasPeucker(points.slice(maxIndex), tolerance);
                return left.slice(0, -1).concat(right);
            }
            
            return [start, end];
        }
        
        function perpendicularDistance(point, lineStart, lineEnd) {
            const dx = lineEnd.lon - lineStart.lon;
            const dy = lineEnd.lat - lineStart.lat;
            
            const norm = Math.sqrt(dx * dx + dy * dy);
            if (norm === 0) return Math.sqrt(
                Math.pow(point.lon - lineStart.lon, 2) + 
                Math.pow(point.lat - lineStart.lat, 2)
            );
            
            return Math.abs(dy * point.lon - dx * point.lat + 
                          lineEnd.lon * lineStart.lat - lineEnd.lat * lineStart.lon) / norm;
        }
        
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Update stats when checkboxes change
        document.querySelectorAll('.checkbox-group input').forEach(cb => {
            cb.addEventListener('change', updateStats);
        });
        
        // Slider event listeners
        document.getElementById('detailLevel').addEventListener('input', () => {
            updateDetailLabel();
            updateStats();
        });
        
        document.getElementById('sizeBudget').addEventListener('input', () => {
            updateBudgetLabel();
            updateStats();
        });
        
        document.getElementById('maxPoints').addEventListener('input', () => {
            document.getElementById('maxPointsValue').textContent = document.getElementById('maxPoints').value + ' pts';
            updateStats();
        });
    </script>
</body>
</html>
