<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HardwareOne Map Converter</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 20px;
        }
        
        header h1 {
            font-size: 1.8em;
            color: #4cc9f0;
            margin-bottom: 5px;
        }
        
        header p {
            color: #888;
            font-size: 0.9em;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        #map {
            height: 500px;
            border-radius: 8px;
            border: 2px solid #333;
        }
        
        .sidebar {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
        }
        
        .sidebar h2 {
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #4cc9f0;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }
        
        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #1a1a2e;
            color: #eee;
            font-size: 0.95em;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #4cc9f0;
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85em;
        }
        
        .checkbox-item input {
            width: 16px;
            height: 16px;
        }
        
        .stats {
            background: #1a1a2e;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 0.85em;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .stats-row:last-child {
            margin-bottom: 0;
        }
        
        .stats-value {
            color: #4cc9f0;
            font-weight: bold;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #4cc9f0;
            color: #1a1a2e;
            font-weight: bold;
        }
        
        .btn-primary:hover {
            background: #7dd8f5;
        }
        
        .btn-primary:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #333;
            color: #eee;
            margin-bottom: 10px;
        }
        
        .btn-secondary:hover {
            background: #444;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.85em;
            text-align: center;
        }
        
        .status.ready {
            background: #1a3a1a;
            color: #4caf50;
        }
        
        .status.working {
            background: #3a3a1a;
            color: #ff9800;
        }
        
        .status.error {
            background: #3a1a1a;
            color: #f44336;
        }
        
        .status.success {
            background: #1a3a1a;
            color: #4caf50;
        }
        
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background: #16213e;
            border-radius: 8px;
        }
        
        .instructions h3 {
            font-size: 1em;
            margin-bottom: 10px;
            color: #4cc9f0;
        }
        
        .instructions ol {
            padding-left: 20px;
            font-size: 0.85em;
            line-height: 1.6;
            color: #aaa;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar.active {
            display: block;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: #4cc9f0;
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üó∫Ô∏è HardwareOne Map Converter</h1>
            <p>Create offline map files for your ESP32 device</p>
        </header>
        
        <div class="main-content">
            <div class="map-container">
                <div id="map"></div>
            </div>
            
            <div class="sidebar">
                <h2>Map Settings</h2>
                
                <button class="btn btn-secondary" onclick="useMyLocation()">
                    üìç Use My Location
                </button>
                
                <div class="form-group">
                    <label>Region Name</label>
                    <input type="text" id="regionName" value="My Area" maxlength="15">
                </div>
                
                <div class="form-group">
                    <label>Include Features</label>
                    <div class="checkbox-group">
                        <label class="checkbox-item">
                            <input type="checkbox" id="majorRoads" checked>
                            Major Roads
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="minorRoads" checked>
                            Minor Roads
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="water" checked>
                            Water
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="parks" checked>
                            Parks
                        </label>
                    </div>
                </div>
                
                <div class="stats">
                    <div class="stats-row">
                        <span>Area Size:</span>
                        <span class="stats-value" id="areaSize">-- √ó -- km</span>
                    </div>
                    <div class="stats-row">
                        <span>Estimated Size:</span>
                        <span class="stats-value" id="estSize">-- KB</span>
                    </div>
                    <div class="stats-row">
                        <span>Features:</span>
                        <span class="stats-value" id="featureCount">--</span>
                    </div>
                </div>
                
                <button class="btn btn-primary" id="generateBtn" onclick="generateMap()" disabled>
                    üó∫Ô∏è Generate Map File
                </button>
                
                <div class="progress-bar" id="progressBar">
                    <div class="progress-bar-fill" id="progressFill"></div>
                </div>
                
                <div class="status ready" id="status">
                    Draw a rectangle on the map to select area
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h3>How to Use</h3>
            <ol>
                <li>Click the rectangle tool on the map (top-left) and draw your desired area</li>
                <li>Adjust the region name and feature options</li>
                <li>Click "Generate Map File" to create the .hwmap file</li>
                <li>Upload the file to your device via the web file manager at <code>/maps/</code></li>
            </ol>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    
    <script>
        // =============================================================================
        // MAP INITIALIZATION
        // =============================================================================
        
        const map = L.map('map').setView([40.7128, -74.0060], 13);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);
        
        // Drawing layer
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
        
        // Draw control
        const drawControl = new L.Control.Draw({
            draw: {
                rectangle: {
                    shapeOptions: {
                        color: '#4cc9f0',
                        fillOpacity: 0.2
                    }
                },
                polygon: false,
                circle: false,
                circlemarker: false,
                marker: false,
                polyline: false
            },
            edit: {
                featureGroup: drawnItems,
                remove: true
            }
        });
        map.addControl(drawControl);
        
        // Current selection bounds
        let selectedBounds = null;
        
        // Handle drawing events
        map.on(L.Draw.Event.CREATED, function(e) {
            drawnItems.clearLayers();
            drawnItems.addLayer(e.layer);
            selectedBounds = e.layer.getBounds();
            updateStats();
            document.getElementById('generateBtn').disabled = false;
            setStatus('ready', 'Ready to generate map');
        });
        
        map.on(L.Draw.Event.DELETED, function(e) {
            selectedBounds = null;
            document.getElementById('generateBtn').disabled = true;
            setStatus('ready', 'Draw a rectangle on the map to select area');
            clearStats();
        });
        
        // =============================================================================
        // UI FUNCTIONS
        // =============================================================================
        
        function useMyLocation() {
            if (!navigator.geolocation) {
                setStatus('error', 'Geolocation not supported');
                return;
            }
            
            setStatus('working', 'Getting location...');
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    map.setView([lat, lon], 14);
                    setStatus('ready', 'Centered on your location');
                },
                (error) => {
                    setStatus('error', 'Could not get location: ' + error.message);
                }
            );
        }
        
        function setStatus(type, message) {
            const status = document.getElementById('status');
            status.className = 'status ' + type;
            status.textContent = message;
        }
        
        function setProgress(percent) {
            const bar = document.getElementById('progressBar');
            const fill = document.getElementById('progressFill');
            bar.classList.add('active');
            fill.style.width = percent + '%';
        }
        
        function hideProgress() {
            document.getElementById('progressBar').classList.remove('active');
        }
        
        function updateStats() {
            if (!selectedBounds) return;
            
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            
            // Calculate area in km
            const widthKm = haversineDistance(sw.lat, sw.lng, sw.lat, ne.lng);
            const heightKm = haversineDistance(sw.lat, sw.lng, ne.lat, sw.lng);
            
            document.getElementById('areaSize').textContent = 
                widthKm.toFixed(1) + ' √ó ' + heightKm.toFixed(1) + ' km';
            
            // Estimate size
            const areaKm2 = widthKm * heightKm;
            const estKB = estimateSize(areaKm2);
            document.getElementById('estSize').textContent = estKB + ' KB';
            
            // Feature count will be updated after fetch
            document.getElementById('featureCount').textContent = '~' + Math.round(areaKm2 * 50);
        }
        
        function clearStats() {
            document.getElementById('areaSize').textContent = '-- √ó -- km';
            document.getElementById('estSize').textContent = '-- KB';
            document.getElementById('featureCount').textContent = '--';
        }
        
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function estimateSize(areaKm2) {
            let bytesPerKm2 = 0;
            if (document.getElementById('majorRoads').checked) bytesPerKm2 += 15000;
            if (document.getElementById('minorRoads').checked) bytesPerKm2 += 25000;
            if (document.getElementById('water').checked) bytesPerKm2 += 5000;
            if (document.getElementById('parks').checked) bytesPerKm2 += 3000;
            return Math.round(areaKm2 * bytesPerKm2 / 1024);
        }
        
        // =============================================================================
        // MAP GENERATION
        // =============================================================================
        
        async function generateMap() {
            if (!selectedBounds) {
                setStatus('error', 'Please select an area first');
                return;
            }
            
            const btn = document.getElementById('generateBtn');
            btn.disabled = true;
            setStatus('working', 'Fetching map data from OpenStreetMap...');
            setProgress(10);
            
            try {
                // Build Overpass query
                const query = buildOverpassQuery();
                setProgress(20);
                
                // Fetch data
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                
                if (!response.ok) {
                    throw new Error('Overpass API error: ' + response.status);
                }
                
                setStatus('working', 'Parsing response...');
                setProgress(50);
                
                const data = await response.json();
                
                setStatus('working', 'Converting to binary format...');
                setProgress(70);
                
                // Convert to binary
                const hwmapBlob = convertToHWMap(data);
                
                setProgress(90);
                
                // Download file
                const regionName = document.getElementById('regionName').value || 'map';
                const filename = regionName.toLowerCase().replace(/[^a-z0-9]/g, '_') + '.hwmap';
                
                downloadBlob(hwmapBlob, filename);
                
                setProgress(100);
                setStatus('success', 'Download started! Upload to device at /maps/');
                
            } catch (error) {
                setStatus('error', 'Error: ' + error.message);
                console.error(error);
            } finally {
                btn.disabled = false;
                setTimeout(hideProgress, 1000);
            }
        }
        
        function buildOverpassQuery() {
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            const bbox = `${sw.lat},${sw.lng},${ne.lat},${ne.lng}`;
            
            let query = `[out:json][bbox:${bbox}];(\n`;
            
            if (document.getElementById('majorRoads').checked) {
                query += `way["highway"~"motorway|trunk|primary|secondary"];\n`;
            }
            if (document.getElementById('minorRoads').checked) {
                query += `way["highway"~"tertiary|residential|unclassified|service"];\n`;
            }
            if (document.getElementById('water').checked) {
                query += `way["natural"="water"];\nway["waterway"];\n`;
            }
            if (document.getElementById('parks').checked) {
                query += `way["leisure"="park"];\nway["landuse"="grass"];\n`;
            }
            
            query += `);out geom;`;
            return query;
        }
        
        // =============================================================================
        // BINARY CONVERSION
        // =============================================================================
        
        // Feature types matching device-side enum
        const FEATURE_TYPES = {
            ROAD_MAJOR: 0x01,
            ROAD_MINOR: 0x02,
            WATER: 0x10,
            PARK: 0x11
        };
        
        function convertToHWMap(osmData) {
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            const regionName = document.getElementById('regionName').value.substring(0, 15);
            
            // Process features
            const features = [];
            
            for (const element of osmData.elements) {
                if (element.type !== 'way' || !element.geometry) continue;
                
                const featureType = classifyFeature(element.tags);
                if (featureType === null) continue;
                
                // Simplify geometry
                const points = simplifyPoints(element.geometry, 0.0001);
                if (points.length < 2) continue;
                
                features.push({
                    type: featureType,
                    points: points
                });
            }
            
            // Update feature count display
            document.getElementById('featureCount').textContent = features.length;
            
            // Calculate buffer size
            let bufferSize = 32; // Header
            for (const f of features) {
                bufferSize += 2 + 8 + (f.points.length - 1) * 4; // type + count + first point + deltas
            }
            
            // Create buffer
            const buffer = new ArrayBuffer(bufferSize);
            const view = new DataView(buffer);
            let offset = 0;
            
            // Write header
            // Magic "HWMP"
            view.setUint8(offset++, 0x48); // H
            view.setUint8(offset++, 0x57); // W
            view.setUint8(offset++, 0x4D); // M
            view.setUint8(offset++, 0x50); // P
            
            // Version
            view.setUint16(offset, 1, true);
            offset += 2;
            
            // Flags (reserved)
            view.setUint16(offset, 0, true);
            offset += 2;
            
            // Bounds (microdegrees)
            view.setInt32(offset, Math.round(sw.lat * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(sw.lng * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(ne.lat * 1000000), true);
            offset += 4;
            view.setInt32(offset, Math.round(ne.lng * 1000000), true);
            offset += 4;
            
            // Feature count
            view.setUint32(offset, features.length, true);
            offset += 4;
            
            // Region name (null-padded to 8 bytes)
            for (let i = 0; i < 8; i++) {
                view.setUint8(offset++, i < regionName.length ? regionName.charCodeAt(i) : 0);
            }
            
            // Write features
            for (const feature of features) {
                // Type
                view.setUint8(offset++, feature.type);
                
                // Point count
                view.setUint8(offset++, feature.points.length);
                
                // First point (absolute, microdegrees)
                const firstLat = Math.round(feature.points[0].lat * 1000000);
                const firstLon = Math.round(feature.points[0].lon * 1000000);
                view.setInt32(offset, firstLat, true);
                offset += 4;
                view.setInt32(offset, firstLon, true);
                offset += 4;
                
                // Remaining points (delta encoded)
                let prevLat = firstLat;
                let prevLon = firstLon;
                
                for (let i = 1; i < feature.points.length; i++) {
                    const lat = Math.round(feature.points[i].lat * 1000000);
                    const lon = Math.round(feature.points[i].lon * 1000000);
                    
                    // Clamp deltas to int16 range
                    const deltaLat = Math.max(-32768, Math.min(32767, lat - prevLat));
                    const deltaLon = Math.max(-32768, Math.min(32767, lon - prevLon));
                    
                    view.setInt16(offset, deltaLat, true);
                    offset += 2;
                    view.setInt16(offset, deltaLon, true);
                    offset += 2;
                    
                    prevLat = lat;
                    prevLon = lon;
                }
            }
            
            return new Blob([buffer], { type: 'application/octet-stream' });
        }
        
        function classifyFeature(tags) {
            if (!tags) return null;
            
            if (tags.highway) {
                if (['motorway', 'trunk', 'primary', 'secondary'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_MAJOR;
                }
                if (['tertiary', 'residential', 'unclassified', 'service'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_MINOR;
                }
            }
            
            if (tags.natural === 'water' || tags.waterway) {
                return FEATURE_TYPES.WATER;
            }
            
            if (tags.leisure === 'park' || tags.landuse === 'grass') {
                return FEATURE_TYPES.PARK;
            }
            
            return null;
        }
        
        function simplifyPoints(geometry, tolerance) {
            // Douglas-Peucker simplification
            if (geometry.length <= 2) return geometry;
            
            const points = geometry.map(p => ({ lat: p.lat, lon: p.lon }));
            return douglasPeucker(points, tolerance);
        }
        
        function douglasPeucker(points, tolerance) {
            if (points.length <= 2) return points;
            
            let maxDist = 0;
            let maxIndex = 0;
            
            const start = points[0];
            const end = points[points.length - 1];
            
            for (let i = 1; i < points.length - 1; i++) {
                const dist = perpendicularDistance(points[i], start, end);
                if (dist > maxDist) {
                    maxDist = dist;
                    maxIndex = i;
                }
            }
            
            if (maxDist > tolerance) {
                const left = douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
                const right = douglasPeucker(points.slice(maxIndex), tolerance);
                return left.slice(0, -1).concat(right);
            }
            
            return [start, end];
        }
        
        function perpendicularDistance(point, lineStart, lineEnd) {
            const dx = lineEnd.lon - lineStart.lon;
            const dy = lineEnd.lat - lineStart.lat;
            
            const norm = Math.sqrt(dx * dx + dy * dy);
            if (norm === 0) return Math.sqrt(
                Math.pow(point.lon - lineStart.lon, 2) + 
                Math.pow(point.lat - lineStart.lat, 2)
            );
            
            return Math.abs(dy * point.lon - dx * point.lat + 
                          lineEnd.lon * lineStart.lat - lineEnd.lat * lineStart.lon) / norm;
        }
        
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Update stats when checkboxes change
        document.querySelectorAll('.checkbox-group input').forEach(cb => {
            cb.addEventListener('change', updateStats);
        });
    </script>
</body>
</html>
