<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HardwareOne Map Converter</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        
        .container {
            max-width: 90%;
            width: 90%;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 20px;
        }
        
        header h1 {
            font-size: 1.8em;
            color: #4cc9f0;
            margin-bottom: 5px;
        }
        
        header p {
            color: #888;
            font-size: 0.9em;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        .map-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        #map {
            height: 650px;
            border-radius: 8px;
            border: 2px solid #333;
            flex-shrink: 0;
        }
        
        .sidebar {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
        }
        
        .sidebar h2 {
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #4cc9f0;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }
        
        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #1a1a2e;
            color: #eee;
            font-size: 0.95em;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #4cc9f0;
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85em;
        }
        
        .checkbox-item input {
            width: 16px;
            height: 16px;
        }
        
        .section-title {
            font-size: 0.8em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 8px;
            margin-bottom: 4px;
            padding: 6px 8px;
            background: #1a1a2e;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        
        .section-title:hover {
            background: #222;
        }
        
        .section-count {
            color: #4cc9f0;
            font-size: 0.9em;
            margin-left: auto;
            margin-right: 8px;
        }
        
        .feature-size {
            color: #888;
            font-size: 0.8em;
            margin-left: 4px;
        }
        
        .feature-size.large {
            color: #ff6b6b;
        }
        
        .feature-size.medium {
            color: #ffd93d;
        }
        
        .feature-size.small {
            color: #69db7c;
        }
        
        .section-title::after {
            content: '▼';
            font-size: 0.7em;
            transition: transform 0.2s;
            flex-shrink: 0;
        }
        
        .section-title.collapsed::after {
            transform: rotate(-90deg);
        }
        
        .section-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            padding: 6px 0;
            overflow: hidden;
            transition: max-height 0.2s, opacity 0.2s;
        }

        /* Waypoints section override: do NOT use the global 2-column grid */
        #waypointsContent {
            display: block !important;
            grid-template-columns: unset !important;
            gap: 0 !important;
            width: 100%;
        }

        #waypointsToolbar {
            display: flex !important;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        #waypointsToolbar .btn {
            width: auto !important;
            margin-bottom: 0 !important;
        }

        #waypointList {
            width: 100%;
        }
        
        .section-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding: 0;
        }
        
        /* Nested sections container - display as block, not grid */
        #allFeaturesContent {
            display: block;
        }
        
        #allFeaturesContent .section-title {
            margin-top: 4px;
        }
        
        #allFeaturesContent .section-content {
            margin-bottom: 4px;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }
        
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* All range sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #555;
            border-radius: 3px;
            outline: none;
            margin: 8px 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4cc9f0;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -5px;
        }
        
        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: #555;
            border-radius: 3px;
        }
        
        input[type="range"]::-moz-range-track {
            height: 6px;
            background: #555;
            border-radius: 3px;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #4cc9f0;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .slider-row input[type="range"] {
            flex: 1;
        }
        
        .slider-value {
            min-width: 60px;
            text-align: right;
            font-size: 0.85em;
            color: #4cc9f0;
        }
        
        .size-warning {
            background: #3a2a1a;
            border: 1px solid #ff9800;
            color: #ff9800;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-bottom: 10px;
            display: none;
        }
        
        .size-warning.active {
            display: block;
        }
        
        .size-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .size-bar-fill {
            height: 100%;
            background: #4caf50;
            transition: width 0.3s, background 0.3s;
        }
        
        .size-bar-fill.warning {
            background: #ff9800;
        }
        
        .size-bar-fill.danger {
            background: #f44336;
        }
        
        .stats {
            background: #1a1a2e;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 0.85em;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .stats-row:last-child {
            margin-bottom: 0;
        }
        
        .stats-value {
            color: #4cc9f0;
            font-weight: bold;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #4cc9f0;
            color: #1a1a2e;
            font-weight: bold;
        }
        
        .btn-primary:hover {
            background: #7dd8f5;
        }
        
        .btn-primary:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #333;
            color: #eee;
            margin-bottom: 10px;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #444;
        }
        
        .btn-secondary:disabled {
            background: #222;
            color: #555;
            cursor: not-allowed;
        }
        
        .btn-clear {
            background: #3a2020;
            color: #f44336;
            border: 1px solid #f44336;
            margin-top: 10px;
        }
        
        .btn-clear:hover {
            background: #4a2a2a;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.85em;
            text-align: center;
        }
        
        .status.ready {
            background: #1a3a1a;
            color: #4caf50;
        }
        
        .status.working {
            background: #3a3a1a;
            color: #ff9800;
        }
        
        .status.error {
            background: #3a1a1a;
            color: #f44336;
        }
        
        .status.success {
            background: #1a3a1a;
            color: #4caf50;
        }
        
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background: #16213e;
            border-radius: 8px;
        }
        
        .instructions h3 {
            font-size: 1em;
            margin-bottom: 10px;
            color: #4cc9f0;
        }
        
        .instructions ol {
            padding-left: 20px;
            font-size: 0.85em;
            line-height: 1.6;
            color: #aaa;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar.active {
            display: block;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: #4cc9f0;
            width: 0%;
            transition: width 0.3s;
        }
        
        .preview-panel {
            background: #16213e;
            border-radius: 8px;
            padding: 12px;
            display: none;
        }
        
        .preview-panel.active {
            display: block;
        }
        
        .instructions-banner {
            background: #16213e;
            border-radius: 8px;
            padding: 10px 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        
        .instructions-banner.hidden {
            display: none;
        }
        
        .instructions-banner h3 {
            color: #4cc9f0;
            font-size: 0.9em;
            margin: 0 0 6px 0;
        }
        
        .instructions-banner ol {
            margin: 0;
            padding-left: 18px;
            font-size: 0.8em;
            color: #aaa;
            line-height: 1.5;
        }
        
        .instructions-banner ol li {
            margin-bottom: 2px;
        }
        
        .instructions-content {
            flex: 1;
        }
        
        .instructions-close {
            background: none;
            border: none;
            color: #666;
            font-size: 1.2em;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .instructions-close:hover {
            color: #fff;
        }
        
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .preview-header h3 {
            color: #4cc9f0;
            font-size: 1em;
            margin: 0;
        }
        
        .preview-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.2em;
            cursor: pointer;
        }
        
        .preview-close:hover {
            color: #fff;
        }
        
        .map-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 6px 10px;
            background: #16213e;
            border-radius: 4px;
            font-size: 0.75em;
        }
        
        .preview-canvas-container {
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            cursor: grab;
        }
        
        .preview-canvas-container:active {
            cursor: grabbing;
        }
        
        #previewCanvas {
            display: block;
            width: 100%;
            height: 400px;
        }
        
        .preview-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .preview-control-btn {
            width: 32px;
            height: 32px;
            background: rgba(22, 33, 62, 0.9);
            border: 1px solid #4cc9f0;
            border-radius: 4px;
            color: #4cc9f0;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .preview-control-btn:hover {
            background: #4cc9f0;
            color: #0f1419;
        }
        
        .map-controls {
            position: absolute;
            top: 80px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }
        
        .map-control-btn {
            width: 38px;
            height: 38px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #333;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-size: 1.3em;
        }
        
        .map-control-btn:hover {
            background: #4cc9f0;
            border-color: #4cc9f0;
            transform: scale(1.05);
        }
        
        .map-control-btn:active {
            transform: scale(0.95);
        }
        
        .map-control-btn.active {
            background: #4cc9f0;
            border-color: #4cc9f0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .legend-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }
        
        /* Replace polygon icon with diagonal line */
        .leaflet-draw-draw-polygon {
            background-image: none !important;
            position: relative;
        }
        /* Waypoint button - clear default sprite background */
        .leaflet-draw-draw-waypoint {
            background-image: none !important;
            display: flex !important;
            align-items: center;
            justify-content: center;
        }
        .leaflet-draw-draw-polygon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 18px;
            height: 3px;
            background: #464646;
            border-radius: 1px;
            transform: translate(-50%, -50%) rotate(-45deg);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>HardwareOne Map Converter</h1>
            <p>Create offline map files for your ESP32 device</p>
        </header>
        
        <div class="main-content">
            <div class="map-row">
                <div class="instructions-banner" id="instructionsBanner">
                    <div class="instructions-content">
                        <h3>How to Use</h3>
                        <ol>
                            <li>Draw a rectangle or polygon on the map to select your area</li>
                            <li>Adjust features and settings in the sidebar</li>
                            <li>Click "Preview" to see what will be included, then "Generate" to download</li>
                        </ol>
                    </div>
                    <button class="instructions-close" onclick="document.getElementById('instructionsBanner').classList.add('hidden')">✕</button>
                </div>
                <div style="position:relative;">
                    <div id="map"></div>
                    <!-- Map controls overlay - shows after selection -->
                    <div class="map-controls" id="mapControls" style="display:none;">
                        <button class="map-control-btn" id="clearSelectionBtn" onclick="clearSelection()" title="Clear Selection">X</button>
                    </div>
                </div>
                <div class="map-legend">
                    <div class="legend-item"><span class="legend-color" style="background:#ff6b6b"></span> Highways</div>
                    <div class="legend-item"><span class="legend-color" style="background:#ffd93d"></span> Major Roads</div>
                    <div class="legend-item"><span class="legend-color" style="background:#ffffff"></span> Minor Roads</div>
                    <div class="legend-item"><span class="legend-color" style="background:#4dabf7"></span> Water</div>
                    <div class="legend-item"><span class="legend-color" style="background:#69db7c"></span> Parks/Land</div>
                    <div class="legend-item"><span class="legend-color" style="background:#da77f2"></span> Railways</div>
                    <div class="legend-item"><span class="legend-color" style="background:#fab005"></span> Bus</div>
                    <div class="legend-item"><span class="legend-color" style="background:#15aabf"></span> Ferry</div>
                    <div class="legend-item"><span class="legend-color" style="background:#f06595;border-radius:50%;width:8px;height:8px"></span> Stations</div>
                </div>
                <div class="preview-panel" id="previewPanel">
                    <div class="preview-header">
                        <h3>Preview</h3>
                        <button class="preview-close" onclick="closePreview()">✕</button>
                    </div>
                    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;margin-top:6px;">
                        <div style="font-size:0.75em;color:#aaa;">
                            <span style="color:#888;font-weight:bold;">Mode:</span>
                            <label style="margin-left:8px;cursor:pointer;"><input type="radio" name="previewMode" id="previewModeDevice" value="device" checked onchange="requestPreviewRender()"> Device</label>
                            <label style="margin-left:10px;cursor:pointer;"><input type="radio" name="previewMode" id="previewModeGranular" value="granular" onchange="requestPreviewRender()"> Granular</label>
                        </div>
                        <div style="font-size:0.7em;color:#666;">Device = exact .hwmap render, Granular = OSM-tag separation</div>
                    </div>
                    <div class="preview-canvas-container" id="previewContainer">
                        <canvas id="previewCanvas"></canvas>
                        <div class="preview-controls">
                            <button class="preview-control-btn" onclick="zoomPreview(1.2)" title="Zoom in">+</button>
                            <button class="preview-control-btn" onclick="zoomPreview(0.8)" title="Zoom out">−</button>
                            <button class="preview-control-btn" onclick="resetPreviewZoom()" title="Reset view">⟲</button>
                        </div>
                    </div>
                    <div class="preview-layers" style="padding:8px;background:#0d0d1a;border-radius:4px;margin-top:6px;font-size:0.7em;">
                        <div style="display:flex;flex-wrap:wrap;gap:4px 10px;margin-bottom:6px;padding-bottom:6px;border-bottom:1px solid #333;">
                            <span style="color:#888;font-weight:bold;width:100%;margin-bottom:2px;">Roads:</span>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerMotorways" checked onchange="renderPreview()"><span style="color:#ff6b6b;">Motorways</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerTrunk" checked onchange="renderPreview()"><span style="color:#ff8787;">Trunk</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerPrimary" checked onchange="renderPreview()"><span style="color:#ffd93d;">Primary</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerSecondary" checked onchange="renderPreview()"><span style="color:#ffe066;">Secondary</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerTertiary" checked onchange="renderPreview()"><span style="color:#fff;">Tertiary</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerResidential" checked onchange="renderPreview()"><span style="color:#ddd;">Residential</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerService" checked onchange="renderPreview()"><span style="color:#bbb;">Service</span></label>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:4px 10px;margin-bottom:6px;padding-bottom:6px;border-bottom:1px solid #333;">
                            <span style="color:#888;font-weight:bold;width:100%;margin-bottom:2px;">Paths:</span>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerFootways" checked onchange="renderPreview()"><span style="color:#aaa;">Footways</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerCycleways" checked onchange="renderPreview()"><span style="color:#74c0fc;">Cycleways</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerTracks" checked onchange="renderPreview()"><span style="color:#a9e34b;">Trails</span></label>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:4px 10px;margin-bottom:6px;padding-bottom:6px;border-bottom:1px solid #333;">
                            <span style="color:#888;font-weight:bold;width:100%;margin-bottom:2px;">Water:</span>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerLakes" checked onchange="renderPreview()"><span style="color:#4dabf7;">Lakes/Ponds</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerRivers" checked onchange="renderPreview()"><span style="color:#339af0;">Rivers</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerCoastlines" checked onchange="renderPreview()"><span style="color:#1c7ed6;">Coastlines</span></label>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:4px 10px;margin-bottom:6px;padding-bottom:6px;border-bottom:1px solid #333;">
                            <span style="color:#888;font-weight:bold;width:100%;margin-bottom:2px;">Nature:</span>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerParks" checked onchange="renderPreview()"><span style="color:#69db7c;">Parks</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerForests" checked onchange="renderPreview()"><span style="color:#2f9e44;">Forests</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerGrassland" checked onchange="renderPreview()"><span style="color:#8fbc8f;">Grassland</span></label>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:4px 10px;">
                            <span style="color:#888;font-weight:bold;width:100%;margin-bottom:2px;">Infrastructure:</span>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerRailway" checked onchange="renderPreview()"><span style="color:#da77f2;">Railways</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerSubways" checked onchange="renderPreview()"><span style="color:#be4bdb;">Subways</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerBus" checked onchange="renderPreview()"><span style="color:#fab005;">Bus</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerFerry" checked onchange="renderPreview()"><span style="color:#15aabf;">Ferry</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerStations" checked onchange="renderPreview()"><span style="color:#f783ac;">Stations</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerBuildings" checked onchange="renderPreview()"><span style="color:#868e96;">Buildings</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerIndustrial" checked onchange="renderPreview()"><span style="color:#adb5bd;">Industrial</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerCommercial" checked onchange="renderPreview()"><span style="color:#ced4da;">Commercial</span></label>
                            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;"><input type="checkbox" id="layerResidentialArea" checked onchange="renderPreview()"><span style="color:#dee2e6;">Residential Areas</span></label>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="sidebar">
                <h2>Map Settings</h2>
                
                <button class="btn btn-secondary" onclick="useMyLocation()">
                    Use My Location
                </button>
                
                <div class="form-group">
                    <label>Region Name</label>
                    <input type="text" id="regionName" value="My Area" maxlength="15">
                </div>
                
                <!-- Waypoints Section - Near top for easy access -->
                <div class="section-title" onclick="toggleSection(this)" data-section="waypoints" style="background:#2a2a4e;margin-bottom:0;">
                    Waypoints <span class="section-count" id="countWaypoints">(0)</span>
                </div>
                <div class="section-content" id="waypointsContent" style="display:block !important;padding:8px;background:#1a1a2e;border-radius:0 0 4px 4px;margin-bottom:12px;">
                    <div id="waypointsToolbar" style="padding:6px 0 10px 0;margin-bottom:10px;border-bottom:1px solid #333;">
                        <button class="btn btn-secondary" onclick="exportWaypoints()" style="padding:6px 14px;font-size:0.75em;">Export</button>
                        <button class="btn btn-secondary" onclick="importWaypoints()" style="padding:6px 14px;font-size:0.75em;">Import</button>
                        <button class="btn btn-secondary" onclick="clearAllWaypoints()" style="padding:6px 14px;font-size:0.75em;">Clear</button>
                    </div>
                    <div id="waypointList" style="max-height:150px;overflow-y:auto;"></div>
                </div>

                <!-- Features Section - All feature categories nested inside -->
                <div class="section-title" onclick="toggleSection(this)" data-section="allfeatures" style="background:#2a2a4e;margin-bottom:0;">
                    Features <span class="section-count" id="countAllFeatures"></span>
                </div>
                <div class="section-content" id="allFeaturesContent" style="padding:4px 8px;background:#1a1a2e;border-radius:0 0 4px 4px;margin-bottom:12px;">
                    <div class="section-title" onclick="toggleSection(this)" data-section="highways" style="font-size:0.9em;">Highways <span class="section-count" id="countHighways">(2/2)</span></div>
                    <div class="section-content">
                        <label class="checkbox-item">
                            <input type="checkbox" id="motorways" checked onchange="updateSectionCounts()">
                            Motorways <span class="feature-size" id="size-motorways"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="trunkRoads" checked onchange="updateSectionCounts()">
                            Trunk/US Routes <span class="feature-size" id="size-trunkRoads"></span>
                        </label>
                    </div>
                    
                    <div class="section-title" onclick="toggleSection(this)" data-section="roads" style="font-size:0.9em;">Roads <span class="section-count" id="countRoads">(2/5)</span></div>
                    <div class="section-content">
                        <label class="checkbox-item">
                            <input type="checkbox" id="primaryRoads" checked onchange="updateSectionCounts()">
                            Primary <span class="feature-size" id="size-primaryRoads"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="secondaryRoads" checked onchange="updateSectionCounts()">
                            Secondary <span class="feature-size" id="size-secondaryRoads"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="tertiaryRoads" onchange="updateSectionCounts()">
                            Tertiary <span class="feature-size" id="size-tertiaryRoads"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="residentialRoads" onchange="updateSectionCounts()">
                            Residential <span class="feature-size" id="size-residentialRoads"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="serviceRoads" onchange="updateSectionCounts()">
                            Service <span class="feature-size" id="size-serviceRoads"></span>
                        </label>
                    </div>
                    
                    <div class="section-title collapsed" onclick="toggleSection(this)" data-section="paths" style="font-size:0.9em;">Paths <span class="section-count" id="countPaths">(0/3)</span></div>
                    <div class="section-content collapsed">
                        <label class="checkbox-item">
                            <input type="checkbox" id="footways" onchange="updateSectionCounts()">
                            Footways <span class="feature-size" id="size-footways"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="cycleways" onchange="updateSectionCounts()">
                            Bike Paths <span class="feature-size" id="size-cycleways"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="tracks" onchange="updateSectionCounts()">
                            Trails <span class="feature-size" id="size-tracks"></span>
                        </label>
                    </div>
                    
                    <div class="section-title" onclick="toggleSection(this)" data-section="water" style="font-size:0.9em;">Water <span class="section-count" id="countWater">(1/3)</span></div>
                    <div class="section-content">
                        <label class="checkbox-item">
                            <input type="checkbox" id="waterBodies" checked onchange="updateSectionCounts()">
                            Lakes/Ponds <span class="feature-size" id="size-waterBodies"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="waterways" onchange="updateSectionCounts()">
                            Rivers <span class="feature-size" id="size-waterways"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="coastlines" onchange="updateSectionCounts(); updateCoastlineSubOptions();">
                            Coastlines <span class="feature-size" id="size-coastlines"></span>
                        </label>
                        <div id="coastlineSubOptions" style="grid-column: span 2; display: flex; flex-direction: column; gap: 4px; padding-left: 16px; margin: 4px 0;">
                            <label class="checkbox-item coastline-sub-option" id="landMaskLabel" style="font-size: 0.85em; opacity: 0.4;">
                                <input type="checkbox" id="landMask" onchange="updateSectionCounts()" disabled checked>
                                Include land mask <span class="feature-size" id="size-landMask"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="section-title collapsed" onclick="toggleSection(this)" data-section="nature" style="font-size:0.9em;">Nature <span class="section-count" id="countNature">(0/3)</span></div>
                    <div class="section-content collapsed">
                        <label class="checkbox-item">
                            <input type="checkbox" id="parks" onchange="updateSectionCounts()">
                            Parks <span class="feature-size" id="size-parks"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="forests" onchange="updateSectionCounts()">
                            Forests <span class="feature-size" id="size-forests"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="grassland" onchange="updateSectionCounts()">
                            Grassland <span class="feature-size" id="size-grassland"></span>
                        </label>
                    </div>
                    
                    <div class="section-title collapsed" onclick="toggleSection(this)" data-section="infrastructure" style="font-size:0.9em;">Infrastructure <span class="section-count" id="countInfrastructure">(0/11)</span></div>
                    <div class="section-content collapsed">
                        <label class="checkbox-item">
                            <input type="checkbox" id="railways" onchange="updateSectionCounts()">
                            Railways <span class="feature-size" id="size-railways"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="subways" onchange="updateSectionCounts()">
                            Subways <span class="feature-size" id="size-subways"></span>
                        </label>
                        <div id="subwayRoutesList" style="display:none;grid-column:span 2;font-size:0.75em;max-height:120px;overflow-y:auto;background:#0d0d1a;border-radius:4px;padding:6px;margin:4px 0;"></div>
                        <label class="checkbox-item">
                            <input type="checkbox" id="busRoutes" onchange="updateSectionCounts()">
                            Bus Routes <span class="feature-size" id="size-busRoutes"></span>
                        </label>
                        <div id="busRoutesList" style="display:none;grid-column:span 2;font-size:0.75em;max-height:120px;overflow-y:auto;background:#0d0d1a;border-radius:4px;padding:6px;margin:4px 0;"></div>
                        <label class="checkbox-item">
                            <input type="checkbox" id="ferryRoutes" onchange="updateSectionCounts()">
                            Ferry Routes <span class="feature-size" id="size-ferryRoutes"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="transitStations" onchange="updateSectionCounts()">
                            Transit Stations <span class="feature-size" id="size-transitStations"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="bridges" onchange="updateSectionCounts()">
                            Bridges <span class="feature-size" id="size-bridges"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="powerlines" onchange="updateSectionCounts()">
                            Power Lines <span class="feature-size" id="size-powerlines"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="buildings" onchange="updateSectionCounts(); updateBuildingSubOptions();">
                            Buildings <span class="feature-size" id="size-buildings"></span>
                        </label>
                        <div id="buildingSubOptions" style="grid-column: span 2; display: flex; flex-direction: column; gap: 4px; padding-left: 16px; margin: 4px 0;">
                            <label class="checkbox-item building-sub-option" id="buildingsLargeOnlyLabel" style="font-size: 0.85em; opacity: 0.4;">
                                <input type="checkbox" id="buildingsLargeOnly" onchange="updateSectionCounts(); updateLargeBuildingSliders();" disabled>
                                Large only <span class="feature-size" id="size-buildingsLargeOnly"></span>
                            </label>
                            <div id="largeBuildingSettings" style="display: none; padding-left: 8px; margin: 4px 0; font-size: 0.8em;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                    <span style="min-width: 70px;">Min Area:</span>
                                    <input type="range" id="buildingMinArea" min="50" max="1000" value="200" step="50" 
                                           style="flex: 1;" oninput="updateBuildingMinAreaLabel(); updateSectionCounts();">
                                    <span id="buildingMinAreaValue" style="min-width: 50px;">200m²</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="min-width: 70px;">Min Floors:</span>
                                    <input type="range" id="buildingMinFloors" min="2" max="10" value="3" step="1" 
                                           style="flex: 1;" oninput="updateBuildingMinFloorsLabel(); updateSectionCounts();">
                                    <span id="buildingMinFloorsValue" style="min-width: 50px;">3+</span>
                                </div>
                            </div>
                            <label class="checkbox-item building-sub-option" id="buildingNamesLabel" style="font-size: 0.85em; opacity: 0.4;">
                                <input type="checkbox" id="buildingNames" onchange="updateSectionCounts()" disabled>
                                Include names
                            </label>
                        </div>
                        <label class="checkbox-item">
                            <input type="checkbox" id="industrial" onchange="updateSectionCounts()">
                            Industrial <span class="feature-size" id="size-industrial"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="commercial" onchange="updateSectionCounts()">
                            Commercial <span class="feature-size" id="size-commercial"></span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="residential" onchange="updateSectionCounts()">
                            Residential <span class="feature-size" id="size-residential"></span>
                        </label>
                    </div>
                </div>
                
                <!-- Post-Processing Section -->
                <div class="section-title" onclick="toggleSection(this)" data-section="postprocessing" style="background:#2a2a4e;margin-bottom:0;">
                    Output Settings
                </div>
                <div class="section-content" id="outputSettingsContent" style="display:block;padding:10px 12px;background:#1a1a2e;border-radius:0 0 4px 4px;margin-bottom:12px;">
                    <div class="slider-group" style="margin-bottom:8px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                            <label style="font-size:0.85em;color:#aaa;">Name Detail</label>
                            <span class="slider-value" id="nameDetailValue" style="font-size:0.85em;color:#4cc9f0;">Everything</span>
                        </div>
                        <input type="range" id="nameDetail" min="0" max="4" value="4" style="width:100%;">
                        <div style="font-size:0.7em;color:#666;margin-top:4px;" id="nameDetailDesc">
                            Highways + major roads get names for "where am I" context
                        </div>
                    </div>
                    
                    <div style="margin:16px 0 12px 0;padding-top:12px;border-top:1px solid #333;">
                        <div style="font-size:0.85em;color:#aaa;margin-bottom:8px;font-weight:bold;">HWMAP v5 Format</div>
                        <div style="font-size:0.7em;color:#666;margin-bottom:12px;">Tiled encoding for efficient streaming (default format)</div>
                        
                        <div class="slider-group" style="margin-bottom:12px;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                                <label style="font-size:0.85em;color:#aaa;">Tile Grid</label>
                                <span class="slider-value" id="v5TileGridValue" style="font-size:0.85em;color:#4cc9f0;">32×32</span>
                            </div>
                            <select id="v5TileGrid" style="width:100%;padding:6px;border-radius:4px;background:#0d0d1a;color:#fff;border:1px solid #333;">
                                <option value="16">16×16 (256 tiles)</option>
                                <option value="32" selected>32×32 (1024 tiles)</option>
                                <option value="64">64×64 (4096 tiles)</option>
                            </select>
                            <div style="font-size:0.7em;color:#666;margin-top:4px;">
                                Smaller tiles = less geometry per tile, more overhead
                            </div>
                        </div>
                        
                        <div class="slider-group" style="margin-bottom:12px;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                                <label style="font-size:0.85em;color:#aaa;">Tile Halo</label>
                                <span class="slider-value" id="v5HaloValue" style="font-size:0.85em;color:#4cc9f0;">10%</span>
                            </div>
                            <input type="range" id="v5HaloPct" min="0" max="20" step="1" value="10" style="width:100%;">
                            <div style="font-size:0.7em;color:#666;margin-top:4px;">
                                Overlap between tiles to prevent seams (0-20%)
                            </div>
                        </div>
                        
                        <div class="slider-group" style="margin-bottom:12px;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                                <label style="font-size:0.85em;color:#aaa;">Quantization</label>
                                <span class="slider-value" id="v5QuantValue" style="font-size:0.85em;color:#4cc9f0;">16-bit</span>
                            </div>
                            <input type="range" id="v5QuantBits" min="10" max="16" step="1" value="16" style="width:100%;">
                            <div style="font-size:0.7em;color:#666;margin-top:4px;">
                                Lower = blockier shapes (10-bit = 1024 steps, 16-bit = 65536)
                            </div>
                        </div>
                        
                        <label class="checkbox-item" style="font-size:0.85em;display:flex;align-items:center;gap:6px;margin-bottom:0;">
                            <input type="checkbox" id="v5ShowTileBounds">
                            <span>Show tile boundaries (debug)</span>
                        </label>
                    </div>
                    
                    <div style="margin:16px 0 12px 0;padding-top:12px;border-top:1px solid #333;">
                        <div style="font-size:0.85em;color:#aaa;margin-bottom:8px;font-weight:bold;">Geometry Simplification</div>
                        <div style="font-size:0.7em;color:#666;margin-bottom:8px;">Reduce file size by simplifying complex shapes. Each slider controls max points per feature.</div>
                        
                        <!-- Highways -->
                        <div style="font-size:0.75em;color:#888;margin:10px 0 4px 0;font-weight:bold;">Highways</div>
                        <label class="checkbox-item" id="simplifyMotorwaysLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyMotorways" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Motorways</span>
                            </div>
                            <span id="simplifyMotorwaysSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="motorwaysSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="motorwaysSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="motorwaysSimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('motorways')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifyTrunkLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyTrunk" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Trunk/US Routes</span>
                            </div>
                            <span id="simplifyTrunkSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="trunkSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="trunkSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="trunkSimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('trunk')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        
                        <!-- Roads -->
                        <div style="font-size:0.75em;color:#888;margin:10px 0 4px 0;font-weight:bold;">Roads</div>
                        <label class="checkbox-item" id="simplifyPrimaryLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyPrimary" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Primary</span>
                            </div>
                            <span id="simplifyPrimarySavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="primarySimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="primarySimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="primarySimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('primary')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifySecondaryLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifySecondary" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Secondary</span>
                            </div>
                            <span id="simplifySecondarySavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="secondarySimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="secondarySimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="secondarySimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('secondary')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifyTertiaryLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyTertiary" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Tertiary</span>
                            </div>
                            <span id="simplifyTertiarySavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="tertiarySimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="tertiarySimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="tertiarySimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('tertiary')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifyResidentialLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyResidential" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Residential</span>
                            </div>
                            <span id="simplifyResidentialSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="residentialSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="residentialSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="residentialSimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('residential')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifyServiceLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyService" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Service</span>
                            </div>
                            <span id="simplifyServiceSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="serviceSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="serviceSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="serviceSimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('service')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        
                        <!-- Paths & Transit -->
                        <div style="font-size:0.75em;color:#888;margin:10px 0 4px 0;font-weight:bold;">Paths & Transit</div>
                        <label class="checkbox-item" id="simplifyPathsLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyPaths" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Paths & trails</span>
                            </div>
                            <span id="simplifyPathsSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="pathsSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="pathsSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">10 pts</span>
                            </div>
                            <input type="range" id="pathsSimplifyPoints" min="10" max="30" step="1" value="10" style="width:100%;" disabled oninput="updateRoadSimplifyValue('paths')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <div id="pathLengthSliderContainer" style="padding-left:20px;margin-bottom:4px;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Min length</label>
                                <span id="pathLengthValue" style="font-size:0.7em;color:#4cc9f0;">0m (all)</span>
                            </div>
                            <input type="range" id="pathMinLength" min="0" max="500" step="25" value="0" style="width:100%;" oninput="updatePathLengthValue(); updateStats();" onchange="updatePathLengthValue(); updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifyBusLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyBus" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Bus routes</span>
                            </div>
                            <span id="simplifyBusSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="busSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="busSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="busSimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('bus')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifyRailLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyRail" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Rail/Subway</span>
                            </div>
                            <span id="simplifyRailSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="railSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="railSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="railSimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('rail')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifyFerryLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyFerry" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Ferry routes (fewer points)</span>
                            </div>
                            <span id="simplifyFerrySavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="ferrySimplifyContainer" style="padding-left:20px;margin-bottom:6px;opacity:0.4;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.75em;color:#888;">Max points</label>
                                <span id="ferrySimplifyValue" style="font-size:0.75em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="ferrySimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateTransitSimplifyValue('ferry')" onchange="updateStats()">
                        </div>
                        
                        <!-- Infrastructure -->
                        <div style="font-size:0.75em;color:#888;margin:10px 0 4px 0;font-weight:bold;">Infrastructure</div>
                        <label class="checkbox-item" id="simplifyStationsLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyStations" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Transit Stations</span>
                            </div>
                            <span id="simplifyStationsSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="stationsSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="stationsSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="stationsSimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('stations')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifyBridgesLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyBridges" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Bridges</span>
                            </div>
                            <span id="simplifyBridgesSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="bridgesSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="bridgesSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="bridgesSimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('bridges')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifyIndustrialLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyIndustrial" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Industrial areas</span>
                            </div>
                            <span id="simplifyIndustrialSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="industrialSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="industrialSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="industrialSimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('industrial')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifyCommercialLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyCommercial" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Commercial areas</span>
                            </div>
                            <span id="simplifyCommercialSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="commercialSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="commercialSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="commercialSimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('commercial')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                        <label class="checkbox-item" id="simplifyResidentialAreaLabel" style="font-size:0.85em;display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;opacity:0.4;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="checkbox" id="simplifyResidentialArea" onchange="updateStats(); updateSimplifySliders();" disabled>
                                <span>Residential areas</span>
                            </div>
                            <span id="simplifyResidentialAreaSavings" style="font-size:0.8em;color:#69db7c;"></span>
                        </label>
                        <div id="residentialAreaSimplifyContainer" style="padding-left:20px;margin-bottom:4px;opacity:0.4;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                                <label style="font-size:0.7em;color:#888;">Max points</label>
                                <span id="residentialAreaSimplifyValue" style="font-size:0.7em;color:#4cc9f0;">12 pts</span>
                            </div>
                            <input type="range" id="residentialAreaSimplifyPoints" min="12" max="30" step="1" value="12" style="width:100%;" disabled oninput="updateRoadSimplifyValue('residentialArea')" onchange="updateStats(); triggerAutoPreview();">
                        </div>
                    </div>
                    
                    <div class="slider-group" style="margin-bottom:12px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                            <label style="font-size:0.85em;color:#aaa;">Target Size Budget</label>
                            <span class="slider-value" id="budgetValue" style="font-size:0.85em;color:#4cc9f0;">1.5 MB</span>
                        </div>
                        <input type="range" id="sizeBudget" min="50" max="25000" step="50" value="1500" style="width:100%;">
                        <div class="size-bar" style="margin-top:6px;">
                            <div class="size-bar-fill" id="sizeBarFill"></div>
                        </div>
                    </div>
                    
                    <label class="checkbox-item" style="font-size:0.85em;display:flex;align-items:center;gap:6px;margin-bottom:0;">
                        <input type="checkbox" id="autoFitBudget">
                        <span>Auto-trim to fit budget</span>
                    </label>
                </div>
                
                <div class="size-warning" id="sizeWarning">
                    Estimated size exceeds budget. Try reducing area or features.
                </div>
                
                <div class="stats">
                    <div class="stats-row">
                        <span>Area Size:</span>
                        <span class="stats-value" id="areaSize">-- × -- km</span>
                    </div>
                    <div class="stats-row">
                        <span>Estimated Size:</span>
                        <span class="stats-value" id="estSize">-- KB</span>
                    </div>
                    <div class="stats-row">
                        <span>Features:</span>
                        <span class="stats-value" id="featureCount">--</span>
                    </div>
                </div>
                
                <div id="sizeBreakdown" class="size-breakdown" style="display:none;margin-top:10px;padding:8px;background:#1a1a2e;border-radius:4px;font-size:0.8em;">
                    <div style="color:#888;margin-bottom:4px;">Size breakdown (est.):</div>
                    <div id="breakdownContent"></div>
                </div>
                
                <div id="mapFeaturesPanel" style="display:none;margin-top:10px;margin-bottom:12px;padding:10px;background:#1a1a2e;border-radius:4px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                        <span style="color:#4cc9f0;font-size:0.9em;font-weight:bold;">Names Found</span>
                        <span id="metadataSizeEst" style="font-size:0.75em;color:#888;"></span>
                    </div>
                    <div id="mapFeaturesList" style="font-size:0.8em;max-height:200px;overflow-y:auto;"></div>
                    <div id="nameSummary" style="margin-top:8px;padding-top:8px;border-top:1px solid #333;font-size:0.75em;color:#888;"></div>
                    <div id="buildingNameSummary" style="margin-top:4px;font-size:0.75em;color:#b197fc;"></div>
                </div>
                
                <div id="actualResults" class="size-breakdown" style="display:none;margin-top:10px;padding:8px;background:#1a2e1a;border:1px solid #69db7c;border-radius:4px;font-size:0.8em;">
                    <div style="color:#69db7c;margin-bottom:8px;font-weight:bold;display:flex;align-items:center;gap:4px;">
                        <span>✓</span>
                        <span>Generated Map File</span>
                    </div>
                    <div style="display:grid;grid-template-columns:auto 1fr;gap:4px 8px;color:#ddd;">
                        <span style="color:#888;">File Size:</span>
                        <span id="actualFileSize" style="color:#69db7c;font-weight:bold;">--</span>
                        
                        <span style="color:#888;">Features:</span>
                        <span id="actualFeatureCount">--</span>
                        
                        <span style="color:#888;">Named Features:</span>
                        <span id="actualNamedCount">--</span>
                        
                        <span style="color:#888;">Unique Names:</span>
                        <span id="actualNameCount">--</span>
                        
                        <span style="color:#888;">Total Points:</span>
                        <span id="actualPointCount">--</span>
                    </div>
                    <div style="margin-top:8px;padding-top:8px;border-top:1px solid #2a5a2a;">
                        <div style="color:#888;margin-bottom:4px;font-size:0.9em;">Size by Type:</div>
                        <div id="actualBreakdown"></div>
                    </div>
                </div>
                
                <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;">
                    <button class="btn btn-secondary" id="previewBtn" onclick="previewMap()" disabled style="flex:1;margin-bottom:0;">
                        Preview Selection
                    </button>
                    <label class="checkbox-item" style="font-size:0.8em;white-space:nowrap;" title="Auto-refresh preview when settings change">
                        <input type="checkbox" id="autoPreview" onchange="handleAutoPreviewToggle()">
                        Auto
                    </label>
                </div>
                
                <button class="btn btn-primary" id="generateBtn" onclick="generateMap()" disabled>
                    Generate Map File
                </button>
                
                <div class="progress-bar" id="progressBar">
                    <div class="progress-bar-fill" id="progressFill"></div>
                </div>
                
                <div class="status ready" id="status">
                    Draw a rectangle or polygon on the map to select area
                </div>
                
            </div>
        </div>
        
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    
    <script>
        // =============================================================================
        // PREVIEW FEATURE TYPE CONSTANTS (for simplification)
        // =============================================================================
        
        const PREVIEW_TYPES = {
            HIGHWAY: 'highway',
            ROAD_MAJOR: 'road_major',
            ROAD_MINOR: 'road_minor',
            PATH: 'path',
            WATER: 'water',
            PARK: 'park',
            RAILWAY: 'railway',
            BUS: 'bus',
            FERRY: 'ferry',
            BUILDING: 'building',
            STATION: 'station'
        };
        
        function getFeatureType(tags) {
            if (!tags) return null;
            
            if (tags.highway) {
                if (['motorway', 'motorway_link', 'trunk', 'trunk_link'].includes(tags.highway)) {
                    return PREVIEW_TYPES.HIGHWAY;
                }
                if (['primary', 'secondary', 'primary_link', 'secondary_link'].includes(tags.highway)) {
                    return PREVIEW_TYPES.ROAD_MAJOR;
                }
                if (['tertiary', 'tertiary_link', 'residential', 'unclassified', 'service', 'living_street'].includes(tags.highway)) {
                    return PREVIEW_TYPES.ROAD_MINOR;
                }
                if (['footway', 'path', 'cycleway', 'track', 'pedestrian', 'steps', 'bridleway'].includes(tags.highway)) {
                    return PREVIEW_TYPES.PATH;
                }
            }
            if (tags.railway) {
                if (['station', 'halt'].includes(tags.railway)) return PREVIEW_TYPES.STATION;
                return PREVIEW_TYPES.RAILWAY;
            }
            if (tags.route === 'bus' || tags.route === 'trolleybus') return PREVIEW_TYPES.BUS;
            if (tags.route === 'ferry') return PREVIEW_TYPES.FERRY;
            if (tags.amenity === 'bus_station' || tags.amenity === 'ferry_terminal') return PREVIEW_TYPES.STATION;
            if (tags.natural === 'water' || tags.natural === 'bay' || tags.natural === 'strait' ||
                tags.water || tags.harbour || tags.place === 'sea' ||
                tags.waterway === 'riverbank' || tags.waterway === 'dock' ||
                tags.landuse === 'basin' || tags.landuse === 'reservoir' ||
                tags.waterway || tags.natural === 'coastline') return PREVIEW_TYPES.WATER;
            if (tags.leisure === 'park' || tags.leisure === 'garden' || tags.leisure === 'recreation_ground' || 
                tags.leisure === 'playground' || tags.leisure === 'golf_course' || tags.leisure === 'nature_reserve' ||
                tags.natural === 'wood' || tags.landuse === 'forest' || tags.landuse === 'grass' ||
                tags.landuse === 'village_green' || tags.landuse === 'allotments' || tags.landuse === 'meadow' ||
                tags.landuse === 'grassland' || tags.natural === 'grassland' || tags.natural === 'heath' ||
                tags.natural === 'scrub') return PREVIEW_TYPES.PARK;
            if (tags.building) return PREVIEW_TYPES.BUILDING;
            
            return null;
        }
        
        // =============================================================================
        // MAP INITIALIZATION
        // =============================================================================
        
        const map = L.map('map').setView([40.7128, -74.0060], 13);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 30
        }).addTo(map);
        
        // Drawing layer
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
        
        // Draw control - rectangle and polygon (click-to-place vertices)
        const drawControl = new L.Control.Draw({
            draw: {
                rectangle: {
                    shapeOptions: {
                        color: '#ff6b35',
                        weight: 5,
                        fillOpacity: 0.25,
                        fillColor: '#ffd93d',
                        dashArray: '10, 5'
                    }
                },
                polygon: {
                    allowIntersection: false,
                    shapeOptions: {
                        color: '#ff6b35',
                        weight: 5,
                        fillOpacity: 0.25,
                        fillColor: '#ffd93d',
                        dashArray: '10, 5'
                    },
                    showArea: true,
                    metric: true
                },
                circle: {
                    shapeOptions: {
                        color: '#ff6b35',
                        weight: 5,
                        fillOpacity: 0.25,
                        fillColor: '#ffd93d',
                        dashArray: '10, 5'
                    },
                    showRadius: true,
                    metric: true
                },
                circlemarker: false,
                marker: false,
                polyline: false
            },
            edit: false
        });
        map.addControl(drawControl);
        
        // Inject waypoint button into the draw toolbar
        setTimeout(() => {
            const drawToolbar = document.querySelector('.leaflet-draw-toolbar');
            if (drawToolbar) {
                const waypointBtn = document.createElement('a');
                waypointBtn.id = 'waypointModeBtn';
                waypointBtn.className = 'leaflet-draw-draw-waypoint';
                waypointBtn.href = '#';
                waypointBtn.title = 'Add Waypoint';
                waypointBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="display:block;"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>`;
                waypointBtn.onclick = (e) => { e.preventDefault(); toggleWaypointModeFromMap(); };
                drawToolbar.appendChild(waypointBtn);
            }
        }, 0);
        
        // Current selection - can be bounds (rect) or polygon
        let selectedBounds = null;
        let selectedPolygon = null;

        let previewRunId = 0;
        let generateRunId = 0;
        
        // Preview layer for showing selected features
        let previewLayer = new L.LayerGroup();
        map.addLayer(previewLayer);
        
        // =============================================================================
        // WAYPOINT MANAGEMENT
        // =============================================================================
        
        let waypoints = [];
        let waypointMarkers = [];
        let waypointAddMode = false;
        let waypointIdCounter = 0;

        function escapeHtml(value) {
            const s = String(value ?? '');
            return s
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function normalizeNewlines(s) {
            return String(s ?? '').replace(/\r\n?/g, '\n');
        }

        function stripControlChars(s, allowNewlines) {
            const normalized = normalizeNewlines(s);
            if (allowNewlines) {
                return normalized.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
            }
            return normalized.replace(/[\x00-\x1F\x7F]/g, '');
        }

        function sanitizeWaypointName(name) {
            const s = stripControlChars(name, false).trim();
            return (s || 'WP').substring(0, 11);
        }

        function sanitizeWaypointNotes(notes) {
            const s = stripControlChars(notes, true);
            return s.substring(0, 255);
        }

        function sanitizeWaypointFiles(files) {
            let arr = [];
            if (Array.isArray(files)) arr = files;
            else if (typeof files === 'string') arr = normalizeNewlines(files).split('\n');

            return arr
                .map(f => stripControlChars(f, false).trim().substring(0, 63))
                .filter(f => f.length > 0)
                .slice(0, 4);
        }

        function sanitizeWaypoint(raw, fallbackId) {
            if (!raw) return null;
            const lat = Number(raw.lat);
            const lon = Number(raw.lon);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
            if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return null;

            let id = Number(raw.id);
            if (!Number.isInteger(id) || id < 0) id = fallbackId;

            return {
                id,
                name: sanitizeWaypointName(raw.name),
                lat,
                lon,
                notes: sanitizeWaypointNotes(raw.notes),
                files: sanitizeWaypointFiles(raw.files)
            };
        }
        
        // Load waypoints from localStorage on startup
        function loadWaypointsFromStorage() {
            try {
                const stored = localStorage.getItem('mapgen_waypoints');
                if (stored) {
                    const data = JSON.parse(stored);
                    const rawWaypoints = Array.isArray(data.waypoints) ? data.waypoints : [];
                    const sanitized = [];
                    let nextId = 0;
                    rawWaypoints.forEach(wp => {
                        const s = sanitizeWaypoint(wp, nextId);
                        if (!s) return;
                        sanitized.push(s);
                        nextId = Math.max(nextId, s.id + 1);
                    });
                    waypoints = sanitized;
                    waypointIdCounter = Number.isInteger(data.nextId) ? Math.max(data.nextId, nextId) : nextId;
                    renderWaypointMarkers();
                    updateWaypointList();
                    saveWaypointsToStorage();
                }
            } catch (e) {
                console.error('Failed to load waypoints:', e);
            }
        }
        
        // Save waypoints to localStorage
        function saveWaypointsToStorage() {
            try {
                const data = {
                    waypoints: waypoints,
                    nextId: waypointIdCounter,
                    savedAt: new Date().toISOString()
                };
                localStorage.setItem('mapgen_waypoints', JSON.stringify(data));
            } catch (e) {
                console.error('Failed to save waypoints:', e);
            }
        }
        
        // Toggle waypoint mode from map button
        function toggleWaypointModeFromMap() {
            waypointAddMode = !waypointAddMode;
            updateWaypointModeUI();
        }
        
        // Update UI based on waypoint mode state
        function updateWaypointModeUI() {
            const btn = document.getElementById('waypointModeBtn');
            if (waypointAddMode) {
                map.getContainer().style.cursor = 'crosshair';
                btn.style.background = '#4cc9f0';
                btn.style.borderColor = '#4cc9f0';
                setStatus('ready', 'Click on the map to add a waypoint');
            } else {
                map.getContainer().style.cursor = '';
                btn.style.background = '#fff';
                btn.style.borderColor = 'rgba(0,0,0,0.2)';
                setStatus('ready', 'Draw a shape on the map to select area');
            }
        }
        
        // Add waypoint at clicked location
        function addWaypoint(lat, lon, name, notes, files) {
            const id = waypointIdCounter++;
            const waypoint = {
                id: id,
                name: sanitizeWaypointName(name || `WP${waypoints.length + 1}`),
                lat: Number(lat),
                lon: Number(lon),
                notes: sanitizeWaypointNotes(notes || ''),
                files: sanitizeWaypointFiles(files || [])
            };
            waypoints.push(waypoint);
            saveWaypointsToStorage();
            renderWaypointMarkers();
            updateWaypointList();
            return waypoint;
        }
        
        // Add file to waypoint
        function addFileToWaypoint(id, filePath) {
            const wp = waypoints.find(w => w.id === id);
            if (!wp) return false;
            if (!wp.files) wp.files = [];
            const sanitizedPath = stripControlChars(filePath, false).trim().substring(0, 63);
            if (!sanitizedPath) return false;
            if (wp.files.length >= 4) {
                alert('Maximum 4 files per waypoint');
                return false;
            }
            if (wp.files.includes(sanitizedPath)) {
                alert('File already attached');
                return false;
            }
            wp.files.push(sanitizedPath);
            saveWaypointsToStorage();
            renderWaypointMarkers();
            updateWaypointList();
            return true;
        }
        
        // Remove file from waypoint
        function removeFileFromWaypoint(id, fileIndex) {
            const wp = waypoints.find(w => w.id === id);
            if (!wp || !wp.files) return false;
            if (fileIndex < 0 || fileIndex >= wp.files.length) return false;
            wp.files.splice(fileIndex, 1);
            saveWaypointsToStorage();
            renderWaypointMarkers();
            updateWaypointList();
            return true;
        }
        
        // Multi-line text editor modal
        let textEditorCallback = null;
        function showTextEditor(title, placeholder, value, callback) {
            textEditorCallback = callback;
            document.getElementById('textEditorTitle').textContent = title;
            document.getElementById('textEditorArea').placeholder = placeholder;
            document.getElementById('textEditorArea').value = value || '';
            document.getElementById('textEditorModal').style.display = 'flex';
            document.getElementById('textEditorArea').focus();
        }
        
        function closeTextEditor() {
            document.getElementById('textEditorModal').style.display = 'none';
            textEditorCallback = null;
        }
        
        function saveTextEditor() {
            const value = document.getElementById('textEditorArea').value;
            if (textEditorCallback) {
                textEditorCallback(value);
            }
            closeTextEditor();
        }

        let activeWaypointInlineEditor = null;
        let waypointListExpandedForEditor = false;

        function setWaypointListExpanded(expanded) {
            const listEl = document.getElementById('waypointList');
            if (!listEl) return;

            waypointListExpandedForEditor = expanded;
            if (expanded) {
                listEl.style.maxHeight = 'none';
                listEl.style.overflowY = 'visible';
            } else {
                listEl.style.maxHeight = '150px';
                listEl.style.overflowY = 'auto';
            }
        }
        
        function ensureWaypointsSectionOpen() {
            const title = document.querySelector('.section-title[data-section="waypoints"]');
            if (title && title.classList.contains('collapsed')) {
                toggleSection(title);
            }
        }

        function setWaypointExpanded(id, expanded) {
            const actionsDiv = document.getElementById(`waypoint-actions-${id}`);
            const arrow = document.getElementById(`waypoint-arrow-${id}`);
            if (!actionsDiv || !arrow) return;
            
            const isExpanded = actionsDiv.style.display !== 'none';
            if (expanded && !isExpanded) {
                actionsDiv.style.display = 'block';
                arrow.textContent = '▼';
            } else if (!expanded && isExpanded) {
                actionsDiv.style.display = 'none';
                arrow.textContent = '▶';
            }
        }

        function openWaypointInlineEditor(id, type) {
            const wp = waypoints.find(w => w.id === id);
            if (!wp) return;

            ensureWaypointsSectionOpen();
            setWaypointExpanded(id, true);

            const cardEl = document.getElementById(`waypoint-card-${id}`);
            if (cardEl) {
                cardEl.scrollIntoView({ block: 'nearest' });
            }

            const editorEl = document.getElementById(`waypoint-inline-editor-${id}`);
            const titleEl = document.getElementById(`waypoint-inline-editor-title-${id}`);
            const textareaEl = document.getElementById(`waypoint-inline-editor-textarea-${id}`);
            if (!editorEl || !titleEl || !textareaEl) return;

            if (activeWaypointInlineEditor && activeWaypointInlineEditor.id !== id) {
                const prev = document.getElementById(`waypoint-inline-editor-${activeWaypointInlineEditor.id}`);
                if (prev) prev.style.display = 'none';
            }

            if (activeWaypointInlineEditor && activeWaypointInlineEditor.id === id && activeWaypointInlineEditor.type === type) {
                editorEl.style.display = 'none';
                activeWaypointInlineEditor = null;
                setWaypointListExpanded(false);
                return;
            }

            editorEl.dataset.type = type;
            if (type === 'notes') {
                titleEl.textContent = 'Notes';
                textareaEl.placeholder = 'Enter notes (optional, max 255 chars)';
                textareaEl.value = wp.notes || '';
            } else {
                titleEl.textContent = 'Files (one per line, max 4)';
                textareaEl.placeholder = 'Example: /photos/image1.jpg';
                textareaEl.value = (wp.files || []).join('\n');
            }

            editorEl.style.display = 'block';
            textareaEl.focus();
            activeWaypointInlineEditor = { id, type };
            setWaypointListExpanded(true);
        }

        function cancelWaypointInlineEditor(id) {
            const editorEl = document.getElementById(`waypoint-inline-editor-${id}`);
            if (editorEl) editorEl.style.display = 'none';
            if (activeWaypointInlineEditor && activeWaypointInlineEditor.id === id) {
                activeWaypointInlineEditor = null;
            }
            setWaypointListExpanded(false);
        }

        function saveWaypointInlineEditor(id) {
            const wp = waypoints.find(w => w.id === id);
            if (!wp) return;
            const editorEl = document.getElementById(`waypoint-inline-editor-${id}`);
            const textareaEl = document.getElementById(`waypoint-inline-editor-textarea-${id}`);
            if (!editorEl || !textareaEl) return;

            const type = editorEl.dataset.type;
            const value = textareaEl.value || '';

            if (type === 'notes') {
                wp.notes = sanitizeWaypointNotes(value);
            } else {
                wp.files = sanitizeWaypointFiles(value);
            }

            saveWaypointsToStorage();
            renderWaypointMarkers();
            activeWaypointInlineEditor = null;
            setWaypointListExpanded(false);
            updateWaypointList();
        }
        
        // Edit waypoint files
        function editWaypointFiles(id) {
            const wp = waypoints.find(w => w.id === id);
            if (!wp) return;

            openWaypointInlineEditor(id, 'files');
        }
        
        // Delete waypoint by id
        function deleteWaypoint(id) {
            waypoints = waypoints.filter(wp => wp.id !== id);
            saveWaypointsToStorage();
            renderWaypointMarkers();
            updateWaypointList();
        }
        
        // Edit waypoint name
        function editWaypoint(id) {
            const wp = waypoints.find(w => w.id === id);
            if (!wp) return;
            
            const newName = prompt('Enter waypoint name:', wp.name);
            if (newName !== null && newName.trim()) {
                wp.name = sanitizeWaypointName(newName);
                saveWaypointsToStorage();
                renderWaypointMarkers();
                updateWaypointList();
            }
        }
        
        // Edit waypoint notes
        function editWaypointNotes(id) {
            const wp = waypoints.find(w => w.id === id);
            if (!wp) return;

            openWaypointInlineEditor(id, 'notes');
        }
        
        // Toggle waypoint expand/collapse
        function toggleWaypointExpand(id) {
            const actionsDiv = document.getElementById(`waypoint-actions-${id}`);
            const arrow = document.getElementById(`waypoint-arrow-${id}`);
            if (!actionsDiv || !arrow) return;
            
            const isExpanded = actionsDiv.style.display !== 'none';
            actionsDiv.style.display = isExpanded ? 'none' : 'block';
            arrow.textContent = isExpanded ? '▶' : '▼';
        }
        
        // Show waypoint on map when clicked from list
        function showWaypointOnMap(id) {
            const wp = waypoints.find(w => w.id === id);
            if (!wp) return;
            
            // Pan to waypoint location
            map.setView([wp.lat, wp.lon], Math.max(map.getZoom(), 15));
            
            // Find and open the marker popup
            const markerIndex = waypoints.findIndex(w => w.id === id);
            if (markerIndex >= 0 && waypointMarkers[markerIndex]) {
                waypointMarkers[markerIndex].openPopup();
            }
        }
        
        // Clear all waypoints
        function clearAllWaypoints() {
            if (!waypoints.length) return;
            if (!confirm(`Delete all ${waypoints.length} waypoint(s)?`)) return;
            
            waypoints = [];
            saveWaypointsToStorage();
            renderWaypointMarkers();
            updateWaypointList();
        }
        
        // Render waypoint markers on map
        function renderWaypointMarkers() {
            // Clear existing markers
            waypointMarkers.forEach(marker => map.removeLayer(marker));
            waypointMarkers = [];
            
            // Add new markers
            waypoints.forEach(wp => {
                const safeName = escapeHtml(wp.name);
                const safeNotes = escapeHtml(wp.notes);
                const marker = L.marker([wp.lat, wp.lon], {
                    icon: L.divIcon({
                        className: 'waypoint-marker',
                        html: `<div style="background:#ffd93d;width:12px;height:12px;border-radius:50%;border:2px solid #fff;box-shadow:0 2px 4px rgba(0,0,0,0.3);"></div>`,
                        iconSize: [16, 16],
                        iconAnchor: [8, 8]
                    })
                }).addTo(map);
                
                const notesHtml = wp.notes ? `<div style="margin-top:4px;padding:4px;background:#1a1a2e;border-radius:3px;font-size:0.85em;color:#aaa;max-width:200px;word-wrap:break-word;white-space:pre-wrap;">${safeNotes}</div>` : '';
                const filesCount = (wp.files || []).length;
                const filesHtml = filesCount > 0 ? `<div style="margin-top:4px;font-size:0.8em;color:#666;">📎 ${filesCount} file${filesCount > 1 ? 's' : ''} attached</div>` : '';
                marker.bindPopup(`
                    <div style="font-family:system-ui,sans-serif;">
                        <strong>${safeName}</strong><br>
                        <small>${wp.lat.toFixed(5)}, ${wp.lon.toFixed(5)}</small>
                        ${notesHtml}
                        ${filesHtml}
                        <div style="margin-top:6px;display:flex;gap:4px;flex-wrap:wrap;">
                            <button onclick="editWaypoint(${wp.id})" style="padding:2px 6px;font-size:0.8em;">Rename</button>
                            <button onclick="editWaypointNotes(${wp.id})" style="padding:2px 6px;font-size:0.8em;">Notes</button>
                            <button onclick="editWaypointFiles(${wp.id})" style="padding:2px 6px;font-size:0.8em;">Files</button>
                            <button onclick="if(confirm('Delete this waypoint?'))deleteWaypoint(${wp.id})" style="padding:2px 6px;font-size:0.8em;">Delete</button>
                        </div>
                    </div>
                `);
                
                waypointMarkers.push(marker);
            });
        }
        
        // Update waypoint list in sidebar
        function updateWaypointList() {
            const listEl = document.getElementById('waypointList');
            const countEl = document.getElementById('countWaypoints');
            
            countEl.textContent = `(${waypoints.length})`;
            
            if (waypoints.length === 0) {
                listEl.innerHTML = '<p style="color:#666;font-size:0.85em;text-align:center;padding:10px 0;">No waypoints yet</p>';
                return;
            }
            
            let html = '';
            waypoints.forEach(wp => {
                const safeName = escapeHtml(wp.name);
                const filesCount = (wp.files || []).length;
                const badges = [];
                if (wp.notes) badges.push('📝');
                if (filesCount > 0) badges.push(`📎${filesCount}`);
                const badgeHtml = badges.length > 0 ? `<span style="color:#666;font-size:0.8em;margin-left:6px;">${badges.join(' ')}</span>` : '';
                
                html += `
                    <div id="waypoint-card-${wp.id}" style="background:#16213e;border-radius:4px;margin-bottom:4px;overflow:hidden;">
                        <div style="display:flex;align-items:center;padding:8px 10px;cursor:pointer;" onclick="toggleWaypointExpand(${wp.id})">
                            <span style="color:#4cc9f0;margin-right:8px;">📍</span>
                            <span style="flex:1;color:#eee;font-size:0.85em;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${safeName}</span>
                            ${badgeHtml}
                            <span id="waypoint-arrow-${wp.id}" style="color:#666;font-size:0.7em;margin-left:8px;">▶</span>
                        </div>
                        <div id="waypoint-actions-${wp.id}" style="display:none;padding:0 10px 10px 10px;border-top:1px solid #333;">
                            <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:8px;">
                                <button onclick="event.stopPropagation();showWaypointOnMap(${wp.id})" style="padding:5px 12px;font-size:0.75em;background:#2a2a4e;color:#ccc;border:none;border-radius:3px;cursor:pointer;">Show on Map</button>
                                <button onclick="event.stopPropagation();editWaypoint(${wp.id})" style="padding:5px 12px;font-size:0.75em;background:#2a2a4e;color:#ccc;border:none;border-radius:3px;cursor:pointer;">Rename</button>
                                <button onclick="event.stopPropagation();editWaypointNotes(${wp.id})" style="padding:5px 12px;font-size:0.75em;background:#2a2a4e;color:#ccc;border:none;border-radius:3px;cursor:pointer;">Notes</button>
                                <button onclick="event.stopPropagation();editWaypointFiles(${wp.id})" style="padding:5px 12px;font-size:0.75em;background:#2a2a4e;color:#ccc;border:none;border-radius:3px;cursor:pointer;">Files</button>
                                <button onclick="event.stopPropagation();if(confirm('Delete this waypoint?'))deleteWaypoint(${wp.id})" style="padding:5px 12px;font-size:0.75em;background:#2a2a4e;color:#ccc;border:none;border-radius:3px;cursor:pointer;">Delete</button>
                            </div>
                            <div id="waypoint-inline-editor-${wp.id}" style="display:none;margin-top:10px;padding:8px;background:#1a1a2e;border:1px solid #333;border-radius:4px;">
                                <div id="waypoint-inline-editor-title-${wp.id}" style="color:#aaa;font-size:0.75em;margin-bottom:6px;"></div>
                                <textarea id="waypoint-inline-editor-textarea-${wp.id}" style="width:100%;min-height:70px;max-height:180px;background:#16213e;border:1px solid #333;border-radius:4px;color:#eee;padding:8px;font-family:inherit;font-size:0.85em;resize:vertical;"></textarea>
                                <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px;">
                                    <button onclick="event.stopPropagation();cancelWaypointInlineEditor(${wp.id})" style="padding:5px 12px;font-size:0.75em;background:#2a2a4e;color:#ccc;border:none;border-radius:3px;cursor:pointer;">Cancel</button>
                                    <button onclick="event.stopPropagation();saveWaypointInlineEditor(${wp.id})" style="padding:5px 12px;font-size:0.75em;background:#4cc9f0;color:#111;border:none;border-radius:3px;cursor:pointer;">Save</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            listEl.innerHTML = html;
        }
        
        // Export waypoints to JSON file
        function exportWaypoints() {
            if (waypoints.length === 0) {
                alert('No waypoints to export');
                return;
            }
            
            const data = {
                waypoints: waypoints.map(wp => ({
                    name: wp.name,
                    lat: wp.lat,
                    lon: wp.lon,
                    notes: wp.notes || '',
                    files: wp.files || []  // Include attached files
                })),
                exportedAt: new Date().toISOString(),
                version: 2  // Bump version for files support
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });

            // Match device naming scheme for Organize Maps: waypoints_<mapname>.hwmap.json
            // Prefer the actual generated/downloaded map name, fall back to the region name input.
            let mapFileName = (window.hwmapFilename || '').trim();
            if (!mapFileName) {
                const regionName = (document.getElementById('regionName')?.value || 'map').trim();
                mapFileName = regionName.toLowerCase().replace(/[^a-z0-9]/g, '_') + '.hwmap';
            }
            // Sanitize to a safe filename (no path separators/control chars)
            mapFileName = mapFileName
                .replace(/[\u0000-\u001F\u007F]/g, '')
                .replace(/[\\/]/g, '_')
                .replace(/\s+/g, '_');
            if (!mapFileName.toLowerCase().endsWith('.hwmap')) {
                mapFileName += '.hwmap';
            }

            const filename = `waypoints_${mapFileName}.json`;
            downloadBlob(blob, filename);
        }
        
        // Import waypoints from JSON file
        function importWaypoints() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(evt) {
                    try {
                        const data = JSON.parse(evt.target.result);
                        if (!data.waypoints || !Array.isArray(data.waypoints)) {
                            alert('Invalid waypoint file format');
                            return;
                        }
                        
                        const importCount = data.waypoints.length;
                        if (!confirm(`Import ${importCount} waypoint(s)? This will add to existing waypoints.`)) {
                            return;
                        }
                        
                        data.waypoints.forEach(wp => {
                            const s = sanitizeWaypoint(wp, waypointIdCounter);
                            if (!s) return;
                            addWaypoint(s.lat, s.lon, s.name || 'Imported', s.notes || '', s.files || []);
                        });
                        
                        alert(`Successfully imported ${importCount} waypoint(s)`);
                    } catch (err) {
                        alert('Failed to parse waypoint file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // Map click handler for adding waypoints
        map.on('click', function(e) {
            if (waypointAddMode) {
                const name = prompt('Enter waypoint name:', `WP${waypoints.length + 1}`);
                if (name !== null) {
                    addWaypoint(e.latlng.lat, e.latlng.lng, name || `WP${waypoints.length + 1}`);
                }
            }
        });
        
        // Load waypoints on startup
        loadWaypointsFromStorage();
        
        // Handle drawing events
        map.on(L.Draw.Event.CREATED, function(e) {
            try {
                drawnItems.clearLayers();
                previewLayer.clearLayers();
                drawnItems.addLayer(e.layer);
                selectedBounds = e.layer.getBounds();
                // Reset preview button when new selection is drawn (cached data is stale)
                const previewBtn = document.getElementById('previewBtn');
                if (previewBtn) {
                    previewBtn.textContent = '👁️ Preview Selection';
                    previewBtn.onclick = previewMap;
                }
                window.hwmapBlob = null;
                window.hwmapFilename = null;
                
                // Store polygon coordinates if it's a polygon or circle
                if (e.layerType === 'polygon') {
                    const latLngs = e.layer.getLatLngs();
                    // Handle nested array structure - can be [latlngs] or [[latlngs]]
                    const coords = Array.isArray(latLngs[0]) && latLngs[0][0] && latLngs[0][0].lat !== undefined 
                        ? latLngs[0] 
                        : latLngs;
                    selectedPolygon = coords.map(ll => [ll.lat, ll.lng]);
                } else if (e.layerType === 'circle') {
                    // Convert circle to polygon (64 points for smooth approximation)
                    const center = e.layer.getLatLng();
                    const radius = e.layer.getRadius();  // meters
                    // Pick segment count based on screen-space radius to avoid a faceted clip edge.
                    // Clamp to keep performance reasonable.
                    let numPoints = 64;
                    try {
                        const lonOffset = (radius / (111320 * Math.cos(center.lat * Math.PI / 180)));
                        const edge = L.latLng(center.lat, center.lng + lonOffset);
                        const cp = map.latLngToContainerPoint(center);
                        const ep = map.latLngToContainerPoint(edge);
                        const rPx = Math.hypot(ep.x - cp.x, ep.y - cp.y);
                        const desiredSegPx = 4;
                        numPoints = Math.max(64, Math.min(512, Math.ceil((2 * Math.PI * rPx) / desiredSegPx)));
                    } catch (err) {
                        numPoints = 128;
                    }
                    const circlePoints = [];
                    
                    for (let i = 0; i < numPoints; i++) {
                        const angle = (i / numPoints) * 2 * Math.PI;
                        // Approximate meters to degrees (rough: 111320 m per degree lat)
                        const latOffset = (radius / 111320) * Math.cos(angle);
                        const lonOffset = (radius / (111320 * Math.cos(center.lat * Math.PI / 180))) * Math.sin(angle);
                        circlePoints.push([center.lat + latOffset, center.lng + lonOffset]);
                    }
                    selectedPolygon = circlePoints;
                } else {
                    selectedPolygon = null;
                }
                
                // Disable drawing tools after selection is made
                map.removeControl(drawControl);
                
                updateStats();
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('previewBtn').disabled = false;
                document.getElementById('mapControls').style.display = 'flex';
                setStatus('ready', 'Ready to preview or generate');
            } catch (err) {
                console.error('Error in draw created handler:', err);
                setStatus('error', 'Error processing selection: ' + err.message);
            }
        });
        
        map.on(L.Draw.Event.DELETED, function(e) {
            selectedBounds = null;
            selectedPolygon = null;
            previewLayer.clearLayers();
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('previewBtn').disabled = true;
            document.getElementById('mapControls').style.display = 'none';
            setStatus('ready', 'Draw a shape on the map to select area');
            clearStats();
        });
        
        // =============================================================================
        // UI FUNCTIONS
        // =============================================================================
        
        function toggleSection(titleEl) {
            titleEl.classList.toggle('collapsed');
            const content = titleEl.nextElementSibling;
            if (content && content.classList.contains('section-content')) {
                content.classList.toggle('collapsed');
            }
        }
        
        // Collapse all expandable sections in sidebar
        function collapseAllSections() {
            const sections = ['allfeatures', 'highways', 'roads', 'paths', 'water', 'nature', 'infrastructure', 'postprocessing'];
            sections.forEach(section => {
                const title = document.querySelector(`.section-title[data-section="${section}"]`);
                if (title && !title.classList.contains('collapsed')) {
                    title.classList.add('collapsed');
                    const content = title.nextElementSibling;
                    if (content && content.classList.contains('section-content')) {
                        content.classList.add('collapsed');
                    }
                }
            });
        }
        
        const AUTO_PREVIEW_DEBOUNCE_MS = 5000;
        let autoPreviewTimeout = null;
        let autoPreviewEnabled = false;
        
        function handleAutoPreviewToggle() {
            autoPreviewEnabled = document.getElementById('autoPreview').checked;
            if (!autoPreviewEnabled && autoPreviewTimeout) {
                clearTimeout(autoPreviewTimeout);
                autoPreviewTimeout = null;
            }
            if (autoPreviewEnabled && selectedBounds) {
                triggerAutoPreview();
            }
        }
        
        function triggerAutoPreview() {
            if (!autoPreviewEnabled || !selectedBounds) return;
            
            // Debounce - wait for changes to settle before contacting the API
            if (autoPreviewTimeout) {
                clearTimeout(autoPreviewTimeout);
            }
            autoPreviewTimeout = setTimeout(() => {
                previewMap();
            }, AUTO_PREVIEW_DEBOUNCE_MS);
        }
        
        function updateSimplifySliders() {
            // Simple helper to update a simplification option
            function updateOption(simplifyId, labelId, featureIds, sliderId, sliderInputId) {
                const checkbox = document.getElementById(simplifyId);
                const label = document.getElementById(labelId);
                if (!checkbox || !label) return;
                
                // Check if any related feature is checked
                let enabled = false;
                for (const fid of featureIds) {
                    const fel = document.getElementById(fid);
                    if (fel && fel.checked) {
                        enabled = true;
                        break;
                    }
                }
                
                // Update checkbox and label
                checkbox.disabled = !enabled;
                label.style.opacity = enabled ? '1' : '0.4';
                label.style.cursor = enabled ? 'pointer' : 'not-allowed';
                
                if (!enabled) {
                    checkbox.checked = false;
                }
                
                // Update slider if present - show/hide based on checkbox state
                if (sliderId && sliderInputId) {
                    const container = document.getElementById(sliderId);
                    const input = document.getElementById(sliderInputId);
                    if (container && input) {
                        const sliderOn = enabled && checkbox.checked;
                        // Show slider when checkbox is checked, hide when unchecked
                        container.style.display = sliderOn ? 'block' : 'none';
                        container.style.opacity = sliderOn ? '1' : '0.4';
                        input.disabled = !sliderOn;
                    }
                }
            }
            
            // Update each simplification option
            // Buildings
            updateOption('simplifyBuildings', 'simplifyBuildingsLabel', ['buildings', 'buildingsLargeOnly']);
            
            // Highways
            updateOption('simplifyMotorways', 'simplifyMotorwaysLabel', ['motorways'], 'motorwaysSimplifyContainer', 'motorwaysSimplifyPoints');
            updateOption('simplifyTrunk', 'simplifyTrunkLabel', ['trunkRoads'], 'trunkSimplifyContainer', 'trunkSimplifyPoints');
            
            // Roads
            updateOption('simplifyPrimary', 'simplifyPrimaryLabel', ['primaryRoads'], 'primarySimplifyContainer', 'primarySimplifyPoints');
            updateOption('simplifySecondary', 'simplifySecondaryLabel', ['secondaryRoads'], 'secondarySimplifyContainer', 'secondarySimplifyPoints');
            updateOption('simplifyTertiary', 'simplifyTertiaryLabel', ['tertiaryRoads'], 'tertiarySimplifyContainer', 'tertiarySimplifyPoints');
            updateOption('simplifyResidential', 'simplifyResidentialLabel', ['residentialRoads'], 'residentialSimplifyContainer', 'residentialSimplifyPoints');
            updateOption('simplifyService', 'simplifyServiceLabel', ['serviceRoads'], 'serviceSimplifyContainer', 'serviceSimplifyPoints');
            
            // Water & Nature
            updateOption('simplifyWater', 'simplifyWaterLabel', ['waterBodies', 'waterways', 'coastlines'], 'waterSimplifyContainer', 'waterSimplifyPoints');
            updateOption('simplifyParks', 'simplifyParksLabel', ['parks', 'grassland'], 'parksSimplifyContainer', 'parksSimplifyPoints');
            updateOption('simplifyForests', 'simplifyForestsLabel', ['forests'], 'forestsSimplifyContainer', 'forestsSimplifyPoints');
            
            // Paths & Transit
            updateOption('simplifyPaths', 'simplifyPathsLabel', ['footways', 'cycleways', 'tracks'], 'pathsSimplifyContainer', 'pathsSimplifyPoints');
            updateOption('simplifyBus', 'simplifyBusLabel', ['busRoutes'], 'busSimplifyContainer', 'busSimplifyPoints');
            updateOption('simplifyRail', 'simplifyRailLabel', ['railways', 'subways'], 'railSimplifyContainer', 'railSimplifyPoints');
            updateOption('simplifyFerry', 'simplifyFerryLabel', ['ferryRoutes'], 'ferrySimplifyContainer', 'ferrySimplifyPoints');
            
            // Infrastructure
            updateOption('simplifyStations', 'simplifyStationsLabel', ['transitStations'], 'stationsSimplifyContainer', 'stationsSimplifyPoints');
            updateOption('simplifyBridges', 'simplifyBridgesLabel', ['bridges'], 'bridgesSimplifyContainer', 'bridgesSimplifyPoints');
            updateOption('simplifyIndustrial', 'simplifyIndustrialLabel', ['industrial'], 'industrialSimplifyContainer', 'industrialSimplifyPoints');
            updateOption('simplifyCommercial', 'simplifyCommercialLabel', ['commercial'], 'commercialSimplifyContainer', 'commercialSimplifyPoints');
            updateOption('simplifyResidentialArea', 'simplifyResidentialAreaLabel', ['residential'], 'residentialAreaSimplifyContainer', 'residentialAreaSimplifyPoints');
        }
        
        function updateBuildingSubOptions() {
            const buildingsChecked = document.getElementById('buildings')?.checked;
            
            // Only Large only and Include names are building sub-options
            const subOptions = [
                { label: 'buildingsLargeOnlyLabel', checkbox: 'buildingsLargeOnly' },
                { label: 'buildingNamesLabel', checkbox: 'buildingNames' }
            ];
            
            for (const opt of subOptions) {
                const label = document.getElementById(opt.label);
                const checkbox = document.getElementById(opt.checkbox);
                if (label && checkbox) {
                    checkbox.disabled = !buildingsChecked;
                    label.style.opacity = buildingsChecked ? '1' : '0.4';
                    label.style.cursor = buildingsChecked ? 'pointer' : 'not-allowed';
                    if (!buildingsChecked) checkbox.checked = false;
                }
            }
            // Also update large building sliders visibility
            updateLargeBuildingSliders();
        }
        
        function updateLargeBuildingSliders() {
            const largeOnlyChecked = document.getElementById('buildingsLargeOnly')?.checked;
            const settingsDiv = document.getElementById('largeBuildingSettings');
            if (settingsDiv) {
                settingsDiv.style.display = largeOnlyChecked ? 'block' : 'none';
            }
        }
        
        function updateBuildingMinAreaLabel() {
            const value = document.getElementById('buildingMinArea')?.value || 200;
            const label = document.getElementById('buildingMinAreaValue');
            if (label) label.textContent = value + 'm²';
        }
        
        function updateBuildingMinFloorsLabel() {
            const value = document.getElementById('buildingMinFloors')?.value || 3;
            const label = document.getElementById('buildingMinFloorsValue');
            if (label) label.textContent = value + '+';
        }
        
        function updateBusSubOptions() {
            const busChecked = document.getElementById('busRoutes')?.checked;
            const simplifyLabel = document.getElementById('busRoutesSimplifyLabel');
            const simplifyCheckbox = document.getElementById('busRoutesSimplify');
            
            if (simplifyLabel && simplifyCheckbox) {
                simplifyCheckbox.disabled = !busChecked;
                simplifyLabel.style.opacity = busChecked ? '1' : '0.4';
                simplifyLabel.style.cursor = busChecked ? 'pointer' : 'not-allowed';
            }
        }
        
        function updateCoastlineSubOptions() {
            const coastlinesChecked = document.getElementById('coastlines')?.checked;
            const landMaskLabel = document.getElementById('landMaskLabel');
            const landMaskCheckbox = document.getElementById('landMask');
            
            if (landMaskLabel && landMaskCheckbox) {
                landMaskCheckbox.disabled = !coastlinesChecked;
                landMaskLabel.style.opacity = coastlinesChecked ? '1' : '0.4';
                landMaskLabel.style.cursor = coastlinesChecked ? 'pointer' : 'not-allowed';
                // Auto-check land mask when coastlines is enabled (default on)
                // Only uncheck when coastlines is disabled
                if (coastlinesChecked) {
                    landMaskCheckbox.checked = true;
                } else {
                    landMaskCheckbox.checked = false;
                }
            }
        }
        
        function updateSectionCounts() {
            // Only count main feature checkboxes, not sub-options
            const sections = {
                highways: ['motorways', 'trunkRoads'],
                roads: ['primaryRoads', 'secondaryRoads', 'tertiaryRoads', 'residentialRoads', 'serviceRoads'],
                paths: ['footways', 'cycleways', 'tracks'],
                water: ['waterBodies', 'waterways', 'coastlines'],
                nature: ['parks', 'forests', 'grassland'],
                infrastructure: ['railways', 'subways', 'busRoutes', 'ferryRoutes', 'transitStations', 'bridges', 'powerlines', 'buildings', 'industrial', 'commercial', 'residential']
            };
            
            for (const [section, ids] of Object.entries(sections)) {
                const checked = ids.filter(id => document.getElementById(id)?.checked).length;
                const total = ids.length;
                const el = document.getElementById('count' + section.charAt(0).toUpperCase() + section.slice(1));
                if (el) {
                    el.textContent = `(${checked}/${total})`;
                }
            }
            
            // Update all simplification options (unified system)
            updateSimplifySliders();
            
            // Also update stats when checkboxes change
            if (selectedBounds) {
                updateStats();
            }
            
            // Trigger auto-preview if enabled
            triggerAutoPreview();
        }
        
        function displayActualResults(result) {
            const { stats } = result;
            const formatVersion = stats.formatVersion || 5;
            
            // Show the results panel
            document.getElementById('actualResults').style.display = 'block';
            
            // Format file size
            let sizeText;
            if (stats.fileSize >= 1024 * 1024) {
                sizeText = (stats.fileSize / (1024 * 1024)).toFixed(2) + ' MB';
            } else {
                sizeText = (stats.fileSize / 1024).toFixed(1) + ' KB';
            }
            
            // Update all fields
            document.getElementById('actualFileSize').textContent = sizeText;
            document.getElementById('actualFeatureCount').textContent = stats.featureCount.toLocaleString();
            document.getElementById('actualNamedCount').textContent = stats.namedCount.toLocaleString();
            document.getElementById('actualNameCount').textContent = stats.nameCount.toLocaleString();
            document.getElementById('actualPointCount').textContent = stats.totalPoints.toLocaleString();
            
            // Build type breakdown HTML with trimmed info
            let breakdownHtml = '';
            
            // Show trimming summary if features were trimmed
            if (typeof stats.totalBeforeTrim === 'number') {
                const trimmed = stats.totalBeforeTrim - stats.featureCount;
                if (trimmed > 0) {
                    const pct = Math.round((trimmed / stats.totalBeforeTrim) * 100);
                    breakdownHtml += `<div style="color:#ff6b6b;margin-bottom:8px;padding:4px 6px;background:rgba(255,107,107,0.15);border-radius:3px;font-size:0.9em;">⚠️ ${trimmed.toLocaleString()} features trimmed (${pct}% dropped due to limit)</div>`;
                }
            }
            
            if (stats.typeBreakdown) {
                // Sort by bytes descending
                const sorted = Object.entries(stats.typeBreakdown).sort((a, b) => b[1].bytes - a[1].bytes);
                for (const [typeName, data] of sorted) {
                    const kb = (data.bytes / 1024).toFixed(1);
                    const color = data.bytes > 50000 ? '#ff6b6b' : data.bytes > 20000 ? '#ffd93d' : '#69db7c';
                    // Show original count if trimmed
                    const preTrim = stats.preTrimCounts?.[typeName] || data.count;
                    const dropped = preTrim - data.count;
                    let countText = data.count.toLocaleString();
                    if (dropped > 0) {
                        countText = `${data.count.toLocaleString()} <span style="color:#ff6b6b;font-size:0.85em;">(-${dropped.toLocaleString()})</span>`;
                    }
                    breakdownHtml += `<div style="display:flex;justify-content:space-between;"><span>${typeName} <span style="color:#666;">(${countText})</span></span><span style="color:${color}">${kb} KB</span></div>`;
                }
                
                // Show types that were completely trimmed
                if (stats.preTrimCounts) {
                    for (const [typeName, count] of Object.entries(stats.preTrimCounts)) {
                        if (!stats.typeBreakdown[typeName] && count > 0) {
                            breakdownHtml += `<div style="display:flex;justify-content:space-between;color:#666;"><span>${typeName} <span style="color:#ff6b6b;">(0 <span style="font-size:0.85em;">-${count.toLocaleString()}</span>)</span></span><span>0 KB</span></div>`;
                        }
                    }
                }
                
                // Add spatial index or tile directory
                if (stats.spatialIndexSize > 0) {
                    const idxKb = (stats.spatialIndexSize / 1024).toFixed(1);
                    breakdownHtml += `<div style="display:flex;justify-content:space-between;margin-top:4px;border-top:1px solid #333;padding-top:4px;"><span style="color:#4cc9f0;">Spatial Index (${stats.gridSize}×${stats.gridSize})</span><span style="color:#4cc9f0;">${idxKb} KB</span></div>`;
                } else if (stats.tileDirectorySize > 0) {
                    const dirKb = (stats.tileDirectorySize / 1024).toFixed(1);
                    const tgs = stats.tileGridSize || 0;
                    breakdownHtml += `<div style="display:flex;justify-content:space-between;margin-top:4px;border-top:1px solid #333;padding-top:4px;"><span style="color:#4cc9f0;">Tile Directory (${tgs}×${tgs})</span><span style="color:#4cc9f0;">${dirKb} KB</span></div>`;
                }
                
                // Add name table
                if (stats.nameTableSize > 0) {
                    const nameKb = (stats.nameTableSize / 1024).toFixed(1);
                    breakdownHtml += `<div style="display:flex;justify-content:space-between;"><span style="color:#b197fc;">Name Table</span><span style="color:#b197fc;">${nameKb} KB</span></div>`;
                }
            }
            document.getElementById('actualBreakdown').innerHTML = breakdownHtml;
        }
        
        function clearSelection() {
            drawnItems.clearLayers();
            previewLayer.clearLayers();
            selectedBounds = null;
            selectedPolygon = null;
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('previewBtn').disabled = true;
            // Reset preview button to preview mode and clear cached blob
            const previewBtn = document.getElementById('previewBtn');
            if (previewBtn) {
                previewBtn.textContent = '👁️ Preview Selection';
                previewBtn.onclick = previewMap;
            }
            window.hwmapBlob = null;
            window.hwmapFilename = null;
            document.getElementById('mapControls').style.display = 'none';
            document.getElementById('actualResults').style.display = 'none';
            
            // Re-enable drawing tools
            map.addControl(drawControl);
            
            // Re-inject waypoint button into draw toolbar
            setTimeout(() => {
                const drawToolbar = document.querySelector('.leaflet-draw-toolbar');
                if (drawToolbar && !document.getElementById('waypointModeBtn')) {
                    const waypointBtn = document.createElement('a');
                    waypointBtn.id = 'waypointModeBtn';
                    waypointBtn.className = 'leaflet-draw-draw-waypoint';
                    waypointBtn.href = '#';
                    waypointBtn.title = 'Add Waypoint';
                    waypointBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="display:block;"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>`;
                    waypointBtn.onclick = (e) => { e.preventDefault(); toggleWaypointModeFromMap(); };
                    drawToolbar.appendChild(waypointBtn);
                }
            }, 0);
            
            setStatus('ready', 'Draw a shape on the map to select area');
            clearStats();
        }
        
        function useMyLocation() {
            if (!navigator.geolocation) {
                setStatus('error', 'Geolocation not supported');
                return;
            }
            
            setStatus('working', 'Getting location...');
            
            const options = {
                enableHighAccuracy: false,  // false is faster and works better on desktop
                timeout: 10000,             // 10 second timeout
                maximumAge: 300000          // Accept cached position up to 5 min old
            };
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    map.setView([lat, lon], 14);
                    setStatus('ready', 'Centered on your location');
                },
                (error) => {
                    let msg = 'Could not get location';
                    if (error.code === 1) {
                        msg = 'Location access denied. Check browser settings.';
                    } else if (error.code === 2) {
                        msg = 'Location unavailable. Try again.';
                    } else if (error.code === 3) {
                        msg = 'Location request timed out. Try again.';
                    }
                    setStatus('error', msg);
                },
                options
            );
        }
        
        function setStatus(type, message) {
            const status = document.getElementById('status');
            status.className = 'status ' + type;
            status.textContent = message;
        }
        
        function setProgress(percent) {
            const bar = document.getElementById('progressBar');
            const fill = document.getElementById('progressFill');
            bar.classList.add('active');
            fill.style.width = percent + '%';
        }
        
        function hideProgress() {
            document.getElementById('progressBar').classList.remove('active');
        }
        
        function updatePathLengthSlider() {
            // Path min length filter is always available (independent of simplification)
            const container = document.getElementById('pathLengthSliderContainer');
            if (container) {
                container.style.opacity = '1';
            }
        }
        
        function updatePathLengthValue() {
            const value = parseInt(document.getElementById('pathMinLength').value);
            const label = document.getElementById('pathLengthValue');
            if (value === 0) {
                label.textContent = '0m (all)';
            } else {
                label.textContent = value + 'm';
            }
            // Update size estimate when path min length changes
            updateStats();
        }
        
        function updateTransitSimplifyValue(type) {
            const slider = document.getElementById(type + 'SimplifyPoints');
            const label = document.getElementById(type + 'SimplifyValue');
            if (slider && label) {
                label.textContent = slider.value + ' pts';
            }
        }
        
        function updateRoadSimplifyValue(type) {
            const slider = document.getElementById(type + 'SimplifyPoints');
            const label = document.getElementById(type + 'SimplifyValue');
            if (slider && label) {
                label.textContent = slider.value + ' pts';
            }
            // Update size estimate in real-time as slider moves
            updateStats();
        }
        
        function updateStats() {
            if (!selectedBounds) return;
            
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            
            // Calculate area in km
            const widthKm = haversineDistance(sw.lat, sw.lng, sw.lat, ne.lng);
            const heightKm = haversineDistance(sw.lat, sw.lng, ne.lat, sw.lng);
            
            document.getElementById('areaSize').textContent = 
                widthKm.toFixed(1) + ' × ' + heightKm.toFixed(1) + ' km';
            
            const areaKm2 = widthKm * heightKm;
            const formatSize = (kb) => kb >= 1024 ? (kb / 1024).toFixed(1) + ' MB' : kb + ' KB';
            
            // Use actual preview data if available, otherwise estimate
            let estResult;
            if (window.previewData && window.previewData.elements) {
                // Count actual features from preview data by type
                const actualCounts = countPreviewFeaturesByType();
                estResult = estimateSizeFromActual(actualCounts);
            } else {
                // Fall back to density-based estimation
                estResult = estimateSize(areaKm2);
            }
            
            const estKB = estResult.capped || estResult;
            document.getElementById('estSize').textContent = formatSize(estKB);
            
            // Update size warning
            updateSizeWarning(estKB);
            
            // Feature count - show actual if from preview, estimate if not
            if (window.previewData && window.previewData.elements) {
                const actualCounts = countPreviewFeaturesByType();
                document.getElementById('featureCount').textContent = actualCounts.total.toLocaleString();
            } else {
                const estCount = Math.round(areaKm2 * 50);
                document.getElementById('featureCount').textContent = '~' + estCount.toLocaleString();
            }
        }
        
        // Count features by type from preview data
        function countPreviewFeaturesByType() {
            const counts = {
                highway: 0,      // motorway, trunk
                major: 0,        // primary, secondary
                minor: 0,        // tertiary, residential, service
                path: 0,         // footway, cycleway
                water: 0,
                park: 0,
                railway: 0,
                bus: 0,
                ferry: 0,
                building: 0,
                station: 0,
                other: 0,
                total: 0
            };
            
            if (!window.previewData || !window.previewData.elements) return counts;
            
            for (const el of window.previewData.elements) {
                if (el.type !== 'way' || !el.tags) continue;
                counts.total++;
                
                const tags = el.tags;
                if (tags.highway) {
                    if (['motorway', 'motorway_link', 'trunk', 'trunk_link'].includes(tags.highway)) {
                        counts.highway++;
                    } else if (['primary', 'secondary', 'primary_link', 'secondary_link'].includes(tags.highway)) {
                        counts.major++;
                    } else if (['tertiary', 'tertiary_link', 'residential', 'unclassified', 'service', 'living_street'].includes(tags.highway)) {
                        counts.minor++;
                    } else if (['footway', 'path', 'cycleway', 'track', 'pedestrian', 'steps'].includes(tags.highway)) {
                        counts.path++;
                    } else {
                        counts.other++;
                    }
                } else if (tags.railway) {
                    if (['station', 'halt'].includes(tags.railway)) {
                        counts.station++;
                    } else {
                        counts.railway++;
                    }
                } else if (tags.route === 'bus' || tags.route === 'trolleybus') {
                    counts.bus++;
                } else if (tags.route === 'ferry') {
                    counts.ferry++;
                } else if (tags.natural === 'water' || tags.waterway) {
                    counts.water++;
                } else if (tags.leisure === 'park' || tags.landuse === 'grass' || tags.landuse === 'forest' || tags.natural === 'wood') {
                    counts.park++;
                } else if (tags.building) {
                    counts.building++;
                } else if (tags.amenity === 'bus_station' || tags.amenity === 'ferry_terminal') {
                    counts.station++;
                } else {
                    counts.other++;
                }
            }
            
            return counts;
        }
        
        // Estimate size from actual feature counts
        function estimateSizeFromActual(counts) {
            const nameDetailLevel = parseInt(document.getElementById('nameDetail').value);
            
            // Avg points per feature (estimate based on typical features)
            const avgPts = 8;
            const bytesPerFeature = 12 + (avgPts - 1) * 4; // type + nameIdx + count + first point + deltas
            
            // Calculate total features that would be included based on checkboxes
            let totalFeatures = 0;
            let totalBytes = 0;
            
            // Map counts to checkbox IDs
            const featureMap = {
                highway: ['motorways', 'trunkRoads'],
                major: ['primaryRoads', 'secondaryRoads'],
                minor: ['tertiaryRoads', 'residentialRoads', 'serviceRoads'],
                path: ['footways', 'cycleways', 'tracks'],
                water: ['waterBodies', 'waterways', 'coastlines'],
                park: ['parks', 'forests', 'grassland'],
                railway: ['railways', 'subways'],
                bus: ['busRoutes'],
                ferry: ['ferryRoutes'],
                building: ['buildings'],
                station: ['transitStations']
            };
            
            for (const [countKey, checkboxIds] of Object.entries(featureMap)) {
                const count = counts[countKey] || 0;
                // Check if any of the related checkboxes are enabled
                const anyEnabled = checkboxIds.some(id => document.getElementById(id)?.checked);
                if (anyEnabled && count > 0) {
                    totalFeatures += count;
                    totalBytes += count * bytesPerFeature;
                }
            }
            
            // Add "other" features proportionally if any checkbox is checked
            const otherCount = counts.other || 0;
            if (otherCount > 0 && totalFeatures > 0) {
                totalFeatures += Math.round(otherCount * 0.5); // Assume 50% match
                totalBytes += Math.round(otherCount * 0.5 * bytesPerFeature);
            }
            
            // Calculate uncapped total
            const namePercent = [0, 0.05, 0.15, 0.40, 0.80][nameDetailLevel];
            const avgNameLen = 18;
            const uncappedNamedFeatures = Math.round(totalFeatures * namePercent);
            const uncappedUniqueNames = Math.round(uncappedNamedFeatures * 0.15);
            const uncappedNameTableBytes = uncappedUniqueNames * (avgNameLen + 1);
            const uncappedNameIndexBytes = totalFeatures * 2;
            const uncappedTotalBytes = totalBytes + uncappedNameTableBytes + uncappedNameIndexBytes + 40; // +header
            
            // Add name overhead
            const namedFeatures = Math.round(totalFeatures * namePercent);
            const uniqueNames = Math.round(namedFeatures * 0.15);
            const nameTableBytes = uniqueNames * (avgNameLen + 1);
            const nameIndexBytes = totalFeatures * 2;
            totalBytes += nameTableBytes + nameIndexBytes + 40; // +header
            
            // Add spatial index estimate (~2% overhead)
            totalBytes += Math.round(totalBytes * 0.02);
            
            return {
                capped: Math.round(totalBytes / 1024),
                uncapped: Math.round(uncappedTotalBytes / 1024)
            };
        }
        
        function clearStats() {
            document.getElementById('areaSize').textContent = '-- × -- km';
            document.getElementById('estSize').textContent = '-- KB';
            document.getElementById('featureCount').textContent = '--';
        }
        
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function estimateSize(areaKm2) {
            const nameDetailLevel = parseInt(document.getElementById('nameDetail').value);
            // Full detail mode - no global quality clamping
            const detailMultiplier = 2.0;
            
            // Name overhead percentages by level
            const namePercent = [0, 0.05, 0.15, 0.40, 0.80][nameDetailLevel];
            const avgNameLen = 18;
            
            // Binary format: 13 bytes base + (avgPts-1)*4 for deltas
            // Full detail - typical feature has ~8 points
            const avgPtsActual = 8;
            const bytesPerFeature = 13 + (avgPtsActual - 1) * 4;
            
            // Feature type density per km² (independent estimates) - calibrated to match actual output
            const featureDensity = {
                motorways: { density: 1, name: 'Motorways', simplifyCheckbox: 'simplifyMotorways' },
                trunkRoads: { density: 3, name: 'Trunk Roads', simplifyCheckbox: 'simplifyTrunk' },
                primaryRoads: { density: 8, name: 'Primary Roads', simplifyCheckbox: 'simplifyPrimary' },
                secondaryRoads: { density: 15, name: 'Secondary Roads', simplifyCheckbox: 'simplifySecondary' },
                tertiaryRoads: { density: 30, name: 'Tertiary Roads', simplifyCheckbox: 'simplifyTertiary' },
                serviceRoads: { density: 60, name: 'Service Roads', simplifyCheckbox: 'simplifyService' },
                footways: { density: 45, name: 'Footways', simplifyCheckbox: 'simplifyPaths' },
                cycleways: { density: 15, name: 'Cycleways', simplifyCheckbox: 'simplifyPaths' },
                tracks: { density: 25, name: 'Tracks', simplifyCheckbox: 'simplifyPaths' },
                waterBodies: { density: 6, name: 'Lakes/Ponds', simplifyCheckbox: 'simplifyWater' },
                waterways: { density: 10, name: 'Rivers', simplifyCheckbox: 'simplifyWater' },
                coastlines: { density: 3, name: 'Coastlines', simplifyCheckbox: 'simplifyWater' },
                parks: { density: 10, name: 'Parks', simplifyCheckbox: 'simplifyParks' },
                forests: { density: 6, name: 'Forests', simplifyCheckbox: 'simplifyForests' },
                grassland: { density: 6, name: 'Grassland', simplifyCheckbox: 'simplifyParks' },
                railways: { density: 6, name: 'Railways', simplifyCheckbox: 'simplifyRail' },
                subways: { density: 10, name: 'Subways', simplifyCheckbox: 'simplifyRail' },
                busRoutes: { density: 80, name: 'Bus Routes', simplifyCheckbox: 'simplifyBus' },
                ferryRoutes: { density: 2, name: 'Ferry Routes', simplifyCheckbox: 'simplifyFerry' },
                transitStations: { density: 3, name: 'Transit Stations', simplifyCheckbox: 'simplifyStations' },
                bridges: { density: 3, name: 'Bridges', simplifyCheckbox: 'simplifyBridges' },
                powerlines: { density: 10, name: 'Power Lines' },
                buildings: { density: 300, name: 'Buildings', simplifyCheckbox: 'simplifyBuildings' },
                buildingsLargeOnly: { density: 30, name: 'Buildings (Large)', simplifyCheckbox: 'simplifyBuildings' },
                residentialRoads: { density: 120, name: 'Residential', simplifyCheckbox: 'simplifyResidential' },
                industrial: { density: 6, name: 'Industrial', simplifyCheckbox: 'simplifyIndustrial' },
                commercial: { density: 6, name: 'Commercial', simplifyCheckbox: 'simplifyCommercial' },
                residential: { density: 6, name: 'Residential Areas', simplifyCheckbox: 'simplifyResidentialArea' }
            };
            
            // Calculate bytes for each feature type independently
            let breakdownHtml = '';
            let totalBytes = 0;
            let totalFeatures = 0;
            const simplifySavings = {
                simplifyBuildings: 0,
                simplifyMotorways: 0,
                simplifyTrunk: 0,
                simplifyPrimary: 0,
                simplifySecondary: 0,
                simplifyTertiary: 0,
                simplifyResidential: 0,
                simplifyService: 0,
                simplifyWater: 0,
                simplifyParks: 0,
                simplifyForests: 0,
                simplifyPaths: 0,
                simplifyBus: 0,
                simplifyRail: 0,
                simplifyFerry: 0,
                simplifyStations: 0,
                simplifyBridges: 0,
                simplifyIndustrial: 0,
                simplifyCommercial: 0,
                simplifyResidentialArea: 0
            };
            
            for (const [id, info] of Object.entries(featureDensity)) {
                const el = document.getElementById(id);
                const sizeEl = document.getElementById('size-' + id);
                
                // Special handling for buildings + Large only: they are mutually exclusive
                // When "Large only" is checked, it REPLACES the full buildings count
                if (id === 'buildings') {
                    const largeOnlyChecked = document.getElementById('buildingsLargeOnly')?.checked;
                    if (largeOnlyChecked) {
                        // Skip regular buildings - buildingsLargeOnly will handle it
                        if (sizeEl) sizeEl.textContent = '';
                        continue;
                    }
                }
                
                // Calculate feature count for this type based on area and density
                const featureCount = Math.round(areaKm2 * info.density * detailMultiplier);
                let featureBytes = featureCount * bytesPerFeature;
                
                // Track simplification savings (always calculate for display)
                if (info.simplifyCheckbox) {
                    const simplifyChecked = document.getElementById(info.simplifyCheckbox)?.checked;
                    const unsimplifiedBytes = featureBytes;
                    if (simplifyChecked) {
                        // Calculate reduction factor based on slider values where applicable
                        let reductionFactor = 0.5;
                        // Roads - get slider value and calculate reduction
                        if (info.simplifyCheckbox === 'simplifyMotorways') {
                            const pts = parseInt(document.getElementById('motorwaysSimplifyPoints')?.value || 15);
                            reductionFactor = Math.max(0.3, pts / 30);
                        } else if (info.simplifyCheckbox === 'simplifyTrunk') {
                            const pts = parseInt(document.getElementById('trunkSimplifyPoints')?.value || 12);
                            reductionFactor = Math.max(0.3, pts / 30);
                        } else if (info.simplifyCheckbox === 'simplifyPrimary') {
                            const pts = parseInt(document.getElementById('primarySimplifyPoints')?.value || 10);
                            reductionFactor = Math.max(0.2, pts / 30);
                        } else if (info.simplifyCheckbox === 'simplifySecondary') {
                            const pts = parseInt(document.getElementById('secondarySimplifyPoints')?.value || 8);
                            reductionFactor = Math.max(0.2, pts / 30);
                        } else if (info.simplifyCheckbox === 'simplifyTertiary') {
                            const pts = parseInt(document.getElementById('tertiarySimplifyPoints')?.value || 6);
                            reductionFactor = Math.max(0.15, pts / 30);
                        } else if (info.simplifyCheckbox === 'simplifyResidential') {
                            const pts = parseInt(document.getElementById('residentialSimplifyPoints')?.value || 4);
                            reductionFactor = Math.max(0.1, pts / 20);
                        } else if (info.simplifyCheckbox === 'simplifyService') {
                            const pts = parseInt(document.getElementById('serviceSimplifyPoints')?.value || 4);
                            reductionFactor = Math.max(0.1, pts / 20);
                        } else if (info.simplifyCheckbox === 'simplifyWater') {
                            const pts = parseInt(document.getElementById('waterSimplifyPoints')?.value || 8);
                            reductionFactor = Math.max(0.3, pts / 30);
                        } else if (info.simplifyCheckbox === 'simplifyParks') {
                            const pts = parseInt(document.getElementById('parksSimplifyPoints')?.value || 8);
                            reductionFactor = Math.max(0.3, pts / 30);
                        } else if (info.simplifyCheckbox === 'simplifyForests') {
                            const pts = parseInt(document.getElementById('forestsSimplifyPoints')?.value || 8);
                            reductionFactor = Math.max(0.3, pts / 20);
                        } else if (info.simplifyCheckbox === 'simplifyPaths') {
                            const pts = parseInt(document.getElementById('pathsSimplifyPoints')?.value || 6);
                            reductionFactor = Math.max(0.2, pts / 20);
                            
                            // Apply min length filtering reduction
                            const minLength = parseInt(document.getElementById('pathMinLength')?.value || 0);
                            if (minLength > 0) {
                                // Estimate that min length filtering removes 20-60% of paths depending on threshold
                                // 100m = ~20%, 200m = ~35%, 300m = ~50%, 400m = ~60%, 500m = ~70%
                                const lengthFilterFactor = Math.max(0.3, 1 - (minLength / 700));
                                reductionFactor *= lengthFilterFactor;
                            }
                        } else if (info.simplifyCheckbox === 'simplifyBus') {
                            const pts = parseInt(document.getElementById('busSimplifyPoints')?.value || 10);
                            reductionFactor = Math.max(0.2, pts / 30);
                        } else if (info.simplifyCheckbox === 'simplifyRail') {
                            const pts = parseInt(document.getElementById('railSimplifyPoints')?.value || 15);
                            reductionFactor = Math.max(0.3, pts / 30);
                        } else if (info.simplifyCheckbox === 'simplifyFerry') {
                            const pts = parseInt(document.getElementById('ferrySimplifyPoints')?.value || 8);
                            reductionFactor = Math.max(0.2, pts / 30);
                        }
                        featureBytes = Math.round(featureBytes * reductionFactor);
                    }
                    // Calculate potential savings for this feature type
                    if (el && el.checked) {
                        // Savings ratio based on slider - lower points = higher savings
                        let savingsRatio = 0.5; // default
                        const sliderMap = {
                            simplifyMotorways: { slider: 'motorwaysSimplifyPoints', def: 12, max: 30 },
                            simplifyTrunk: { slider: 'trunkSimplifyPoints', def: 12, max: 30 },
                            simplifyPrimary: { slider: 'primarySimplifyPoints', def: 12, max: 30 },
                            simplifySecondary: { slider: 'secondarySimplifyPoints', def: 12, max: 30 },
                            simplifyTertiary: { slider: 'tertiarySimplifyPoints', def: 12, max: 30 },
                            simplifyResidential: { slider: 'residentialSimplifyPoints', def: 12, max: 30 },
                            simplifyService: { slider: 'serviceSimplifyPoints', def: 12, max: 30 },
                            simplifyWater: { slider: 'waterSimplifyPoints', def: 12, max: 30 },
                            simplifyParks: { slider: 'parksSimplifyPoints', def: 12, max: 30 },
                            simplifyForests: { slider: 'forestsSimplifyPoints', def: 12, max: 30 },
                            simplifyPaths: { slider: 'pathsSimplifyPoints', def: 10, max: 30 },
                            simplifyBus: { slider: 'busSimplifyPoints', def: 12, max: 30 },
                            simplifyRail: { slider: 'railSimplifyPoints', def: 12, max: 30 },
                            simplifyFerry: { slider: 'ferrySimplifyPoints', def: 12, max: 30 },
                            simplifyStations: { slider: 'stationsSimplifyPoints', def: 12, max: 30 },
                            simplifyBridges: { slider: 'bridgesSimplifyPoints', def: 12, max: 30 },
                            simplifyIndustrial: { slider: 'industrialSimplifyPoints', def: 12, max: 30 },
                            simplifyCommercial: { slider: 'commercialSimplifyPoints', def: 12, max: 30 },
                            simplifyResidentialArea: { slider: 'residentialAreaSimplifyPoints', def: 12, max: 30 }
                        };
                        const sliderInfo = sliderMap[info.simplifyCheckbox];
                        if (sliderInfo) {
                            const pts = parseInt(document.getElementById(sliderInfo.slider)?.value || sliderInfo.def);
                            savingsRatio = Math.max(0.2, 1 - (pts / sliderInfo.max));
                        }
                        const potentialSavings = Math.round(unsimplifiedBytes * savingsRatio);
                        simplifySavings[info.simplifyCheckbox] = (simplifySavings[info.simplifyCheckbox] || 0) + potentialSavings;
                    }
                }
                
                const kb = Math.round(featureBytes / 1024);
                
                // Update inline size indicator (always, for all features)
                if (sizeEl && areaKm2 > 0) {
                    const sizeClass = kb > 50 ? 'large' : kb > 20 ? 'medium' : 'small';
                    sizeEl.textContent = kb > 0 ? `(${kb}KB)` : '';
                    sizeEl.className = 'feature-size ' + sizeClass;
                } else if (sizeEl) {
                    sizeEl.textContent = '';
                }
                
                // Add to total only if checked
                if (el && el.checked) {
                    totalBytes += featureBytes;
                    totalFeatures += featureCount;
                    
                    if (kb > 0) {
                        const color = kb > 50 ? '#ff6b6b' : kb > 20 ? '#ffd93d' : '#69db7c';
                        breakdownHtml += `<div style="display:flex;justify-content:space-between;"><span>${info.name}</span><span style="color:${color}">${kb} KB</span></div>`;
                        
                        // Add building names sub-item
                        if ((id === 'buildings' || id === 'buildingsLargeOnly') && document.getElementById('buildingNames')?.checked) {
                            if (window.extractedMetadata?.namedFeatures?.buildings?.length > 0) {
                                let nameBytes = 0;
                                for (const f of window.extractedMetadata.namedFeatures.buildings) nameBytes += (f.bytes || 20);
                                const nameKB = (nameBytes / 1024).toFixed(1);
                                breakdownHtml += `<div style="display:flex;justify-content:space-between;padding-left:12px;"><span style="color:#b197fc;">+ names (${window.extractedMetadata.namedFeatures.buildings.length})</span><span style="color:#b197fc;">${nameKB} KB</span></div>`;
                            } else if (!window.previewData && !window.extractedMetadata) {
                                breakdownHtml += '<div style="display:flex;justify-content:space-between;padding-left:12px;"><span style="color:#888;">+ names</span><span style="color:#888;">preview to see</span></div>';
                            } else {
                                // Preview loaded but no building names found
                                breakdownHtml += `<div style="display:flex;justify-content:space-between;padding-left:12px;"><span style="color:#888;">+ names</span><span style="color:#888;">0 found</span></div>`;
                            }
                        }
                    }
                }
            }
            
            // Add road/terrain names entry based on Name Detail level
            const currentNameLevel = parseInt(document.getElementById('nameDetail').value);
            if (currentNameLevel > 0 && window.extractedMetadata?.namedFeatures) {
                const nf = window.extractedMetadata.namedFeatures;
                let roadNameBytes = 0;
                let roadNameCount = 0;
                
                // Level 1: Highways only
                if (currentNameLevel >= 1 && nf.highways) {
                    for (const f of nf.highways) roadNameBytes += (f.bytes || 20);
                    roadNameCount += nf.highways.length;
                }
                // Level 2+: Major roads
                if (currentNameLevel >= 2 && nf.roads) {
                    for (const f of nf.roads) roadNameBytes += (f.bytes || 20);
                    roadNameCount += nf.roads.length;
                }
                // Level 4: Everything (water, parks, railways)
                if (currentNameLevel >= 4) {
                    if (nf.water) { for (const f of nf.water) roadNameBytes += (f.bytes || 20); roadNameCount += nf.water.length; }
                    if (nf.parks) { for (const f of nf.parks) roadNameBytes += (f.bytes || 20); roadNameCount += nf.parks.length; }
                    if (nf.railways) { for (const f of nf.railways) roadNameBytes += (f.bytes || 20); roadNameCount += nf.railways.length; }
                }
                
                if (roadNameBytes > 0) {
                    const roadNameKB = (roadNameBytes / 1024).toFixed(1);
                    breakdownHtml += `<div style="display:flex;justify-content:space-between;"><span style="color:#ffd93d;">+ names</span><span style="color:#ffd93d;">${roadNameKB} KB</span></div>`;
                    totalBytes += roadNameBytes;
                }
            }
            
            // Calculate uncapped size first (for comparison display)
            const uncappedFeatures = totalFeatures;
            const uncappedNamedFeatures = Math.round(uncappedFeatures * namePercent);
            const uncappedUniqueNames = Math.round(uncappedNamedFeatures * 0.15);
            const uncappedNameTableBytes = uncappedUniqueNames * (avgNameLen + 1);
            const uncappedNameIndexBytes = uncappedFeatures * 2;
            const uncappedTotalBytes = totalBytes + uncappedNameTableBytes + uncappedNameIndexBytes;
            
            // Feature count for calculations
            let estFeatures = totalFeatures;
            
            // Add name table overhead
            const estNamedFeatures = Math.round(estFeatures * namePercent);
            const estUniqueNames = Math.round(estNamedFeatures * 0.15); // ~15% unique names among named features
            const nameTableBytes = estUniqueNames * (avgNameLen + 1);
            const nameIndexBytes = estFeatures * 2;
            totalBytes += nameTableBytes + nameIndexBytes;
            
            // Use breakdown directly (no scaling since maxFeatures limit was removed)
            let scaledBreakdownHtml = breakdownHtml;
            
            // Show breakdown
            const breakdownDiv = document.getElementById('sizeBreakdown');
            const contentDiv = document.getElementById('breakdownContent');
            if (scaledBreakdownHtml && areaKm2 > 0) {
                contentDiv.innerHTML = scaledBreakdownHtml;
                breakdownDiv.style.display = 'block';
            } else {
                breakdownDiv.style.display = 'none';
            }
            
            // Update simplification savings displays - show potential savings even when unchecked
            const simplifyMapping = {
                simplifyBuildings: ['buildings', 'buildingsLargeOnly'],
                simplifyMotorways: ['motorways'],
                simplifyTrunk: ['trunkRoads'],
                simplifyPrimary: ['primaryRoads'],
                simplifySecondary: ['secondaryRoads'],
                simplifyTertiary: ['tertiaryRoads'],
                simplifyResidential: ['residentialRoads'],
                simplifyService: ['serviceRoads'],
                simplifyWater: ['waterBodies', 'waterways', 'coastlines'],
                simplifyParks: ['parks', 'grassland'],
                simplifyForests: ['forests'],
                simplifyPaths: ['footways', 'cycleways', 'tracks'],
                simplifyBus: ['busRoutes'],
                simplifyRail: ['railways', 'subways'],
                simplifyFerry: ['ferryRoutes'],
                simplifyStations: ['transitStations'],
                simplifyBridges: ['bridges'],
                simplifyIndustrial: ['industrial'],
                simplifyCommercial: ['commercial'],
                simplifyResidentialArea: ['residential']
            };
            
            for (const [checkboxId, savingsBytes] of Object.entries(simplifySavings)) {
                const savingsEl = document.getElementById(checkboxId + 'Savings');
                const checkbox = document.getElementById(checkboxId);
                if (savingsEl && checkbox) {
                    // Check if any related features are checked
                    const featureIds = simplifyMapping[checkboxId] || [];
                    const anyFeatureChecked = featureIds.some(id => document.getElementById(id)?.checked);
                    
                    if (anyFeatureChecked && savingsBytes > 0) {
                        const savingsKB = Math.round(savingsBytes / 1024);
                        // Show in gray if not checked, green if checked
                        if (checkbox.checked) {
                            savingsEl.textContent = `-${savingsKB} KB`;
                            savingsEl.style.color = '#69db7c';
                        } else {
                            savingsEl.textContent = `save ${savingsKB} KB`;
                            savingsEl.style.color = '#888';
                        }
                    } else {
                        savingsEl.textContent = '';
                    }
                }
            }
            
            return {
                capped: Math.round(totalBytes / 1024),
                uncapped: Math.round(uncappedTotalBytes / 1024)
            };
        }
        
        function updateSizeWarning(estKB) {
            const budget = parseInt(document.getElementById('sizeBudget').value);
            const warning = document.getElementById('sizeWarning');
            const barFill = document.getElementById('sizeBarFill');
            const percent = Math.min(100, (estKB / budget) * 100);
            
            barFill.style.width = percent + '%';
            barFill.className = 'size-bar-fill';
            
            if (estKB > budget * 1.5) {
                barFill.classList.add('danger');
                warning.classList.add('active');
            } else if (estKB > budget) {
                barFill.classList.add('warning');
                warning.classList.add('active');
            } else {
                warning.classList.remove('active');
            }
        }
        
        function updateDetailLabel() {
            // Detail Level slider removed - now using full detail by default
        }
        
        function updateBudgetLabel() {
            const budget = parseInt(document.getElementById('sizeBudget').value);
            if (budget >= 1000) {
                document.getElementById('budgetValue').textContent = (budget / 1000).toFixed(1) + ' MB';
            } else {
                document.getElementById('budgetValue').textContent = budget + ' KB';
            }
        }
        
        // =============================================================================
        // API RETRY HELPER
        // =============================================================================
        
        // Multiple Overpass API servers for fallback
        const OVERPASS_SERVERS = [
            'https://overpass-api.de/api/interpreter',
            'https://overpass.kumi.systems/api/interpreter'
  
        ];
        let currentServerIndex = 0;
        
        async function fetchWithRetry(url, options, maxRetries = 2) {
            let lastError;
            
            // Try current server first
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        // 400 = bad query syntax - don't retry, it won't help
                        if (response.status === 400) {
                            const errorText = await response.text();
                            console.error('Overpass query error (400):', errorText);
                            console.error('Query was:', options.body);
                            // Throw with special marker so we don't retry
                            const err = new Error('Query syntax error: ' + (errorText.substring(0, 200) || 'Bad Request'));
                            err.noRetry = true;
                            throw err;
                        }
                        // 429 = rate limit, 504 = timeout
                        if (response.status === 429 || response.status === 504) {
                            throw new Error('Server overloaded: ' + response.status);
                        }
                        throw new Error('API error: ' + response.status);
                    }
                    return response;
                } catch (error) {
                    lastError = error;
                    // Don't retry syntax errors - they won't fix themselves
                    if (error.noRetry) {
                        currentServerIndex = 0;
                        throw error;
                    }
                    console.warn(`Attempt ${attempt}/${maxRetries} on server ${currentServerIndex + 1} failed:`, error.message);
                    if (attempt < maxRetries) {
                        setStatus('working', `Retry ${attempt}/${maxRetries}... Server busy`);
                        await new Promise(r => setTimeout(r, 2000 * attempt)); // Longer backoff
                    }
                }
            }
            
            // If all retries failed, try next server
            if (currentServerIndex < OVERPASS_SERVERS.length - 1) {
                currentServerIndex++;
                console.warn(`Switching to backup server ${currentServerIndex + 1}/${OVERPASS_SERVERS.length}`);
                setStatus('working', `Trying backup server ${currentServerIndex + 1}...`);
                await new Promise(r => setTimeout(r, 1000)); // Brief pause before switching
                return fetchWithRetry(OVERPASS_SERVERS[currentServerIndex], options, maxRetries);
            }
            
            // All servers failed
            currentServerIndex = 0; // Reset for next time
            throw new Error('All API servers are currently overloaded. Please wait a few minutes and try again.');
        }
        
        // =============================================================================
        // PREVIEW FUNCTION
        // =============================================================================
        
        // Colors for preview matching the device viewer
        const PREVIEW_COLORS = {
            highway: { color: '#ff6b6b', weight: 4 },      // Motorways, trunk
            major: { color: '#ffd93d', weight: 3 },        // Primary, secondary
            minor: { color: '#ffffff', weight: 2 },        // Tertiary, residential
            path: { color: '#aaaaaa', weight: 1, dashArray: '4,4' },  // Footways, etc.
            water: { color: '#4dabf7', weight: 1, fillColor: '#1864ab', fillOpacity: 0.5, isPolygon: true },
            park: { color: '#69db7c', weight: 1, fillColor: '#2b8a3e', fillOpacity: 0.4, isPolygon: true },
            railway: { color: '#da77f2', weight: 2, dashArray: '8,4' },
            bus: { color: '#fab005', weight: 2, dashArray: '6,3' },   // Yellow/orange for bus
            ferry: { color: '#15aabf', weight: 3, dashArray: '12,6' }, // Cyan/teal for ferry
            station: { color: '#f06595', weight: 0, radius: 4 },       // Pink dot for stations
            building: { color: '#868e96', weight: 1, fillColor: '#495057', fillOpacity: 0.5, isPolygon: true }
        };
        
        function closePreview() {
            document.getElementById('previewPanel').classList.remove('active');
            // Reset preview button back to preview mode
            const btn = document.getElementById('previewBtn');
            if (btn) {
                btn.textContent = '👁️ Preview Selection';
                btn.onclick = previewMap;
            }
            // Clear cached blob since user closed preview
            window.hwmapBlob = null;
            window.hwmapFilename = null;
        }
        
        // =============================================================================
        // PERFORMANCE: Spatial Index & Render Throttling
        // =============================================================================
        
        const SPATIAL_GRID_SIZE = 8;  // 8x8 = 64 cells (matches HWMAP export)
        window.previewSpatialIndex = null;
        window.previewRenderPending = false;
        
        function buildPreviewSpatialIndex() {
            if (!window.previewData) return;
            
            const bounds = window.previewData.bounds;
            const cellWidth = (bounds.maxLon - bounds.minLon) / SPATIAL_GRID_SIZE;
            const cellHeight = (bounds.maxLat - bounds.minLat) / SPATIAL_GRID_SIZE;
            
            // Create grid of empty arrays
            const grid = Array(SPATIAL_GRID_SIZE * SPATIAL_GRID_SIZE).fill(null).map(() => []);
            
            // Index each element by its bounding box
            for (let i = 0; i < window.previewData.elements.length; i++) {
                const el = window.previewData.elements[i];
                const coords = el.geometry;
                if (!coords || coords.length < 2) continue;
                
                // Calculate element bounding box
                let fMinLat = Infinity, fMaxLat = -Infinity;
                let fMinLon = Infinity, fMaxLon = -Infinity;
                for (const p of coords) {
                    if (p.lat < fMinLat) fMinLat = p.lat;
                    if (p.lat > fMaxLat) fMaxLat = p.lat;
                    if (p.lon < fMinLon) fMinLon = p.lon;
                    if (p.lon > fMaxLon) fMaxLon = p.lon;
                }
                
                // Store bbox with element index for fast lookup
                el._bbox = { fMinLat, fMaxLat, fMinLon, fMaxLon };
                
                // Determine which grid cells this element intersects
                let minCellX = Math.floor((fMinLon - bounds.minLon) / cellWidth);
                let maxCellX = Math.floor((fMaxLon - bounds.minLon) / cellWidth);
                let minCellY = Math.floor((fMinLat - bounds.minLat) / cellHeight);
                let maxCellY = Math.floor((fMaxLat - bounds.minLat) / cellHeight);
                
                // Clamp to valid range
                minCellX = Math.max(0, Math.min(SPATIAL_GRID_SIZE - 1, minCellX));
                maxCellX = Math.max(0, Math.min(SPATIAL_GRID_SIZE - 1, maxCellX));
                minCellY = Math.max(0, Math.min(SPATIAL_GRID_SIZE - 1, minCellY));
                maxCellY = Math.max(0, Math.min(SPATIAL_GRID_SIZE - 1, maxCellY));
                
                // Add element index to all cells it intersects
                for (let cy = minCellY; cy <= maxCellY; cy++) {
                    for (let cx = minCellX; cx <= maxCellX; cx++) {
                        grid[cy * SPATIAL_GRID_SIZE + cx].push(i);
                    }
                }
            }
            
            // Build building clusters per cell for LOD rendering
            const buildingClusters = Array(SPATIAL_GRID_SIZE * SPATIAL_GRID_SIZE).fill(null).map(() => null);
            for (let cellIdx = 0; cellIdx < grid.length; cellIdx++) {
                let clusterMinLat = Infinity, clusterMaxLat = -Infinity;
                let clusterMinLon = Infinity, clusterMaxLon = -Infinity;
                let buildingCount = 0;
                
                for (const elemIdx of grid[cellIdx]) {
                    const el = window.previewData.elements[elemIdx];
                    if (el.tags?.building && el._bbox) {
                        clusterMinLat = Math.min(clusterMinLat, el._bbox.fMinLat);
                        clusterMaxLat = Math.max(clusterMaxLat, el._bbox.fMaxLat);
                        clusterMinLon = Math.min(clusterMinLon, el._bbox.fMinLon);
                        clusterMaxLon = Math.max(clusterMaxLon, el._bbox.fMaxLon);
                        buildingCount++;
                    }
                }
                
                if (buildingCount > 0) {
                    buildingClusters[cellIdx] = {
                        minLat: clusterMinLat, maxLat: clusterMaxLat,
                        minLon: clusterMinLon, maxLon: clusterMaxLon,
                        count: buildingCount
                    };
                }
            }
            
            window.previewSpatialIndex = {
                grid,
                cellWidth,
                cellHeight,
                bounds,
                buildingClusters
            };
            
            console.log(`[SPATIAL] Built ${SPATIAL_GRID_SIZE}x${SPATIAL_GRID_SIZE} index for ${window.previewData.elements.length} features`);
        }
        
        // Get element indices visible in the given viewport bounds
        function getVisibleElementIndices(viewMinLon, viewMaxLon, viewMinLat, viewMaxLat) {
            const idx = window.previewSpatialIndex;
            if (!idx) return null;  // Fall back to full iteration
            
            const bounds = idx.bounds;
            
            // Determine which grid cells the viewport intersects
            let minCellX = Math.floor((viewMinLon - bounds.minLon) / idx.cellWidth);
            let maxCellX = Math.floor((viewMaxLon - bounds.minLon) / idx.cellWidth);
            let minCellY = Math.floor((viewMinLat - bounds.minLat) / idx.cellHeight);
            let maxCellY = Math.floor((viewMaxLat - bounds.minLat) / idx.cellHeight);
            
            // Clamp to valid range
            minCellX = Math.max(0, Math.min(SPATIAL_GRID_SIZE - 1, minCellX));
            maxCellX = Math.max(0, Math.min(SPATIAL_GRID_SIZE - 1, maxCellX));
            minCellY = Math.max(0, Math.min(SPATIAL_GRID_SIZE - 1, minCellY));
            maxCellY = Math.max(0, Math.min(SPATIAL_GRID_SIZE - 1, maxCellY));
            
            // Collect unique element indices from visible cells
            const seen = new Set();
            for (let cy = minCellY; cy <= maxCellY; cy++) {
                for (let cx = minCellX; cx <= maxCellX; cx++) {
                    for (const elemIdx of idx.grid[cy * SPATIAL_GRID_SIZE + cx]) {
                        seen.add(elemIdx);
                    }
                }
            }
            
            return seen;
        }
        
        // Throttled render - batches rapid pan/zoom into single frame
        function requestPreviewRender() {
            if (window.previewRenderPending) return;
            window.previewRenderPending = true;
            requestAnimationFrame(() => {
                window.previewRenderPending = false;
                renderPreview();
            });
        }
        
        function renderPreview() {
            const mode = document.getElementById('previewModeGranular')?.checked ? 'granular' : 'device';
            if (mode === 'device') {
                if (window.hwmapData) {
                    renderHWMapPreview();
                    return;
                }
                // No hwmap loaded yet; fallback to OSM preview
                renderPreviewOSM();
                return;
            }
            // Granular mode: always use OSM-tag preview rendering
            renderPreviewOSM();
        }

        function renderPreviewOSM() {
            if (!window.previewData || !selectedBounds) return;
            
            const canvas = document.getElementById('previewCanvas');
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');
            
            // BLACK background outside selection
            ctx.fillStyle = '#0a0a14';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Use bounds stored WITH the data to ensure consistency
            const storedBounds = window.previewData.bounds;
            const storedPolygon = window.previewData.polygon;
            const minLat = storedBounds.minLat;
            const maxLat = storedBounds.maxLat;
            const minLon = storedBounds.minLon;
            const maxLon = storedBounds.maxLon;
            
            console.log('Using stored bounds:', storedBounds);
            console.log('Using stored polygon:', storedPolygon ? storedPolygon.length + ' points' : 'none');
            
            // Point-in-polygon test (same as in filter)
            function pointInPolygon(lon, lat, polygon) {
                if (!polygon || polygon.length < 3) return true;
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const yi = polygon[i][0], xi = polygon[i][1];
                    const yj = polygon[j][0], xj = polygon[j][1];
                    if (((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }
                return inside;
            }
            
            function inSelection(lon, lat, includeEdges = false) {
                // Use inclusive bounds check when includeEdges is true (for polygons that trace boundary)
                if (includeEdges) {
                    if (lon < minLon - 0.001 || lon > maxLon + 0.001 || lat < minLat - 0.001 || lat > maxLat + 0.001) return false;
                } else {
                    if (lon < minLon || lon > maxLon || lat < minLat || lat > maxLat) return false;
                }
                if (storedPolygon) return pointInPolygon(lon, lat, storedPolygon);
                return true;
            }
            
            // Padding
            const padding = 20;
            const drawWidth = canvas.width - padding * 2;
            const drawHeight = canvas.height - padding * 2;
            
            // Scale to fit while maintaining aspect ratio
            // Apply latitude correction: at lat φ, 1° lon = cos(φ) × 1° lat in real distance
            const centerLat = (minLat + maxLat) / 2;
            const latCorrectionFactor = Math.cos(centerLat * Math.PI / 180);
            
            const latRange = maxLat - minLat;
            const lonRange = maxLon - minLon;
            const correctedLonRange = lonRange * latCorrectionFactor;  // Actual width in "lat degrees"
            
            const latScale = drawHeight / latRange;
            const lonScale = drawWidth / correctedLonRange;
            const baseScale = Math.min(latScale, lonScale);
            const scale = baseScale * window.previewZoom;
            
            // Center offset with pan (use corrected lon range for proper centering)
            const offsetX = padding + (drawWidth - correctedLonRange * scale) / 2 + window.previewPanX;
            const offsetY = padding + (drawHeight - latRange * scale) / 2 + window.previewPanY;
            
            function toCanvasX(lon) {
                return offsetX + (lon - minLon) * latCorrectionFactor * scale;
            }
            function toCanvasY(lat) {
                return canvas.height - (offsetY + (lat - minLat) * scale);
            }
            
            // Calculate visible viewport in geo coordinates (for culling)
            // Inverse of toCanvasX/Y to get geo bounds of visible canvas area
            function canvasToLon(cx) {
                return (cx - offsetX) / (latCorrectionFactor * scale) + minLon;
            }
            function canvasToLat(cy) {
                return (canvas.height - cy - offsetY) / scale + minLat;
            }
            
            // Visible viewport bounds (with some margin for partially visible features)
            const margin = 50; // pixels
            const viewMinLon = canvasToLon(-margin);
            const viewMaxLon = canvasToLon(canvas.width + margin);
            const viewMinLat = canvasToLat(canvas.height + margin);
            const viewMaxLat = canvasToLat(-margin);
            
            // Fast AABB intersection check for viewport culling
            function featureInViewport(coords) {
                // Quick bounding box check - find feature bounds
                let fMinLat = Infinity, fMaxLat = -Infinity;
                let fMinLon = Infinity, fMaxLon = -Infinity;
                for (const p of coords) {
                    if (p.lat < fMinLat) fMinLat = p.lat;
                    if (p.lat > fMaxLat) fMaxLat = p.lat;
                    if (p.lon < fMinLon) fMinLon = p.lon;
                    if (p.lon > fMaxLon) fMaxLon = p.lon;
                }
                // AABB intersection test
                return !(fMaxLon < viewMinLon || fMinLon > viewMaxLon ||
                         fMaxLat < viewMinLat || fMinLat > viewMaxLat);
            }
            
            // Helper to extract geometry from element (handles both ways and relations)
            // Track processed way refs to avoid duplicates from shared relation members
            const processedWayRefs = new Set();
            
            function getElementGeometries(element) {
                if (element.type === 'way' && element.geometry) {
                    return [{ coords: element.geometry, tags: element.tags }];
                }
                if (element.type === 'relation' && element.members) {
                    // For multipolygon relations, extract outer ring geometries
                    const geometries = [];
                    const MAX_MEMBERS_PER_RELATION = 50;  // Limit complexity, but allow dense areas
                    let memberCount = 0;
                    
                    for (const member of element.members) {
                        if (memberCount >= MAX_MEMBERS_PER_RELATION) break;
                        if (!member.geometry || member.role === 'inner') continue;
                        if (member.geometry.length < 4) continue;  // Skip tiny fragments
                        
                        // Skip if this way was already processed (deduplication)
                        if (member.ref && processedWayRefs.has(member.ref)) continue;
                        if (member.ref) processedWayRefs.add(member.ref);
                        
                        geometries.push({ coords: member.geometry, tags: element.tags });
                        memberCount++;
                    }
                    return geometries;
                }
                return [];
            }
            
            // Draw BLUE water only inside the selection area (not entire canvas)
            ctx.fillStyle = '#1864ab';
            if (storedPolygon && storedPolygon.length >= 3) {
                // Polygon selection - fill only the polygon shape
                ctx.beginPath();
                ctx.moveTo(toCanvasX(storedPolygon[0][1]), toCanvasY(storedPolygon[0][0]));
                for (let i = 1; i < storedPolygon.length; i++) {
                    ctx.lineTo(toCanvasX(storedPolygon[i][1]), toCanvasY(storedPolygon[i][0]));
                }
                ctx.closePath();
                ctx.fill();
            } else {
                // Rectangle selection - fill the bounding box
                const x1 = toCanvasX(minLon);
                const y1 = toCanvasY(maxLat);
                const x2 = toCanvasX(maxLon);
                const y2 = toCanvasY(minLat);
                ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
            }
            
            // RENDER LAND MASK: Draw all coastlines and fill land with black
            // This creates a proper land/water distinction without polygon overlap issues
            (function renderLandMask() {
                const EPSILON = 0.00001;  // ~1 meter tolerance for point matching
                
                // Collect coastline segments from elements
                const coastlineSegments = [];
                for (const el of window.previewData.elements) {
                    if (el.type === 'way' && el.tags?.natural === 'coastline' && el.geometry) {
                        coastlineSegments.push(el.geometry.map(p => ({ lat: p.lat, lon: p.lon })));
                    }
                }
                
                if (coastlineSegments.length === 0) return;
                
                // Connect segments into continuous paths (same logic as processCoastlines)
                function pointsMatch(p1, p2) {
                    return Math.abs(p1.lat - p2.lat) < EPSILON && Math.abs(p1.lon - p2.lon) < EPSILON;
                }
                
                const used = new Set();
                function findConnectingSegment(endPoint, excludeIdx) {
                    for (let i = 0; i < coastlineSegments.length; i++) {
                        if (used.has(i) || i === excludeIdx) continue;
                        const seg = coastlineSegments[i];
                        if (pointsMatch(endPoint, seg[0])) return { idx: i, reverse: false };
                        if (pointsMatch(endPoint, seg[seg.length - 1])) return { idx: i, reverse: true };
                    }
                    return null;
                }
                
                const coastlinePaths = [];
                for (let startIdx = 0; startIdx < coastlineSegments.length; startIdx++) {
                    if (used.has(startIdx)) continue;
                    
                    let path = [...coastlineSegments[startIdx]];
                    used.add(startIdx);
                    
                    // Extend forward
                    let extended = true;
                    while (extended) {
                        extended = false;
                        const conn = findConnectingSegment(path[path.length - 1], -1);
                        if (conn) {
                            used.add(conn.idx);
                            const seg = coastlineSegments[conn.idx];
                            const toAdd = conn.reverse ? [...seg].reverse() : seg;
                            path = path.concat(toAdd.slice(1));
                            extended = true;
                        }
                    }
                    
                    // Extend backward
                    extended = true;
                    while (extended) {
                        extended = false;
                        const conn = findConnectingSegment(path[0], -1);
                        if (conn) {
                            used.add(conn.idx);
                            const seg = coastlineSegments[conn.idx];
                            const toAdd = conn.reverse ? seg : [...seg].reverse();
                            path = toAdd.slice(0, -1).concat(path);
                            extended = true;
                        }
                    }
                    
                    coastlinePaths.push(path);
                }
                
                console.log(`[LAND MASK] Connected ${coastlineSegments.length} segments into ${coastlinePaths.length} paths`);
                
                // Proper line-boundary intersection clipping
                // This preserves direction and computes exact intersection points
                function lineIntersectRect(p1, p2, minLat, maxLat, minLon, maxLon) {
                    // Returns intersection point where line p1->p2 crosses the rectangle boundary
                    const edges = [
                        { lat: maxLat, lon1: minLon, lon2: maxLon, type: 'top' },    // Top edge
                        { lat: minLat, lon1: minLon, lon2: maxLon, type: 'bottom' }, // Bottom edge
                        { lon: minLon, lat1: minLat, lat2: maxLat, type: 'left' },   // Left edge
                        { lon: maxLon, lat1: minLat, lat2: maxLat, type: 'right' }   // Right edge
                    ];
                    
                    for (const edge of edges) {
                        if (edge.type === 'top' || edge.type === 'bottom') {
                            // Horizontal edge - check lat intersection
                            if ((p1.lat - edge.lat) * (p2.lat - edge.lat) < 0) {
                                const t = (edge.lat - p1.lat) / (p2.lat - p1.lat);
                                const lon = p1.lon + t * (p2.lon - p1.lon);
                                if (lon >= edge.lon1 && lon <= edge.lon2) {
                                    return { lat: edge.lat, lon: lon, edge: edge.type };
                                }
                            }
                        } else {
                            // Vertical edge - check lon intersection
                            if ((p1.lon - edge.lon) * (p2.lon - edge.lon) < 0) {
                                const t = (edge.lon - p1.lon) / (p2.lon - p1.lon);
                                const lat = p1.lat + t * (p2.lat - p1.lat);
                                if (lat >= edge.lat1 && lat <= edge.lat2) {
                                    return { lat: lat, lon: edge.lon, edge: edge.type };
                                }
                            }
                        }
                    }
                    return null;
                }
                
                function isInside(p) {
                    return p.lat >= minLat && p.lat <= maxLat && p.lon >= minLon && p.lon <= maxLon;
                }
                
                // Helper: determine which edge a point is on (or nearest edge if inside)
                function getEdgeForPoint(p, forceNearest = false) {
                    const tolerance = 0.0001;
                    // First check if exactly on an edge
                    if (Math.abs(p.lat - maxLat) < tolerance) return 'top';
                    if (Math.abs(p.lat - minLat) < tolerance) return 'bottom';
                    if (Math.abs(p.lon - minLon) < tolerance) return 'left';
                    if (Math.abs(p.lon - maxLon) < tolerance) return 'right';
                    
                    // If forceNearest, find the closest edge
                    if (forceNearest) {
                        const distTop = Math.abs(p.lat - maxLat);
                        const distBottom = Math.abs(p.lat - minLat);
                        const distLeft = Math.abs(p.lon - minLon);
                        const distRight = Math.abs(p.lon - maxLon);
                        const minDist = Math.min(distTop, distBottom, distLeft, distRight);
                        if (minDist === distTop) return 'top';
                        if (minDist === distBottom) return 'bottom';
                        if (minDist === distLeft) return 'left';
                        return 'right';
                    }
                    return null;
                }
                
                // Clip each coastline using proper intersection
                const clippedPaths = [];
                for (const path of coastlinePaths) {
                    const clipped = [];
                    
                    for (let i = 0; i < path.length; i++) {
                        const curr = path[i];
                        const prev = i > 0 ? path[i - 1] : null;
                        const currInside = isInside(curr);
                        const prevInside = prev ? isInside(prev) : false;
                        
                        if (currInside && !prevInside && prev) {
                            // Entering bounds - add intersection point
                            const intersection = lineIntersectRect(prev, curr, minLat, maxLat, minLon, maxLon);
                            if (intersection) clipped.push(intersection);
                            clipped.push(curr);
                        } else if (!currInside && prevInside && prev) {
                            // Exiting bounds - add intersection point and save segment
                            const intersection = lineIntersectRect(prev, curr, minLat, maxLat, minLon, maxLon);
                            if (intersection) clipped.push(intersection);
                            if (clipped.length >= 2) clippedPaths.push([...clipped]);
                            clipped.length = 0;
                        } else if (currInside) {
                            clipped.push(curr);
                        }
                    }
                    if (clipped.length >= 2) clippedPaths.push(clipped);
                }
                
                // Post-process: ensure start/end points have edge info
                // Use forceNearest=true to assign nearest edge for points inside bounds
                for (const path of clippedPaths) {
                    if (path.length < 2) continue;
                    if (!path[0].edge) path[0].edge = getEdgeForPoint(path[0], true);  // Force nearest edge
                    if (!path[path.length - 1].edge) path[path.length - 1].edge = getEdgeForPoint(path[path.length - 1], true);
                }
                
                if (clippedPaths.length === 0) return;
                
                console.log(`[LAND MASK] ${clippedPaths.length} clipped coastline segments`);
                
                // Draw land polygons using the "water on right" rule
                // For each coastline segment: trace coastline, then trace bbox edges on LAND side (left)
                ctx.fillStyle = '#1a1a2e'; // Dark blue-gray for land (visible against blue water)
                
                // Edge indices: top=0, right=1, bottom=2, left=3
                // Corners in CLOCKWISE order: NE=0, SE=1, SW=2, NW=3
                const corners = [
                    { lat: maxLat, lon: maxLon }, // NE - 0
                    { lat: minLat, lon: maxLon }, // SE - 1
                    { lat: minLat, lon: minLon }, // SW - 2
                    { lat: maxLat, lon: minLon }  // NW - 3
                ];
                
                // Get edge index from edge name
                const edgeIndex = { 'top': 0, 'right': 1, 'bottom': 2, 'left': 3 };
                
                // For counter-clockwise traversal from edge A to edge B, which corners to include?
                // Counter-clockwise order: top -> left -> bottom -> right -> top
                // Corner at CCW end of edge: top->NW(3), left->SW(2), bottom->SE(1), right->NE(0)
                const ccwCornerAfterEdge = [3, 0, 1, 2]; // After exiting edge, first CCW corner
                
                let landPolysDrawn = 0;
                let skippedNoEdge = 0;
                let skippedNegativeArea = 0;
                let closedLoopsFilled = 0;
                
                for (let pathIdx = 0; pathIdx < clippedPaths.length; pathIdx++) {
                    const path = clippedPaths[pathIdx];
                    if (path.length < 2) continue;
                    
                    const start = path[0];
                    const end = path[path.length - 1];
                    
                    // Check if this is a closed loop (island entirely inside bounds)
                    const isClosed = Math.abs(start.lat - end.lat) < 0.0001 && Math.abs(start.lon - end.lon) < 0.0001;
                    
                    if (isClosed && path.length >= 3) {
                        // Closed loop - fill directly if positive area (land/island)
                        let area = 0;
                        for (let i = 0; i < path.length; i++) {
                            const j = (i + 1) % path.length;
                            area += path[i].lon * path[j].lat;
                            area -= path[j].lon * path[i].lat;
                        }
                        area /= 2;
                        
                        if (area > 0) {
                            ctx.beginPath();
                            ctx.moveTo(toCanvasX(path[0].lon), toCanvasY(path[0].lat));
                            for (let i = 1; i < path.length; i++) {
                                ctx.lineTo(toCanvasX(path[i].lon), toCanvasY(path[i].lat));
                            }
                            ctx.closePath();
                            ctx.fill();
                            closedLoopsFilled++;
                            if (pathIdx < 5) console.log(`[LAND MASK ${pathIdx}] Closed loop filled: ${path.length} pts, area=${area.toFixed(6)}`);
                        }
                        continue;
                    }
                    
                    // Get edge info (computed during intersection)
                    const startEdge = start.edge ? edgeIndex[start.edge] : null;
                    const endEdge = end.edge ? edgeIndex[end.edge] : null;
                    
                    if (startEdge === null || endEdge === null) {
                        skippedNoEdge++;
                        if (pathIdx < 5) console.log(`[LAND MASK ${pathIdx}] Skipped: no edge info. start.edge=${start.edge}, end.edge=${end.edge}`);
                        continue;
                    }
                    
                    // Build land polygon by trying BOTH corner traversal directions
                    // Pick the one that gives positive area (land), not negative (water)
                    
                    function buildPolygonWithCorners(pathPts, startE, endE, clockwise) {
                        const poly = [...pathPts];
                        let currentEdge = endE;
                        let safety = 0;
                        const cornersUsed = [];
                        while (currentEdge !== startE && safety < 5) {
                            if (clockwise) {
                                // CW: top->right->bottom->left (edge + 1)
                                const cornerIdx = currentEdge; // CW corner after edge
                                poly.push(corners[cornerIdx]);
                                cornersUsed.push(cornerIdx);
                                currentEdge = (currentEdge + 1) % 4;
                            } else {
                                // CCW: top->left->bottom->right (edge + 3)
                                const cornerIdx = ccwCornerAfterEdge[currentEdge];
                                poly.push(corners[cornerIdx]);
                                cornersUsed.push(cornerIdx);
                                currentEdge = (currentEdge + 3) % 4;
                            }
                            safety++;
                        }
                        // Calculate signed area
                        let a = 0;
                        for (let i = 0; i < poly.length; i++) {
                            const j = (i + 1) % poly.length;
                            a += poly[i].lon * poly[j].lat;
                            a -= poly[j].lon * poly[i].lat;
                        }
                        return { poly, area: a / 2, corners: cornersUsed };
                    }
                    
                    const ccwResult = buildPolygonWithCorners(path, startEdge, endEdge, false);
                    const cwResult = buildPolygonWithCorners(path, startEdge, endEdge, true);
                    
                    // Pick the polygon with positive area (land)
                    let chosenResult = null;
                    let direction = '';
                    if (ccwResult.area > 0 && cwResult.area > 0) {
                        // Both positive - pick smaller one (more likely to be actual land peninsula)
                        chosenResult = ccwResult.area < cwResult.area ? ccwResult : cwResult;
                        direction = ccwResult.area < cwResult.area ? 'CCW(smaller)' : 'CW(smaller)';
                    } else if (ccwResult.area > 0) {
                        chosenResult = ccwResult;
                        direction = 'CCW';
                    } else if (cwResult.area > 0) {
                        chosenResult = cwResult;
                        direction = 'CW';
                    }
                    
                    if (pathIdx < 10) {
                        console.log(`[LAND MASK ${pathIdx}] startEdge=${startEdge}(${start.edge}), endEdge=${endEdge}(${end.edge}), CCW_area=${ccwResult.area.toFixed(6)}, CW_area=${cwResult.area.toFixed(6)}, chosen=${direction}`);
                    }
                    
                    if (chosenResult) {
                        ctx.beginPath();
                        ctx.moveTo(toCanvasX(chosenResult.poly[0].lon), toCanvasY(chosenResult.poly[0].lat));
                        for (let i = 1; i < chosenResult.poly.length; i++) {
                            ctx.lineTo(toCanvasX(chosenResult.poly[i].lon), toCanvasY(chosenResult.poly[i].lat));
                        }
                        ctx.closePath();
                        ctx.fill();
                        landPolysDrawn++;
                    } else {
                        skippedNegativeArea++;
                        if (pathIdx < 10) console.log(`[LAND MASK ${pathIdx}] Skipped: both areas negative (water bay)`);
                    }
                }
                
                console.log(`[LAND MASK] SUMMARY: drawn=${landPolysDrawn}, closedLoops=${closedLoopsFilled}, skippedNoEdge=${skippedNoEdge}, skippedNegativeArea=${skippedNegativeArea}`);
            })();
            
            // Draw features with SPATIAL INDEX culling (much faster than iterating all)
            let featureCount = 0;
            let culledCount = 0;
            let spatialSkipped = 0;
            
            // Get visible element indices from spatial index
            const visibleIndices = getVisibleElementIndices(viewMinLon, viewMaxLon, viewMinLat, viewMaxLat);
            const usesSpatialIndex = visibleIndices !== null;
            
            // LOD thresholds
            const lodSkipMinor = window.previewZoom < 1.2;  // Skip individual buildings
            const lodSkipPaths = window.previewZoom < 0.8;
            const showBuildingClusters = window.previewZoom < 1.2;  // Show clusters instead
            
            // Draw building clusters as blobs when zoomed out
            if (showBuildingClusters && window.previewSpatialIndex?.buildingClusters) {
                ctx.fillStyle = 'rgba(128, 128, 128, 0.4)';  // Semi-transparent gray
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 1;
                
                for (let cellIdx = 0; cellIdx < window.previewSpatialIndex.buildingClusters.length; cellIdx++) {
                    const cluster = window.previewSpatialIndex.buildingClusters[cellIdx];
                    if (!cluster) continue;
                    
                    // Check if cluster is in viewport
                    if (cluster.maxLon < viewMinLon || cluster.minLon > viewMaxLon ||
                        cluster.maxLat < viewMinLat || cluster.minLat > viewMaxLat) continue;
                    
                    // Draw cluster as rounded rectangle blob
                    const x1 = toCanvasX(cluster.minLon);
                    const y1 = toCanvasY(cluster.maxLat);
                    const x2 = toCanvasX(cluster.maxLon);
                    const y2 = toCanvasY(cluster.minLat);
                    const w = x2 - x1;
                    const h = y2 - y1;
                    
                    // Only draw if big enough to see
                    if (w > 3 && h > 3) {
                        const r = Math.min(4, w / 4, h / 4);  // Corner radius
                        ctx.beginPath();
                        ctx.roundRect(x1, y1, w, h, r);
                        ctx.fill();
                        ctx.stroke();
                    }
                }
            }
            
            // Iterate only visible elements (or all if no spatial index)
            const elementsToCheck = usesSpatialIndex 
                ? Array.from(visibleIndices).map(i => window.previewData.elements[i])
                : window.previewData.elements;
            
            if (usesSpatialIndex) {
                spatialSkipped = window.previewData.elements.length - visibleIndices.size;
            }
            
            for (const element of elementsToCheck) {
                const geometries = getElementGeometries(element);
                if (geometries.length === 0) continue;
                
                for (const { coords, tags } of geometries) {
                if (!coords || coords.length < 2) continue;
                
                // LOD culling - skip buildings and paths when zoomed out
                if (lodSkipMinor && tags.building) {
                    culledCount++;
                    continue;
                }
                if (lodSkipPaths && (tags.highway === 'footway' || tags.highway === 'path' || 
                    tags.highway === 'cycleway' || tags.highway === 'track')) {
                    culledCount++;
                    continue;
                }
                
                // VIEWPORT CULLING: Use cached bbox if available, otherwise compute
                const bbox = element._bbox;
                if (bbox) {
                    if (bbox.fMaxLon < viewMinLon || bbox.fMinLon > viewMaxLon ||
                        bbox.fMaxLat < viewMinLat || bbox.fMinLat > viewMaxLat) {
                        culledCount++;
                        continue;
                    }
                } else if (!featureInViewport(coords)) {
                    culledCount++;
                    continue;
                }
                
                const style = getPreviewStyle(tags);
                if (!style) continue;
                
                ctx.strokeStyle = style.color;
                // Don't scale line width with zoom - keep lines thin when zoomed in
                ctx.lineWidth = Math.max(1, Math.min(style.weight || 1, 2));
                if (style.dashArray) {
                    ctx.setLineDash(style.dashArray.split(',').map(n => Number(n)));
                } else {
                    ctx.setLineDash([]);
                }
                
                // Check if this is actually a closed polygon (first/last points match)
                const isClosedPolygon = coords.length >= 3 && 
                    Math.abs(coords[0].lon - coords[coords.length-1].lon) < 0.0001 &&
                    Math.abs(coords[0].lat - coords[coords.length-1].lat) < 0.0001;
                
                // Debug: log coastline-generated water polygons
                if (tags.water === 'coastline_generated') {
                    console.log('Coastline water:', { 
                        points: coords.length, 
                        isClosedPolygon,
                        hasIsPolygon: style.isPolygon,
                        hasFillColor: !!style.fillColor,
                        first: coords[0],
                        last: coords[coords.length-1]
                    });
                }
                
                // For closed polygons (lakes, parks, buildings), draw filled shapes
                // Linear features like rivers should just be stroked
                if (style.isPolygon && style.fillColor && isClosedPolygon) {
                    ctx.beginPath();
                    let hasPoints = false;
                    // For polygons, use inclusive bounds to include boundary points
                    for (const p of coords) {
                        if (!inSelection(p.lon, p.lat, true)) continue;  // includeEdges=true
                        const cx = toCanvasX(p.lon), cy = toCanvasY(p.lat);
                        if (!hasPoints) {
                            ctx.moveTo(cx, cy);
                            hasPoints = true;
                        } else {
                            ctx.lineTo(cx, cy);
                        }
                    }
                    if (hasPoints) {
                        ctx.closePath();
                        ctx.fillStyle = style.fillColor;
                        ctx.globalAlpha = style.fillOpacity || 0.5;
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                        ctx.stroke();
                    }
                } else {
                    // Regular line rendering for roads, railways, etc.
                    ctx.beginPath();
                    let inPath = false;
                    for (const p of coords) {
                        if (!inSelection(p.lon, p.lat)) {
                            if (inPath) {
                                ctx.stroke();
                                ctx.beginPath();
                                inPath = false;
                            }
                            continue;
                        }
                        
                        const cx = toCanvasX(p.lon), cy = toCanvasY(p.lat);
                        if (!inPath) {
                            ctx.moveTo(cx, cy);
                            inPath = true;
                        } else {
                            ctx.lineTo(cx, cy);
                        }
                    }
                    if (inPath) ctx.stroke();
                }
                featureCount++;
                }  // end geometries loop
            }
            
            const totalChecked = featureCount + culledCount;
            const totalElements = window.previewData.elements.length;
            console.log(`Features rendered: ${featureCount}, culled: ${culledCount}/${totalChecked} checked (${spatialSkipped} skipped by spatial index, zoom=${window.previewZoom.toFixed(2)})`);
            
            // Draw text labels for named features (buildings, roads) with collision avoidance
            const buildingNamesChecked = document.getElementById('buildingNames')?.checked;
            const nameDetailLevel = parseInt(document.getElementById('nameDetail').value);
            
            if (buildingNamesChecked || nameDetailLevel > 0) {
                const labelRects = []; // Track placed labels to avoid overlap
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Check if a new label would overlap existing ones
                function wouldOverlap(x, y, width, height) {
                    const padding = 4;
                    const newRect = { 
                        x: x - width/2 - padding, 
                        y: y - height/2 - padding, 
                        w: width + padding*2, 
                        h: height + padding*2 
                    };
                    for (const rect of labelRects) {
                        if (newRect.x < rect.x + rect.w && newRect.x + newRect.w > rect.x &&
                            newRect.y < rect.y + rect.h && newRect.y + newRect.h > rect.y) {
                            return true;
                        }
                    }
                    return false;
                }
                
                // Track how many times each name has been rendered (limit duplicates)
                const nameRenderCount = new Map();
                const MAX_NAME_RENDERS = 2;  // Show same name at most twice
                
                for (const element of window.previewData.elements) {
                    if (element.type !== 'way' || !element.geometry || !element.tags) continue;
                    
                    const name = element.tags.name;
                    if (!name) continue;
                    
                    // Limit how many times the same name is shown
                    const currentCount = nameRenderCount.get(name) || 0;
                    if (currentCount >= MAX_NAME_RENDERS) continue;
                    
                    // Check if this feature type should show labels
                    const isBuilding = element.tags.building;
                    const highway = element.tags.highway;
                    const waterway = element.tags.waterway;
                    const natural = element.tags.natural;
                    const leisure = element.tags.leisure;
                    
                    // Determine feature type and zoom threshold
                    let minZoom = 20;  // Default: don't show
                    let fontSize = 10;
                    let bgColor = 'rgba(255, 217, 61, 0.85)';
                    
                    if (highway === 'motorway' || highway === 'trunk') {
                        minZoom = 5;
                        fontSize = window.previewZoom >= 10 ? 14 : 11;
                        bgColor = 'rgba(255, 107, 107, 0.85)';
                    } else if (highway === 'primary' || highway === 'secondary') {
                        minZoom = 7;
                        fontSize = window.previewZoom >= 12 ? 12 : 10;
                        bgColor = 'rgba(255, 217, 61, 0.85)';
                    } else if (highway === 'tertiary' || highway === 'residential') {
                        minZoom = 10;
                        fontSize = 9;
                        bgColor = 'rgba(255, 255, 255, 0.85)';
                    } else if (highway) {
                        minZoom = 15;
                        fontSize = 8;
                        bgColor = 'rgba(170, 170, 170, 0.85)';
                    } else if (waterway || (natural && (natural === 'water' || natural === 'coastline'))) {
                        minZoom = 8;
                        fontSize = window.previewZoom >= 12 ? 12 : 10;
                        bgColor = 'rgba(77, 171, 247, 0.85)';
                    } else if (leisure === 'park' || natural === 'wood') {
                        minZoom = 8;
                        fontSize = window.previewZoom >= 12 ? 12 : 10;
                        bgColor = 'rgba(105, 219, 124, 0.85)';
                    } else if (isBuilding) {
                        if (!buildingNamesChecked) continue;
                        minZoom = 12;
                        fontSize = window.previewZoom >= 15 ? 10 : 8;
                        bgColor = 'rgba(177, 151, 252, 0.85)';
                    } else {
                        if (nameDetailLevel === 0) continue;
                    }
                    
                    if (window.previewZoom < minZoom) continue;
                    
                    ctx.font = `${fontSize}px Arial`;
                        
                        // Calculate centroid of the feature
                        let sumLon = 0, sumLat = 0, count = 0;
                        for (const p of element.geometry) {
                            if (inSelection(p.lon, p.lat)) {
                                sumLon += p.lon;
                                sumLat += p.lat;
                                count++;
                            }
                        }
                        if (count === 0) continue;
                        
                        const cx = toCanvasX(sumLon / count);
                        const cy = toCanvasY(sumLat / count);
                        
                        // Skip if centroid is outside canvas
                        if (cx < 0 || cx > canvas.width || cy < 0 || cy > canvas.height) continue;
                        
                        // Truncate long names
                        const displayName = name.length > 20 ? name.substring(0, 18) + '...' : name;
                        const textWidth = ctx.measureText(displayName).width;
                        const textHeight = fontSize;
                        
                        // Skip if would overlap
                        if (wouldOverlap(cx, cy, textWidth, textHeight)) continue;
                        
                        // Draw label with background (bgColor already set above)
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(cx - textWidth/2 - 3, cy - textHeight/2 - 2, textWidth + 6, textHeight + 4);
                        
                        ctx.fillStyle = '#000';
                        ctx.fillText(displayName, cx, cy);
                        
                        // Record this label's position and increment name count
                        labelRects.push({ x: cx - textWidth/2, y: cy - textHeight/2, w: textWidth, h: textHeight });
                        nameRenderCount.set(name, (nameRenderCount.get(name) || 0) + 1);
                }
                
                console.log('Labels rendered:', labelRects.length);
            }
            
            // Draw bounds border (cyan) to show exact clip region
            ctx.strokeStyle = '#4cc9f0';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            const bx1 = toCanvasX(minLon), by1 = toCanvasY(maxLat);
            const bx2 = toCanvasX(maxLon), by2 = toCanvasY(minLat);
            ctx.strokeRect(bx1, by1, bx2 - bx1, by2 - by1);
            
            // Debug log bounds
            console.log('Preview bounds:', {minLat, maxLat, minLon, maxLon});
            console.log('Canvas clip rect:', {bx1, by1, width: bx2-bx1, height: by2-by1});
            
            window.previewFeatureCount = featureCount;
        }
        
        function zoomPreview(factor) {
            if (!window.hwmapData && !window.previewData) return;
            window.previewZoom *= factor;
            window.previewZoom = Math.max(0.5, Math.min(20.0, window.previewZoom)); // Limit 0.5x to 20x
            requestPreviewRender();
        }
        
        function resetPreviewZoom() {
            if (!window.hwmapData && !window.previewData) return;
            window.previewZoom = 1.0;
            window.previewPanX = 0;
            window.previewPanY = 0;
            requestPreviewRender();
        }
        
        // Pan support with mouse drag
        (function setupPreviewPan() {
            let isDragging = false;
            let lastX, lastY;
            
            const container = document.getElementById('previewContainer');
            if (!container) return;
            
            container.addEventListener('mousedown', (e) => {
                if (!window.hwmapData && !window.previewData) return;
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!isDragging || (!window.hwmapData && !window.previewData)) return;
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                window.previewPanX += dx;
                window.previewPanY += dy;
                lastX = e.clientX;
                lastY = e.clientY;
                requestPreviewRender();  // Throttled
            });
            
            container.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            container.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // Mouse wheel zoom with cursor tracking
            container.addEventListener('wheel', (e) => {
                if (!window.hwmapData && !window.previewData) return;
                e.preventDefault();
                
                const canvas = document.getElementById('previewCanvas');
                const rect = canvas.getBoundingClientRect();
                
                // Get mouse position relative to canvas center
                const mouseX = e.clientX - rect.left - rect.width / 2;
                const mouseY = e.clientY - rect.top - rect.height / 2;
                
                // Calculate zoom factor
                const factor = e.deltaY < 0 ? 1.1 : 0.9;
                const oldZoom = window.previewZoom;
                const newZoom = Math.max(0.5, Math.min(20.0, oldZoom * factor));
                
                // Adjust pan to keep mouse position stable
                if (newZoom !== oldZoom) {
                    const zoomRatio = newZoom / oldZoom;
                    window.previewPanX = mouseX + (window.previewPanX - mouseX) * zoomRatio;
                    window.previewPanY = mouseY + (window.previewPanY - mouseY) * zoomRatio;
                    window.previewZoom = newZoom;
                    requestPreviewRender();  // Throttled
                }
            });
        })();
        
        function extractMetadataFromData(data) {
            // Extract all named features for the Map Features panel
            const namedFeatures = {
                highways: [],
                roads: [],
                water: [],
                parks: [],
                railways: [],
                buildings: []
            };
            let totalMetadataBytes = 0;
            
            // Extract subway and bus route relations
            const subwayRoutes = [];
            const busRoutes = [];
            for (const el of (data.elements || [])) {
                if (el.type === 'relation' && el.tags) {
                    if (el.tags.route === 'subway') {
                        subwayRoutes.push({
                            ref: el.tags.ref || '?',
                            name: el.tags.name || 'Unknown',
                            colour: el.tags.colour || el.tags.color || '#da77f2',
                            network: el.tags.network || '',
                            operator: el.tags.operator || ''
                        });
                    } else if (el.tags.route === 'bus' || el.tags.route === 'trolleybus') {
                        busRoutes.push({
                            ref: el.tags.ref || '?',
                            name: el.tags.name || 'Unknown',
                            colour: el.tags.colour || el.tags.color || '#fab005',
                            network: el.tags.network || '',
                            operator: el.tags.operator || ''
                        });
                    }
                }
            }
            
            for (const el of (data.elements || [])) {
                if (el.type !== 'way' || !el.tags) continue;
                
                const name = el.tags.name;
                const ref = el.tags.ref;
                if (!name && !ref) continue;
                
                const label = ref ? (name ? `${ref} - ${name}` : ref) : name;
                const bytes = (label || '').length + 1;
                
                if (el.tags.highway) {
                    if (['motorway', 'trunk', 'motorway_link', 'trunk_link'].includes(el.tags.highway)) {
                        if (!namedFeatures.highways.find(f => f.label === label)) {
                            namedFeatures.highways.push({ label, ref, name, bytes });
                            totalMetadataBytes += bytes;
                        }
                    } else if (['primary', 'secondary', 'tertiary', 'residential'].includes(el.tags.highway)) {
                        if (!namedFeatures.roads.find(f => f.label === label)) {
                            namedFeatures.roads.push({ label, ref, name, bytes });
                            totalMetadataBytes += bytes;
                        }
                    }
                } else if (el.tags.natural === 'water' || el.tags.waterway) {
                    if (!namedFeatures.water.find(f => f.label === label)) {
                        namedFeatures.water.push({ label, ref, name, bytes });
                        totalMetadataBytes += bytes;
                    }
                } else if (el.tags.leisure === 'park' || el.tags.landuse === 'grass') {
                    if (!namedFeatures.parks.find(f => f.label === label)) {
                        namedFeatures.parks.push({ label, ref, name, bytes });
                        totalMetadataBytes += bytes;
                    }
                } else if (el.tags.railway) {
                    if (!namedFeatures.railways.find(f => f.label === label)) {
                        namedFeatures.railways.push({ label, ref, name, bytes });
                        totalMetadataBytes += bytes;
                    }
                } else if (el.tags.building) {
                    if (!namedFeatures.buildings.find(f => f.label === label)) {
                        namedFeatures.buildings.push({ label, ref, name, bytes });
                        totalMetadataBytes += bytes;
                    }
                }
            }
            
            // Add subway and bus routes to metadata size
            for (const r of subwayRoutes) {
                totalMetadataBytes += (r.name || '').length + (r.ref || '').length + 2;
            }
            for (const r of busRoutes) {
                totalMetadataBytes += (r.name || '').length + (r.ref || '').length + 2;
            }
            
            // Display Map Features panel
            const featuresPanel = document.getElementById('mapFeaturesPanel');
            const featuresList = document.getElementById('mapFeaturesList');
            const nameDetailLevel = parseInt(document.getElementById('nameDetail').value);
            const buildingNamesChecked = document.getElementById('buildingNames')?.checked || false;
            
            // Filter named features based on name detail level (matching conversion logic)
            let filteredHighways = [];
            let filteredRoads = [];
            let filteredWater = [];
            let filteredParks = [];
            let filteredRailways = [];
            let filteredBuildings = [];
            let filteredMetadataBytes = 0;
            
            if (nameDetailLevel >= 1) {
                filteredHighways = namedFeatures.highways;
                filteredMetadataBytes += namedFeatures.highways.reduce((sum, f) => sum + f.bytes, 0);
            }
            if (nameDetailLevel >= 2) {
                filteredRoads = namedFeatures.roads;
                filteredMetadataBytes += namedFeatures.roads.reduce((sum, f) => sum + f.bytes, 0);
            }
            if (nameDetailLevel >= 4) {
                filteredWater = namedFeatures.water;
                filteredParks = namedFeatures.parks;
                filteredRailways = namedFeatures.railways;
                filteredMetadataBytes += namedFeatures.water.reduce((sum, f) => sum + f.bytes, 0);
                filteredMetadataBytes += namedFeatures.parks.reduce((sum, f) => sum + f.bytes, 0);
                filteredMetadataBytes += namedFeatures.railways.reduce((sum, f) => sum + f.bytes, 0);
                // Add subway/bus routes at level 4
                for (const r of subwayRoutes) {
                    filteredMetadataBytes += (r.name || '').length + (r.ref || '').length + 2;
                }
            }
            if (buildingNamesChecked) {
                filteredBuildings = namedFeatures.buildings;
                filteredMetadataBytes += namedFeatures.buildings.reduce((sum, f) => sum + f.bytes, 0);
            }
            
            const totalFilteredFeatures = filteredHighways.length + filteredRoads.length + 
                filteredWater.length + filteredParks.length + filteredRailways.length + 
                filteredBuildings.length + (nameDetailLevel >= 4 ? subwayRoutes.length : 0);
            
            if (totalFilteredFeatures > 0 && (nameDetailLevel > 0 || buildingNamesChecked)) {
                const indexOverhead = totalFilteredFeatures * 2;  // 2 bytes per feature for name index
                const totalWithOverhead = filteredMetadataBytes + indexOverhead;
                
                document.getElementById('metadataSizeEst').textContent = 
                    `+${(totalWithOverhead / 1024).toFixed(1)} KB if included`;
                
                let html = '';
                const addSection = (title, items, color) => {
                    if (items.length === 0) return;
                    html += `<div style="margin-bottom:8px;">`;
                    html += `<div style="color:${color};font-weight:bold;margin-bottom:4px;">${title} (${items.length})</div>`;
                    html += `<div style="color:#aaa;padding-left:8px;">`;
                    const shown = items.slice(0, 10);
                    html += shown.map(f => `<div style="margin:1px 0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${f.label}">${f.label}</div>`).join('');
                    if (items.length > 10) {
                        html += `<div style="color:#666;font-style:italic;">...and ${items.length - 10} more</div>`;
                    }
                    html += `</div></div>`;
                };
                
                addSection('Highways', filteredHighways, '#ff6b6b');
                addSection('Roads', filteredRoads, '#ffd93d');
                addSection('Water', filteredWater, '#4dabf7');
                addSection('Parks', filteredParks, '#69db7c');
                addSection('Railways', filteredRailways, '#da77f2');
                addSection('Buildings', filteredBuildings, '#868e96');
                
                featuresList.innerHTML = html;
                featuresPanel.style.display = 'block';
                
                // Store for use in binary generation and size estimates
                window.extractedMetadata = {
                    namedFeatures,
                    subwayRoutes: subwayRoutes,
                    totalBytes: totalWithOverhead
                };
            } else {
                featuresPanel.style.display = 'none';
                window.extractedMetadata = null;
            }
            
            // Display subway routes if any found
            const routesList = document.getElementById('subwayRoutesList');
            if (subwayRoutes.length > 0) {
                subwayRoutes.sort((a, b) => a.ref.localeCompare(b.ref, undefined, {numeric: true}));
                const seen = new Set();
                const uniqueRoutes = subwayRoutes.filter(r => {
                    if (seen.has(r.ref)) return false;
                    seen.add(r.ref);
                    return true;
                });
                
                routesList.innerHTML = '<div style="color:#4cc9f0;margin-bottom:4px;">Detected Routes:</div>' +
                    uniqueRoutes.map(r => 
                        `<div style="display:flex;align-items:center;gap:6px;margin:2px 0;">` +
                        `<span style="background:${r.colour};color:#fff;padding:1px 6px;border-radius:3px;font-weight:bold;min-width:24px;text-align:center;">${r.ref}</span>` +
                        `<span style="color:#aaa;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${r.name}">${r.name}</span>` +
                        `</div>`
                    ).join('');
                routesList.style.display = 'block';
            } else {
                routesList.style.display = 'none';
            }
            
            // Display bus routes if any found
            const busRoutesList = document.getElementById('busRoutesList');
            if (busRoutes.length > 0 && busRoutesList) {
                busRoutes.sort((a, b) => a.ref.localeCompare(b.ref, undefined, {numeric: true}));
                const seen = new Set();
                const uniqueBusRoutes = busRoutes.filter(r => {
                    if (seen.has(r.ref)) return false;
                    seen.add(r.ref);
                    return true;
                });
                
                busRoutesList.innerHTML = '<div style="color:#fab005;margin-bottom:4px;">Detected Bus Routes:</div>' +
                    uniqueBusRoutes.slice(0, 15).map(r => 
                        `<div style="display:flex;align-items:center;gap:6px;margin:2px 0;">` +
                        `<span style="background:${r.colour};color:#000;padding:1px 6px;border-radius:3px;font-weight:bold;min-width:24px;text-align:center;">${r.ref}</span>` +
                        `<span style="color:#aaa;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${r.name}">${r.name}</span>` +
                        `</div>`
                    ).join('') + (uniqueBusRoutes.length > 15 ? `<div style="color:#666;font-style:italic;">...and ${uniqueBusRoutes.length - 15} more</div>` : '');
                busRoutesList.style.display = 'block';
            } else if (busRoutesList) {
                busRoutesList.style.display = 'none';
            }
            
            return { namedFeatures, subwayRoutes, totalMetadataBytes };
        }
        
        async function previewMap() {
            if (!selectedBounds) {
                setStatus('error', 'Please select an area first');
                return;
            }

            const runId = ++previewRunId;
            const isStale = () => runId !== previewRunId;
            
            const btn = document.getElementById('previewBtn');
            btn.disabled = true;
            btn.textContent = '⏳ Loading...';
            setStatus('working', 'Fetching preview from OpenStreetMap...');
            
            try {
                setStatus('working', 'Building query...');
                const query = buildOverpassQuery();
                
                setStatus('working', 'Fetching data from OpenStreetMap...');
                const response = await fetchWithRetry(OVERPASS_SERVERS[currentServerIndex], {
                    method: 'POST',
                    body: query
                });

                if (isStale()) return;
                
                setStatus('working', 'Parsing response...');
                const data = await response.json();

                if (isStale()) return;
                
                setStatus('working', 'Extracting metadata...');
                // Extract metadata using shared function
                extractMetadataFromData(data);
                
                // CLIP ALL GEOMETRY TO BOUNDS (and polygon if drawn) before storing
                const bounds = selectedBounds;
                const minLat = bounds.getSouth(), maxLat = bounds.getNorth();
                const minLon = bounds.getWest(), maxLon = bounds.getEast();
                
                console.log('=== CLIPPING DEBUG ===');
                console.log('Clip bounds:', {minLat, maxLat, minLon, maxLon});
                console.log('Polygon selection:', selectedPolygon ? selectedPolygon.length + ' points' : 'none (rectangle)');
                
                // Point-in-polygon test using ray casting
                function pointInPolygon(lon, lat, polygon) {
                    if (!polygon || polygon.length < 3) return true; // No polygon = use bounds only
                    let inside = false;
                    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                        const yi = polygon[i][0], xi = polygon[i][1]; // [lat, lng]
                        const yj = polygon[j][0], xj = polygon[j][1];
                        if (((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
                            inside = !inside;
                        }
                    }
                    return inside;
                }
                
                // Check if point is inside selection (polygon or bounds)
                function inSelection(lon, lat) {
                    // First check bounding box (fast)
                    if (lon < minLon || lon > maxLon || lat < minLat || lat > maxLat) return false;
                    // Then check polygon if exists
                    if (selectedPolygon) {
                        return pointInPolygon(lon, lat, selectedPolygon);
                    }
                    return true;
                }
                
                const clippedElements = [];
                let stats = {total: 0, kept: 0, dropped: 0, badAfter: 0};
                
                for (const el of (data.elements || [])) {
                    if (el.type !== 'way' || !el.geometry || el.geometry.length < 2) continue;
                    
                    // STRICT: Only keep points inside selection (polygon or bounds)
                    const filteredGeom = [];
                    for (const p of el.geometry) {
                        stats.total++;
                        if (inSelection(p.lon, p.lat)) {
                            filteredGeom.push({lon: p.lon, lat: p.lat});
                            stats.kept++;
                        } else {
                            stats.dropped++;
                        }
                    }
                    
                    if (filteredGeom.length >= 2) {
                        clippedElements.push({...el, geometry: filteredGeom});
                    }
                }
                
                // VERIFY no bad points remain
                for (const el of clippedElements) {
                    for (const p of el.geometry) {
                        if (!inSelection(p.lon, p.lat)) {
                            stats.badAfter++;
                            console.error('BAD POINT AFTER FILTER:', p);
                        }
                    }
                }
                
                console.log('Stats:', stats);
                console.log('Elements kept:', clippedElements.length);
                
                setStatus('working', `Clipped ${clippedElements.length} elements. Simplifying...`);
                
                // Apply simplification to preview data (same as map generation)
                const simplifiedElements = [];
                // Use maximum detail (no global quality clamping) - type-specific simplification handles reduction
                const tolerance = 0.00001; // Finest tolerance for maximum detail
                const maxPointsPerFeature = 2048; // Effectively unlimited - type-specific simplification handles limits
                
                for (const el of clippedElements) {
                    if (!el.geometry || el.geometry.length < 2) continue;
                    
                    // Determine feature type
                    const featureType = getFeatureType(el.tags);
                    if (!featureType) continue;
                    
                    // Apply simplification based on feature type and settings
                    let points = simplifyPoints(el.geometry, tolerance);
                    if (points.length < 2) continue;
                    
                    // === LARGE BUILDINGS ONLY FILTER ===
                    const buildingsLargeOnlyChecked = document.getElementById('buildingsLargeOnly')?.checked;
                    if (featureType === PREVIEW_TYPES.BUILDING && buildingsLargeOnlyChecked) {
                        const minFloors = parseInt(document.getElementById('buildingMinFloors')?.value || 3);
                        const minAreaM2 = parseInt(document.getElementById('buildingMinArea')?.value || 200);
                        // Check building:levels tag first
                        const levels = parseInt(el.tags?.['building:levels'] || '0');
                        if (levels < minFloors) {
                            // Calculate polygon area in m² to filter by size
                            let areaM2 = 0;
                            if (points.length >= 3) {
                                let sum = 0;
                                for (let i = 0; i < points.length; i++) {
                                    const j = (i + 1) % points.length;
                                    const lat1 = points[i].lat * Math.PI / 180;
                                    const lat2 = points[j].lat * Math.PI / 180;
                                    const lon1 = points[i].lon * Math.PI / 180;
                                    const lon2 = points[j].lon * Math.PI / 180;
                                    const x1 = lon1 * Math.cos((lat1 + lat2) / 2) * 6371000;
                                    const y1 = lat1 * 6371000;
                                    const x2 = lon2 * Math.cos((lat1 + lat2) / 2) * 6371000;
                                    const y2 = lat2 * 6371000;
                                    sum += (x1 * y2 - x2 * y1);
                                }
                                areaM2 = Math.abs(sum / 2);
                            }
                            // Skip buildings smaller than threshold
                            if (areaM2 < minAreaM2) continue;
                        }
                    }
                    
                    // Apply type-specific simplification using specialized algorithms
                    // Highways - Motorways
                    const simplifyMotorwaysChecked = document.getElementById('simplifyMotorways')?.checked;
                    const motorwaysSimplifyPts = parseInt(document.getElementById('motorwaysSimplifyPoints')?.value || 15);
                    if (featureType === PREVIEW_TYPES.ROAD_HIGHWAY && simplifyMotorwaysChecked && 
                        el.tags?.highway === 'motorway' && points.length > motorwaysSimplifyPts) {
                        points = simplifyRoad(points, motorwaysSimplifyPts, tolerance * 2);
                    }
                    
                    // Highways - Trunk
                    const simplifyTrunkChecked = document.getElementById('simplifyTrunk')?.checked;
                    const trunkSimplifyPts = parseInt(document.getElementById('trunkSimplifyPoints')?.value || 12);
                    if (featureType === PREVIEW_TYPES.ROAD_HIGHWAY && simplifyTrunkChecked && 
                        el.tags?.highway === 'trunk' && points.length > trunkSimplifyPts) {
                        points = simplifyRoad(points, trunkSimplifyPts, tolerance * 2);
                    }
                    
                    // Roads - Primary
                    const simplifyPrimaryChecked = document.getElementById('simplifyPrimary')?.checked;
                    const primarySimplifyPts = parseInt(document.getElementById('primarySimplifyPoints')?.value || 10);
                    if (featureType === PREVIEW_TYPES.ROAD_MAJOR && simplifyPrimaryChecked && 
                        el.tags?.highway === 'primary' && points.length > primarySimplifyPts) {
                        points = simplifyRoad(points, primarySimplifyPts, tolerance * 2);
                    }
                    
                    // Roads - Secondary
                    const simplifySecondaryChecked = document.getElementById('simplifySecondary')?.checked;
                    const secondarySimplifyPts = parseInt(document.getElementById('secondarySimplifyPoints')?.value || 8);
                    if (featureType === PREVIEW_TYPES.ROAD_MAJOR && simplifySecondaryChecked && 
                        el.tags?.highway === 'secondary' && points.length > secondarySimplifyPts) {
                        points = simplifyRoad(points, secondarySimplifyPts, tolerance * 2);
                    }
                    
                    // Roads - Tertiary
                    const simplifyTertiaryChecked = document.getElementById('simplifyTertiary')?.checked;
                    const tertiarySimplifyPts = parseInt(document.getElementById('tertiarySimplifyPoints')?.value || 6);
                    if (featureType === PREVIEW_TYPES.ROAD_MINOR && simplifyTertiaryChecked && 
                        el.tags?.highway === 'tertiary' && points.length > tertiarySimplifyPts) {
                        points = simplifyRoad(points, tertiarySimplifyPts, tolerance * 2);
                    }
                    
                    // Roads - Residential
                    const simplifyResidentialChecked = document.getElementById('simplifyResidential')?.checked;
                    const residentialSimplifyPts = parseInt(document.getElementById('residentialSimplifyPoints')?.value || 4);
                    if (featureType === PREVIEW_TYPES.ROAD_MINOR && simplifyResidentialChecked && 
                        el.tags?.highway === 'residential' && points.length > residentialSimplifyPts) {
                        points = simplifyRoad(points, residentialSimplifyPts, tolerance * 3);
                    }
                    
                    // Roads - Service
                    const simplifyServiceChecked = document.getElementById('simplifyService')?.checked;
                    const serviceSimplifyPts = parseInt(document.getElementById('serviceSimplifyPoints')?.value || 4);
                    if (featureType === PREVIEW_TYPES.ROAD_MINOR && simplifyServiceChecked && 
                        el.tags?.highway === 'service' && points.length > serviceSimplifyPts) {
                        points = simplifyRoad(points, serviceSimplifyPts, tolerance * 3);
                    }
                    
                    // Paths (with min length filter)
                    const simplifyPathsChecked = document.getElementById('simplifyPaths')?.checked;
                    const pathsSimplifyPts = parseInt(document.getElementById('pathsSimplifyPoints')?.value || 6);
                    if (featureType === PREVIEW_TYPES.PATH) {
                        // Min length filter (independent of simplification)
                        const minPathLength = parseInt(document.getElementById('pathMinLength')?.value || 0);
                        if (minPathLength > 0) {
                            let pathLengthM = 0;
                            for (let i = 1; i < points.length; i++) {
                                const dLat = (points[i].lat - points[i-1].lat) * 111000;
                                const dLon = (points[i].lon - points[i-1].lon) * 111000 * Math.cos(points[i].lat * Math.PI / 180);
                                pathLengthM += Math.sqrt(dLat*dLat + dLon*dLon);
                            }
                            if (pathLengthM < minPathLength) continue;
                        }
                        // Simplification
                        if (simplifyPathsChecked && points.length > pathsSimplifyPts) {
                            points = simplifyRoad(points, pathsSimplifyPts, tolerance * 3);
                        }
                    }
                    
                    // Bus routes
                    const simplifyBusChecked = document.getElementById('simplifyBus')?.checked;
                    const busSimplifyPts = parseInt(document.getElementById('busSimplifyPoints')?.value || 12);
                    if (featureType === PREVIEW_TYPES.BUS && simplifyBusChecked && points.length > busSimplifyPts) {
                        points = simplifyRoad(points, busSimplifyPts, tolerance * 3);
                    }
                    
                    // Rail routes
                    const simplifyRailChecked = document.getElementById('simplifyRail')?.checked;
                    const railSimplifyPts = parseInt(document.getElementById('railSimplifyPoints')?.value || 12);
                    if (featureType === PREVIEW_TYPES.RAILWAY && simplifyRailChecked && points.length > railSimplifyPts) {
                        points = simplifyRoad(points, railSimplifyPts, tolerance * 2);
                    }
                    
                    // Ferry routes
                    const simplifyFerryChecked = document.getElementById('simplifyFerry')?.checked;
                    const ferrySimplifyPts = parseInt(document.getElementById('ferrySimplifyPoints')?.value || 12);
                    if (featureType === PREVIEW_TYPES.FERRY && simplifyFerryChecked && points.length > ferrySimplifyPts) {
                        points = simplifyRoad(points, ferrySimplifyPts, tolerance * 2);
                    }
                    
                    // Transit stations
                    const simplifyStationsChecked = document.getElementById('simplifyStations')?.checked;
                    const stationsSimplifyPts = parseInt(document.getElementById('stationsSimplifyPoints')?.value || 12);
                    if (featureType === PREVIEW_TYPES.STATION && simplifyStationsChecked && points.length > stationsSimplifyPts) {
                        points = simplifyRoad(points, stationsSimplifyPts, tolerance * 2);
                    }
                    
                    // Bridges
                    const simplifyBridgesChecked = document.getElementById('simplifyBridges')?.checked;
                    const bridgesSimplifyPts = parseInt(document.getElementById('bridgesSimplifyPoints')?.value || 12);
                    if (el.tags?.bridge && simplifyBridgesChecked && points.length > bridgesSimplifyPts) {
                        points = simplifyRoad(points, bridgesSimplifyPts, tolerance * 2);
                    }
                    
                    // Industrial areas
                    const simplifyIndustrialChecked = document.getElementById('simplifyIndustrial')?.checked;
                    const industrialSimplifyPts = parseInt(document.getElementById('industrialSimplifyPoints')?.value || 12);
                    if (featureType === PREVIEW_TYPES.BUILDING && el.tags?.landuse === 'industrial' && simplifyIndustrialChecked && points.length > industrialSimplifyPts) {
                        points = simplifyRoad(points, industrialSimplifyPts, tolerance * 2);
                    }
                    
                    // Commercial areas
                    const simplifyCommercialChecked = document.getElementById('simplifyCommercial')?.checked;
                    const commercialSimplifyPts = parseInt(document.getElementById('commercialSimplifyPoints')?.value || 12);
                    if (featureType === PREVIEW_TYPES.BUILDING && (el.tags?.landuse === 'commercial' || el.tags?.landuse === 'retail') && simplifyCommercialChecked && points.length > commercialSimplifyPts) {
                        points = simplifyRoad(points, commercialSimplifyPts, tolerance * 2);
                    }
                    
                    // Residential areas
                    const simplifyResidentialAreaChecked = document.getElementById('simplifyResidentialArea')?.checked;
                    const residentialAreaSimplifyPts = parseInt(document.getElementById('residentialAreaSimplifyPoints')?.value || 12);
                    if (featureType === PREVIEW_TYPES.BUILDING && el.tags?.landuse === 'residential' && simplifyResidentialAreaChecked && points.length > residentialAreaSimplifyPts) {
                        points = simplifyRoad(points, residentialAreaSimplifyPts, tolerance * 2);
                    }
                    
                    // Type-specific simplification handles all reduction based on checkbox state
                    // No forced global simplification
                    
                    if (points.length >= 2) {
                        simplifiedElements.push({...el, geometry: points});
                    }
                }
                
                console.log('After simplification:', simplifiedElements.length, 'features');
                
                setStatus('working', `Simplified to ${simplifiedElements.length} features. Fetching expanded water data...`);
                
                // EXPANDED BOUNDS APPROACH: Fetch coastlines AND water bodies with ~10km buffer
                // This ensures proper connectivity for water/land determination
                const WATER_BUFFER = 0.1; // ~10km buffer
                const expandedBounds = {
                    minLat: minLat - WATER_BUFFER,
                    maxLat: maxLat + WATER_BUFFER,
                    minLon: minLon - WATER_BUFFER,
                    maxLon: maxLon + WATER_BUFFER
                };
                
                // Fetch coastlines AND water bodies with expanded bounds
                let waterData = data.elements;
                const fetchCoastlines = document.getElementById('coastlines')?.checked;
                const fetchWaterBodies = document.getElementById('waterBodies')?.checked;
                
                if (fetchCoastlines || fetchWaterBodies) {
                    try {
                        // Build query for all water-related features with expanded bounds
                        let waterQuery = `[out:json][bbox:${expandedBounds.minLat},${expandedBounds.minLon},${expandedBounds.maxLat},${expandedBounds.maxLon}];(\n`;
                        
                        if (fetchCoastlines) {
                            waterQuery += `way["natural"="coastline"];\n`;
                        }
                        if (fetchWaterBodies) {
                            // All water area polygons
                            waterQuery += `way["natural"="water"];\n`;
                            waterQuery += `relation["natural"="water"];\n`;
                            waterQuery += `way["water"];\n`;
                            waterQuery += `relation["water"];\n`;
                            waterQuery += `way["waterway"="riverbank"];\n`;
                            waterQuery += `relation["waterway"="riverbank"];\n`;
                            waterQuery += `way["waterway"="dock"];\n`;
                            waterQuery += `way["landuse"~"basin|reservoir"];\n`;
                            waterQuery += `relation["natural"~"bay|strait"];\n`;
                            waterQuery += `way["harbour"];\n`;
                        }
                        waterQuery += `);out geom;`;
                        
                        console.log('[WATER] Fetching with expanded bounds:', expandedBounds);
                        const waterResponse = await fetchWithRetry(OVERPASS_SERVERS[currentServerIndex], {
                            method: 'POST',
                            body: waterQuery
                        });

                        if (isStale()) return;
                        const expandedWaterData = await waterResponse.json();

                        if (isStale()) return;
                        console.log('[WATER] Expanded fetch returned:', expandedWaterData.elements?.length || 0, 'water features');
                        
                        // Merge expanded water data with original (replace water features)
                        // But preserve coastlines from original if not fetching them expanded
                        const isWaterFeature = (el) => {
                            if (el.type !== 'way' && el.type !== 'relation') return false;
                            const tags = el.tags || {};
                            // Don't filter out coastlines if we're not fetching them expanded
                            // (they need to stay in waterData for processCoastlines)
                            if (tags.natural === 'coastline' && !fetchCoastlines) return false;
                            return tags.natural === 'coastline' || 
                                   tags.natural === 'water' ||
                                   tags.natural === 'bay' ||
                                   tags.natural === 'strait' ||
                                   tags.water ||
                                   tags.waterway === 'riverbank' ||
                                   tags.waterway === 'dock' ||
                                   tags.landuse === 'basin' ||
                                   tags.landuse === 'reservoir' ||
                                   tags.harbour;
                        };
                        const nonWaterElements = data.elements.filter(el => !isWaterFeature(el));
                        waterData = [...nonWaterElements, ...(expandedWaterData.elements || [])];
                    } catch (e) {
                        console.warn('[WATER] Expanded fetch failed, using original bounds:', e.message);
                    }
                }
                
                setStatus('working', 'Processing water features with expanded context...');
                
                // Process coastlines with EXPANDED bounds for correct polygon creation
                // Then clip results to USER's actual selection
                const userBounds = {minLat, maxLat, minLon, maxLon};
                const coastlineResult = processCoastlines(waterData, expandedBounds, userBounds);
                const coastlineWaterPolygons = coastlineResult?.water || [];
                console.log('Coastline water polygons created:', coastlineWaterPolygons.length);
                
                setStatus('working', `Created ${coastlineWaterPolygons.length} water polygons. Rendering...`);
                
                // TRUE PREVIEW: Generate .hwmap binary, parse it back, and render exactly like device
                // This ensures preview matches what you'll see on the device web viewer
                
                setStatus('working', 'Generating binary map data...');
                
                // Generate the .hwmap binary using the SAME expanded water/coastline context
                const hwmapPreviewData = { ...data, elements: waterData };
                const hwmapResult = convertToHWMap(hwmapPreviewData, {
                    coastlineProcessingBounds: expandedBounds,
                    coastlineClipBounds: userBounds
                });

                if (isStale()) return;
                
                setStatus('working', 'Parsing binary for preview...');
                
                // Parse the binary back into renderable structure
                const parsedMap = await parseHWMapBlob(hwmapResult.blob);

                if (isStale()) return;
                
                // Store for rendering AND for download
                window.hwmapData = parsedMap;
                window.hwmapBlob = hwmapResult.blob;
                window.hwmapFilename = hwmapResult.filename || 'map.hwmap';
                window.previewZoom = 1.0;
                window.previewPanX = 0;
                window.previewPanY = 0;
                
                // Display actual results from generation
                displayActualResults(hwmapResult);
                
                // Show preview panel FIRST so canvas has proper dimensions
                document.getElementById('previewPanel').classList.add('active');
                
                // Render after panel is visible (use requestAnimationFrame to ensure layout is complete)
                requestAnimationFrame(() => {
                    if (isStale()) return;
                    renderPreview();
                    document.getElementById('featureCount').textContent = parsedMap.features.length;
                    const mode = document.getElementById('previewModeGranular')?.checked ? 'Granular' : 'Device';
                    setStatus('ready', mode + ' Preview: ' + parsedMap.features.length + ' features.');
                    
                    // Update stats
                    updateStats();
                    
                    // Collapse sidebar sections
                    collapseAllSections();
                    
                    // Enable download - change button to show both options
                    btn.disabled = false;
                    btn.textContent = '⬇️ Download Map';
                    btn.onclick = downloadPreviewedMap;
                });
                
            } catch (error) {
                setStatus('error', 'Preview error: ' + error.message);
                console.error(error);
                btn.disabled = false;
                btn.textContent = '👁️ Preview Selection';
            }
        }
        
        function downloadPreviewedMap() {
            if (!window.hwmapBlob) {
                setStatus('error', 'No previewed map to download. Preview first.');
                return;
            }
            const url = URL.createObjectURL(window.hwmapBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.hwmapFilename || 'map.hwmap';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            setStatus('ready', 'Downloaded: ' + (window.hwmapFilename || 'map.hwmap'));
        }
        
        function getPreviewStyle(tags) {
            if (!tags) return null;
            
            // Check granular layer toggles
            const layers = {
                // Roads
                motorways: document.getElementById('layerMotorways')?.checked ?? true,
                trunk: document.getElementById('layerTrunk')?.checked ?? true,
                primary: document.getElementById('layerPrimary')?.checked ?? true,
                secondary: document.getElementById('layerSecondary')?.checked ?? true,
                tertiary: document.getElementById('layerTertiary')?.checked ?? true,
                residential: document.getElementById('layerResidential')?.checked ?? true,
                service: document.getElementById('layerService')?.checked ?? true,
                // Paths
                footways: document.getElementById('layerFootways')?.checked ?? true,
                cycleways: document.getElementById('layerCycleways')?.checked ?? true,
                tracks: document.getElementById('layerTracks')?.checked ?? true,
                // Water
                lakes: document.getElementById('layerLakes')?.checked ?? true,
                rivers: document.getElementById('layerRivers')?.checked ?? true,
                coastlines: document.getElementById('layerCoastlines')?.checked ?? true,
                // Nature
                parks: document.getElementById('layerParks')?.checked ?? true,
                forests: document.getElementById('layerForests')?.checked ?? true,
                grassland: document.getElementById('layerGrassland')?.checked ?? true,
                // Infrastructure
                railway: document.getElementById('layerRailway')?.checked ?? true,
                subways: document.getElementById('layerSubways')?.checked ?? true,
                bus: document.getElementById('layerBus')?.checked ?? true,
                ferry: document.getElementById('layerFerry')?.checked ?? true,
                stations: document.getElementById('layerStations')?.checked ?? true,
                buildings: document.getElementById('layerBuildings')?.checked ?? true,
                industrial: document.getElementById('layerIndustrial')?.checked ?? true,
                commercial: document.getElementById('layerCommercial')?.checked ?? true,
                residentialArea: document.getElementById('layerResidentialArea')?.checked ?? true
            };
            
            // Roads - granular checks
            if (tags.highway) {
                if (['motorway', 'motorway_link'].includes(tags.highway)) {
                    return layers.motorways ? PREVIEW_COLORS.highway : null;
                }
                if (['trunk', 'trunk_link'].includes(tags.highway)) {
                    return layers.trunk ? { ...PREVIEW_COLORS.highway, color: '#ff8787' } : null;
                }
                if (['primary', 'primary_link'].includes(tags.highway)) {
                    return layers.primary ? PREVIEW_COLORS.major : null;
                }
                if (['secondary', 'secondary_link'].includes(tags.highway)) {
                    return layers.secondary ? { ...PREVIEW_COLORS.major, color: '#ffe066' } : null;
                }
                if (['tertiary', 'tertiary_link', 'unclassified'].includes(tags.highway)) {
                    return layers.tertiary ? PREVIEW_COLORS.minor : null;
                }
                if (['residential', 'living_street'].includes(tags.highway)) {
                    return layers.residential ? { ...PREVIEW_COLORS.minor, color: '#ddd' } : null;
                }
                if (tags.highway === 'service') {
                    return layers.service ? { ...PREVIEW_COLORS.minor, color: '#bbb', weight: 1 } : null;
                }
                // Paths
                if (['footway', 'path', 'pedestrian', 'steps'].includes(tags.highway)) {
                    return layers.footways ? PREVIEW_COLORS.path : null;
                }
                if (tags.highway === 'cycleway') {
                    return layers.cycleways ? { ...PREVIEW_COLORS.path, color: '#74c0fc' } : null;
                }
                if (['track', 'bridleway'].includes(tags.highway)) {
                    return layers.tracks ? { ...PREVIEW_COLORS.path, color: '#a9e34b' } : null;
                }
            }
            
            // Railways
            if (tags.railway) {
                if (['station', 'halt'].includes(tags.railway)) {
                    return layers.stations ? PREVIEW_COLORS.station : null;
                }
                if (['subway', 'light_rail', 'tram'].includes(tags.railway)) {
                    return layers.subways ? { ...PREVIEW_COLORS.railway, color: '#be4bdb' } : null;
                }
                return layers.railway ? PREVIEW_COLORS.railway : null;
            }
            
            // Transit routes
            if (tags.route === 'bus' || tags.route === 'trolleybus') return layers.bus ? PREVIEW_COLORS.bus : null;
            if (tags.route === 'ferry') return layers.ferry ? PREVIEW_COLORS.ferry : null;
            if (tags.amenity === 'bus_station' || tags.amenity === 'ferry_terminal') return layers.stations ? PREVIEW_COLORS.station : null;
            
            // Water - granular checks
            if (tags.natural === 'water' || tags.natural === 'bay' || tags.natural === 'strait' ||
                tags.water || tags.harbour || tags.place === 'sea' ||
                tags.waterway === 'riverbank' || tags.waterway === 'dock' ||
                tags.landuse === 'basin' || tags.landuse === 'reservoir') {
                return layers.lakes ? PREVIEW_COLORS.water : null;
            }
            if (tags.waterway && ['river', 'stream', 'canal', 'drain', 'ditch'].includes(tags.waterway)) {
                return layers.rivers ? { ...PREVIEW_COLORS.water, isPolygon: false, weight: 2 } : null;
            }
            if (tags.natural === 'coastline') {
                return layers.coastlines ? { ...PREVIEW_COLORS.water, color: '#1c7ed6' } : null;
            }
            
            // Nature - granular checks (expanded coverage)
            if (tags.leisure === 'park' || tags.leisure === 'garden' || tags.leisure === 'recreation_ground' ||
                tags.leisure === 'playground' || tags.leisure === 'golf_course' || tags.leisure === 'nature_reserve' ||
                tags.landuse === 'village_green' || tags.landuse === 'allotments' ||
                tags.landuse === 'recreation_ground') {
                return layers.parks ? PREVIEW_COLORS.park : null;
            }
            if (tags.natural === 'wood' || tags.landuse === 'forest' || tags.landuse === 'wood') {
                return layers.forests ? { ...PREVIEW_COLORS.park, color: '#2f9e44', fillColor: '#1e7c2e' } : null;
            }
            if (tags.landuse === 'grass' || tags.natural === 'grassland' || tags.landuse === 'meadow' ||
                tags.landuse === 'grassland' || tags.landuse === 'farmland' ||
                tags.natural === 'heath' || tags.natural === 'scrub') {
                return layers.grassland ? { ...PREVIEW_COLORS.park, color: '#8fbc8f', fillColor: '#6b8e6b' } : null;
            }
            
            // Landuse areas - industrial, commercial, residential
            if (tags.landuse === 'industrial') {
                return layers.industrial ? { color: '#adb5bd', weight: 1, fillColor: '#495057', fillOpacity: 0.3, isPolygon: true } : null;
            }
            if (tags.landuse === 'commercial' || tags.landuse === 'retail') {
                return layers.commercial ? { color: '#ced4da', weight: 1, fillColor: '#6c757d', fillOpacity: 0.3, isPolygon: true } : null;
            }
            if (tags.landuse === 'residential') {
                return layers.residentialArea ? { color: '#dee2e6', weight: 1, fillColor: '#adb5bd', fillOpacity: 0.2, isPolygon: true } : null;
            }
            
            // Other landuse (fallback for parks toggle)
            if (tags.landuse) {
                return layers.parks ? PREVIEW_COLORS.park : null;
            }
            
            // Buildings
            if (tags.building) return layers.buildings ? PREVIEW_COLORS.building : null;
            
            return null;
        }
        
        // =============================================================================
        // MAP GENERATION
        // =============================================================================
        
        // Debug mode - set to true to enable verbose logging
        const DEBUG = true;

        const LOG_LEVEL = 1;

        function verboseLog(...args) {
            if (DEBUG && LOG_LEVEL >= 2) console.log(...args);
        }
        
        function debugLog(category, message, data = null) {
            if (!DEBUG) return;
            const timestamp = new Date().toISOString().substr(11, 12);
            const prefix = `[${timestamp}] [${category}]`;
            if (data !== null) {
                console.log(prefix, message, data);
            } else {
                console.log(prefix, message);
            }
        }
        
        // =============================================================================
        // COASTLINE POLYGON PROCESSOR
        // Converts linear coastline segments into filled water polygons
        // OSM coastlines have water on the RIGHT side when following the direction
        // =============================================================================
        
        function processCoastlines(elements, bounds, clipBounds = null) {
            // bounds = expanded bounds for processing (connectivity)
            // clipBounds = user's actual selection to clip results to (optional)
            const EPSILON = 0.00001;  // ~1 meter tolerance for point matching
            const finalClipBounds = clipBounds || bounds;  // Use clipBounds if provided
            
            // RAW DATA: Log input bounds
            verboseLog(`[RAW INPUT] ========== processCoastlines START ==========`);
            verboseLog(`[RAW INPUT] elements: ${elements.length}`);
            verboseLog(`[RAW INPUT] bounds (expanded): minLat=${bounds.minLat}, maxLat=${bounds.maxLat}, minLon=${bounds.minLon}, maxLon=${bounds.maxLon}`);
            verboseLog(`[RAW INPUT] clipBounds (user): ${clipBounds ? `minLat=${clipBounds.minLat}, maxLat=${clipBounds.maxLat}, minLon=${clipBounds.minLon}, maxLon=${clipBounds.maxLon}` : 'null'}`);
            verboseLog(`[RAW INPUT] finalClipBounds: minLat=${finalClipBounds.minLat}, maxLat=${finalClipBounds.maxLat}, minLon=${finalClipBounds.minLon}, maxLon=${finalClipBounds.maxLon}`);
            
            // Extract coastline segments
            const coastlineSegments = [];

            const coastlineWays = [];
            for (const el of elements) {
                if (el.type === 'way' && el.tags?.natural === 'coastline' && el.geometry) {
                    coastlineWays.push(el);
                }
            }
            coastlineWays.sort((a, b) => {
                const ai = typeof a.id === 'number' ? a.id : Number.POSITIVE_INFINITY;
                const bi = typeof b.id === 'number' ? b.id : Number.POSITIVE_INFINITY;
                if (ai !== bi) return ai - bi;
                const as = String(a.id ?? '');
                const bs = String(b.id ?? '');
                return as.localeCompare(bs);
            });
            for (const el of coastlineWays) {
                coastlineSegments.push(el.geometry.map(p => ({ lat: p.lat, lon: p.lon })));
            }
            
            if (coastlineSegments.length === 0) {
                verboseLog(`[RAW INPUT] No coastline segments found, returning empty`);
                return [];
            }
            
            debugLog('COAST', `Found ${coastlineSegments.length} coastline segments`);
            
            // RAW DATA: Log each coastline segment
            verboseLog(`[RAW SEGMENTS] ========== ALL ${coastlineSegments.length} COASTLINE SEGMENTS ==========`);
            if (DEBUG && LOG_LEVEL >= 2) {
                coastlineSegments.forEach((seg, i) => {
                    const lats = seg.map(p => p.lat);
                    const lons = seg.map(p => p.lon);
                    console.log(`  [RAW SEG ${i}] pts=${seg.length}, lat=${Math.min(...lats).toFixed(6)}-${Math.max(...lats).toFixed(6)}, lon=${Math.min(...lons).toFixed(6)}-${Math.max(...lons).toFixed(6)}`);
                    console.log(`    first: (${seg[0].lat.toFixed(6)}, ${seg[0].lon.toFixed(6)})`);
                    console.log(`    last: (${seg[seg.length-1].lat.toFixed(6)}, ${seg[seg.length-1].lon.toFixed(6)})`);
                });
                console.log(`[RAW SEGMENTS] ============================================`);
            }
            
            // Connect segments into continuous paths
            const connectedPaths = [];
            const used = new Set();
            
            function pointsMatch(p1, p2) {
                return Math.abs(p1.lat - p2.lat) < EPSILON && Math.abs(p1.lon - p2.lon) < EPSILON;
            }
            
            // Preserve OSM coastline direction.
            // OSM coastline ways are oriented such that water is on the RIGHT.
            // Reversing individual segments breaks that invariant and can invert land/water.
            function findForwardConnectingSegment(endPoint) {
                for (let i = 0; i < coastlineSegments.length; i++) {
                    if (used.has(i)) continue;
                    const seg = coastlineSegments[i];
                    if (pointsMatch(endPoint, seg[0])) return i;
                }
                return null;
            }
            function findBackwardConnectingSegment(startPoint) {
                for (let i = 0; i < coastlineSegments.length; i++) {
                    if (used.has(i)) continue;
                    const seg = coastlineSegments[i];
                    if (pointsMatch(startPoint, seg[seg.length - 1])) return i;
                }
                return null;
            }
            
            // Build connected paths
            for (let startIdx = 0; startIdx < coastlineSegments.length; startIdx++) {
                if (used.has(startIdx)) continue;
                
                let path = [...coastlineSegments[startIdx]];
                used.add(startIdx);
                
                // Extend forward
                let extended = true;
                while (extended) {
                    extended = false;
                    const idx = findForwardConnectingSegment(path[path.length - 1]);
                    if (idx !== null) {
                        used.add(idx);
                        const seg = coastlineSegments[idx];
                        path = path.concat(seg.slice(1));  // Skip first point (duplicate)
                        extended = true;
                    }
                }
                
                // Extend backward
                extended = true;
                while (extended) {
                    extended = false;
                    const idx = findBackwardConnectingSegment(path[0]);
                    if (idx !== null) {
                        used.add(idx);
                        const seg = coastlineSegments[idx];
                        path = seg.slice(0, -1).concat(path);  // Skip last point (duplicate)
                        extended = true;
                    }
                }
                
                connectedPaths.push(path);
            }
            
            debugLog('COAST', `Connected into ${connectedPaths.length} paths`);
            
            // RAW DATA: Log every connected path
            verboseLog(`[RAW PATHS] ========== ALL ${connectedPaths.length} CONNECTED PATHS ==========`);
            if (DEBUG && LOG_LEVEL >= 2) {
                connectedPaths.forEach((path, i) => {
                    const lats = path.map(p => p.lat);
                    const lons = path.map(p => p.lon);
                    const first = path[0];
                    const last = path[path.length - 1];
                    const isClosed = Math.abs(first.lat - last.lat) < 0.0001 && Math.abs(first.lon - last.lon) < 0.0001;
                    console.log(`  [RAW PATH ${i}] pts=${path.length}, closed=${isClosed}`);
                    console.log(`    lat: ${Math.min(...lats).toFixed(6)} to ${Math.max(...lats).toFixed(6)}`);
                    console.log(`    lon: ${Math.min(...lons).toFixed(6)} to ${Math.max(...lons).toFixed(6)}`);
                    console.log(`    first: (${first.lat.toFixed(6)}, ${first.lon.toFixed(6)})`);
                    console.log(`    last: (${last.lat.toFixed(6)}, ${last.lon.toFixed(6)})`);
                });
                console.log(`[RAW PATHS] ====================================================`);
            }
            
            // Create water AND land polygons by closing paths along selection boundary
            const waterPolygons = [];
            const landPolygons = [];
            // Use USER bounds (finalClipBounds) for polygon creation, not expanded bounds
            const { minLat, maxLat, minLon, maxLon } = finalClipBounds;
            verboseLog(`[COAST] Selection bounds (USER): minLat=${minLat}, maxLat=${maxLat}, minLon=${minLon}, maxLon=${maxLon}`);
            verboseLog(`[COAST] Selection size: ${(maxLat-minLat).toFixed(4)} lat x ${(maxLon-minLon).toFixed(4)} lon`);
            verboseLog(`[COAST] ========== PROCESSING ${connectedPaths.length} PATHS ==========`);
            let stats = { closed: 0, closedWater: 0, open: 0, nearBoundary: 0, usedCW: 0, usedCCW: 0, skippedLand: 0 };
            
            let pathIndex = 0;
            for (const path of connectedPaths) {
                pathIndex++;
                if (path.length < 3) {
                    console.log(`[PATH ${pathIndex}] Skipped: <3 points`);
                    continue;
                }
                
                const startPoint = path[0];
                const endPoint = path[path.length - 1];
                
                // Check if path is already closed
                if (pointsMatch(startPoint, endPoint)) {
                    stats.closed++;
                    const area = signedArea(path);
                    const lats = path.map(p => p.lat);
                    const lons = path.map(p => p.lon);
                    
                    console.log(`[RAW CLOSED ${pathIndex}] pts=${path.length}, signedArea=${area.toFixed(8)}`);
                    console.log(`  [RAW] lat: ${Math.min(...lats).toFixed(6)} to ${Math.max(...lats).toFixed(6)}`);
                    console.log(`  [RAW] lon: ${Math.min(...lons).toFixed(6)} to ${Math.max(...lons).toFixed(6)}`);
                    console.log(`  [RAW] area < 0: ${area < 0}`);
                    
                    if (area < 0) {
                        console.log(`  [DECISION] CLOSED LOOP: adding to WATER (area < 0)`);
                        waterPolygons.push(path);
                        stats.closedWater++;
                    } else {
                        console.log(`  [DECISION] CLOSED LOOP: adding to LAND (area >= 0)`);
                        const clippedIsland = clipPolygonToBounds(path, finalClipBounds);
                        console.log(`  [RAW] clipped island: ${clippedIsland?.length || 0} pts`);
                        if (clippedIsland && clippedIsland.length >= 3) {
                            landPolygons.push(clippedIsland);
                            const clipLats = clippedIsland.map(p => p.lat);
                            const clipLons = clippedIsland.map(p => p.lon);
                            console.log(`  [RAW] clipped lat: ${Math.min(...clipLats).toFixed(6)} to ${Math.max(...clipLats).toFixed(6)}`);
                            console.log(`  [RAW] clipped lon: ${Math.min(...clipLons).toFixed(6)} to ${Math.max(...clipLons).toFixed(6)}`);
                        }
                    }
                    continue;
                }
                
                stats.open++;
                console.log(`[PATH ${pathIndex}] Open path: ${path.length} pts, start=${JSON.stringify(startPoint)}, end=${JSON.stringify(endPoint)}`);
                
                // CLIP path to USER bounds (not expanded bounds)
                const clippedPath = clipPathToBounds(path, finalClipBounds);
                if (clippedPath.length < 3) {
                    console.log(`[PATH ${pathIndex}] Clipped to ${clippedPath.length} pts (<3), skipping`);
                    continue;
                }
                console.log(`[PATH ${pathIndex}] Clipped: ${path.length} -> ${clippedPath.length} pts`);
                
                // DEBUG: Log clipped path start/end edges
                const clippedStart = clippedPath[0];
                const clippedEnd = clippedPath[clippedPath.length - 1];
                const distToN_s = Math.abs(clippedStart.lat - finalClipBounds.maxLat);
                const distToS_s = Math.abs(clippedStart.lat - finalClipBounds.minLat);
                const distToE_s = Math.abs(clippedStart.lon - finalClipBounds.maxLon);
                const distToW_s = Math.abs(clippedStart.lon - finalClipBounds.minLon);
                const startEdge = ['N','E','S','W'][[distToN_s, distToE_s, distToS_s, distToW_s].indexOf(Math.min(distToN_s, distToE_s, distToS_s, distToW_s))];
                const distToN_e = Math.abs(clippedEnd.lat - finalClipBounds.maxLat);
                const distToS_e = Math.abs(clippedEnd.lat - finalClipBounds.minLat);
                const distToE_e = Math.abs(clippedEnd.lon - finalClipBounds.maxLon);
                const distToW_e = Math.abs(clippedEnd.lon - finalClipBounds.minLon);
                const endEdge = ['N','E','S','W'][[distToN_e, distToE_e, distToS_e, distToW_e].indexOf(Math.min(distToN_e, distToE_e, distToS_e, distToW_e))];
                console.log(`[PATH ${pathIndex}] Clipped edges: ${startEdge} -> ${endEdge}`);
                
                stats.nearBoundary++;
                
                // Use the new osmplotr-style algorithm on CLIPPED path with USER bounds
                const result = createCoastlinePolygons(clippedPath, finalClipBounds);
                if (!result || (!result.water && !result.land)) {
                    console.log(`[PATH ${pathIndex}] Skipped by createCoastlinePolygons (too large or wrong winding)`);
                    stats.skippedLand++;
                    continue;
                }
                
                const waterArea = result.water ? signedArea(result.water) : null;
                const landArea = result.land ? signedArea(result.land) : null;
                
                console.log(`[COAST PATH ${stats.nearBoundary}] ===== DETAILED DEBUG =====`);
                console.log(`  Original path: ${path.length} pts, first=${JSON.stringify(path[0])}, last=${JSON.stringify(path[path.length-1])}`);
                console.log(`  Clipped path: ${clippedPath.length} pts, first=${JSON.stringify(clippedPath[0])}, last=${JSON.stringify(clippedPath[clippedPath.length-1])}`);
                console.log(`  Water polygon: ${result.water?.length || 0} pts`);
                console.log(`  Land polygon: ${result.land?.length || 0} pts`);
                console.log(`  Water area: ${waterArea?.toFixed(6) || 'null'}`);
                console.log(`  Land area: ${landArea?.toFixed(6) || 'null'}`);
                console.log(`  Same-edge case: ${(result.water && !result.land) || (!result.water && result.land)}`);
                
                // DEBUG: Check if water and land polygons overlap significantly
                if (result.water && result.land) {
                    const waterBounds = {
                        minLat: Math.min(...result.water.map(p => p.lat)),
                        maxLat: Math.max(...result.water.map(p => p.lat)),
                        minLon: Math.min(...result.water.map(p => p.lon)),
                        maxLon: Math.max(...result.water.map(p => p.lon))
                    };
                    const landBounds = {
                        minLat: Math.min(...result.land.map(p => p.lat)),
                        maxLat: Math.max(...result.land.map(p => p.lat)),
                        minLon: Math.min(...result.land.map(p => p.lon)),
                        maxLon: Math.max(...result.land.map(p => p.lon))
                    };
                    console.log(`  [OVERLAP CHECK] Water bounds: lat ${waterBounds.minLat.toFixed(4)}-${waterBounds.maxLat.toFixed(4)}, lon ${waterBounds.minLon.toFixed(4)}-${waterBounds.maxLon.toFixed(4)}`);
                    console.log(`  [OVERLAP CHECK] Land bounds: lat ${landBounds.minLat.toFixed(4)}-${landBounds.maxLat.toFixed(4)}, lon ${landBounds.minLon.toFixed(4)}-${landBounds.maxLon.toFixed(4)}`);
                    
                    // Check how much of selection each covers
                    const selLat = finalClipBounds.maxLat - finalClipBounds.minLat;
                    const selLon = finalClipBounds.maxLon - finalClipBounds.minLon;
                    const waterLatPct = ((waterBounds.maxLat - waterBounds.minLat) / selLat * 100).toFixed(1);
                    const waterLonPct = ((waterBounds.maxLon - waterBounds.minLon) / selLon * 100).toFixed(1);
                    const landLatPct = ((landBounds.maxLat - landBounds.minLat) / selLat * 100).toFixed(1);
                    const landLonPct = ((landBounds.maxLon - landBounds.minLon) / selLon * 100).toFixed(1);
                    console.log(`  [OVERLAP CHECK] Water covers: ${waterLatPct}% lat x ${waterLonPct}% lon`);
                    console.log(`  [OVERLAP CHECK] Land covers: ${landLatPct}% lat x ${landLonPct}% lon`);
                }
                if (result.water) {
                    console.log(`  Water poly first 3: ${JSON.stringify(result.water.slice(0,3))}`);
                    console.log(`  Water poly last 3: ${JSON.stringify(result.water.slice(-3))}`);
                }
                if (result.land) {
                    console.log(`  Land poly first 3: ${JSON.stringify(result.land.slice(0,3))}`);
                    console.log(`  Land poly last 3: ${JSON.stringify(result.land.slice(-3))}`);
                }
                
                // Collect WATER polygons (for blue fill) and LAND polygons (for land mask)
                if (result.water) {
                    waterPolygons.push(result.water);
                    stats.usedCW++;
                    console.log(`  -> USED water polygon (${result.water.length} pts, area=${waterArea?.toFixed(6)})`);
                }
                if (result.land) {
                    landPolygons.push(result.land);
                    stats.usedCCW++;
                    console.log(`  -> USED land polygon (${result.land.length} pts, area=${landArea?.toFixed(6)})`);
                }
                if (!result.water && !result.land) {
                    stats.skippedLand++;
                    console.log(`  -> No polygon returned`);
                }
            }
            
            console.log(`[COAST] ===== FINAL SUMMARY =====`);
            console.log(`[COAST] Stats:`, JSON.stringify(stats));
            console.log(`[COAST] Water polygons before clipping: ${waterPolygons.length}`);
            
            // CLIP water polygons to user's actual selection (finalClipBounds)
            const clippedWaterPolygons = [];
            for (const poly of waterPolygons) {
                const clipped = clipPolygonToBounds(poly, finalClipBounds);
                if (clipped && clipped.length >= 3) {
                    // Ensure polygon is explicitly closed (first point == last point)
                    // This is required for the renderer to detect it as a fillable polygon
                    const first = clipped[0];
                    const last = clipped[clipped.length - 1];
                    if (Math.abs(first.lat - last.lat) > 0.00001 || Math.abs(first.lon - last.lon) > 0.00001) {
                        clipped.push({ lat: first.lat, lon: first.lon });
                    }
                    clippedWaterPolygons.push(clipped);
                }
            }
            
            console.log(`[COAST] Water polygons after clipping to user bounds: ${clippedWaterPolygons.length}`);
            // DEBUG: Log detailed info about large water polygons
            clippedWaterPolygons.filter(p => p.length > 100).forEach((poly, i) => {
                const lats = poly.map(p => p.lat);
                const lons = poly.map(p => p.lon);
                const minLat = Math.min(...lats), maxLat = Math.max(...lats);
                const minLon = Math.min(...lons), maxLon = Math.max(...lons);
                const selectionLatRange = finalClipBounds.maxLat - finalClipBounds.minLat;
                const selectionLonRange = finalClipBounds.maxLon - finalClipBounds.minLon;
                const polyLatRange = maxLat - minLat;
                const polyLonRange = maxLon - minLon;
                const latCoverage = (polyLatRange / selectionLatRange * 100).toFixed(1);
                const lonCoverage = (polyLonRange / selectionLonRange * 100).toFixed(1);
                const area = signedArea(poly);
                console.log(`[COAST WATER ${i}] ${poly.length} pts, covers ${latCoverage}% lat x ${lonCoverage}% lon, area=${area.toFixed(6)}`);
                console.log(`  Bounds: lat ${minLat.toFixed(4)}-${maxLat.toFixed(4)}, lon ${minLon.toFixed(4)}-${maxLon.toFixed(4)}`);
            });
            
            // CLIP land polygons to user's actual selection
            const clippedLandPolygons = [];
            for (const poly of landPolygons) {
                const clipped = clipPolygonToBounds(poly, finalClipBounds);
                if (clipped && clipped.length >= 3) {
                    const first = clipped[0];
                    const last = clipped[clipped.length - 1];
                    if (Math.abs(first.lat - last.lat) > 0.00001 || Math.abs(first.lon - last.lon) > 0.00001) {
                        clipped.push({ lat: first.lat, lon: first.lon });
                    }

                    // If a land polygon covers essentially the entire selection bbox AND has very high
                    // actual area coverage, it's likely an artifact that would repaint all water back to land.
                    // But if it has significant coastline "bites", it's a legitimate land mass (like NJ).
                    const lats = clipped.map(p => p.lat);
                    const lons = clipped.map(p => p.lon);
                    const minLat = Math.min(...lats), maxLat = Math.max(...lats);
                    const minLon = Math.min(...lons), maxLon = Math.max(...lons);
                    const selectionLatRange = finalClipBounds.maxLat - finalClipBounds.minLat;
                    const selectionLonRange = finalClipBounds.maxLon - finalClipBounds.minLon;
                    const polyLatCoverage = (maxLat - minLat) / selectionLatRange;
                    const polyLonCoverage = (maxLon - minLon) / selectionLonRange;
                    const touchesAllEdges =
                        Math.abs(minLat - finalClipBounds.minLat) < 0.0005 &&
                        Math.abs(maxLat - finalClipBounds.maxLat) < 0.0005 &&
                        Math.abs(minLon - finalClipBounds.minLon) < 0.0005 &&
                        Math.abs(maxLon - finalClipBounds.maxLon) < 0.0005;
                    
                    // Check actual polygon area vs selection area
                    const polyArea = Math.abs(signedArea(clipped));
                    const selectionArea = selectionLatRange * selectionLonRange;
                    const areaRatio = polyArea / selectionArea;
                    
                    // Drop if bbox covers 99.5%+ AND actual area covers 40%+ of selection
                    // Large land polygons spanning the entire bbox are artifacts from coastline clipping
                    // that would incorrectly cover water areas
                    if (touchesAllEdges && polyLatCoverage > 0.995 && polyLonCoverage > 0.995 && areaRatio > 0.40) {
                        console.log(`[COAST] Dropping full-coverage land polygon: ${clipped.length} pts, ${(polyLatCoverage*100).toFixed(1)}% lat x ${(polyLonCoverage*100).toFixed(1)}% lon, area=${(areaRatio*100).toFixed(1)}%`);
                        continue;
                    }

                    clippedLandPolygons.push(clipped);
                }
            }
            
            console.log(`[COAST] Land polygons after clipping: ${clippedLandPolygons.length}`);
            // DEBUG: Log detailed info about large land polygons
            clippedLandPolygons.filter(p => p.length > 100).forEach((poly, i) => {
                const lats = poly.map(p => p.lat);
                const lons = poly.map(p => p.lon);
                const minLat = Math.min(...lats), maxLat = Math.max(...lats);
                const minLon = Math.min(...lons), maxLon = Math.max(...lons);
                const selectionLatRange = finalClipBounds.maxLat - finalClipBounds.minLat;
                const selectionLonRange = finalClipBounds.maxLon - finalClipBounds.minLon;
                const polyLatRange = maxLat - minLat;
                const polyLonRange = maxLon - minLon;
                const latCoverage = (polyLatRange / selectionLatRange * 100).toFixed(1);
                const lonCoverage = (polyLonRange / selectionLonRange * 100).toFixed(1);
                console.log(`[COAST LAND ${i}] ${poly.length} pts, covers ${latCoverage}% lat x ${lonCoverage}% lon`);
                console.log(`  Bounds: lat ${minLat.toFixed(4)}-${maxLat.toFixed(4)}, lon ${minLon.toFixed(4)}-${maxLon.toFixed(4)}`);
                console.log(`  First 3: ${JSON.stringify(poly.slice(0, 3).map(p => ({lat: p.lat.toFixed(4), lon: p.lon.toFixed(4)})))}`);
                console.log(`  Last 3: ${JSON.stringify(poly.slice(-3).map(p => ({lat: p.lat.toFixed(4), lon: p.lon.toFixed(4)})))}`);
            });
            debugLog('COAST', `Stats:`, stats);
            debugLog('COAST', `Created ${clippedWaterPolygons.length} water + ${clippedLandPolygons.length} land polygons`);
            
            // COMPREHENSIVE SUMMARY
            console.log(`[COAST] ========== FINAL POLYGON SUMMARY ==========`);
            console.log(`[COAST] Total water polygons: ${clippedWaterPolygons.length}`);
            console.log(`[COAST] Total land polygons: ${clippedLandPolygons.length}`);
            
            // RAW DATA: List each polygon with exact area
            const selectionArea = (finalClipBounds.maxLat - finalClipBounds.minLat) * (finalClipBounds.maxLon - finalClipBounds.minLon);
            console.log(`[RAW] Selection area: ${selectionArea.toFixed(8)}`);
            console.log(`[RAW] Each water polygon:`);
            clippedWaterPolygons.forEach((p, i) => {
                const area = signedArea(p);
                const absArea = Math.abs(area);
                const pct = (absArea / selectionArea * 100).toFixed(2);
                const lats = p.map(pt => pt.lat);
                const lons = p.map(pt => pt.lon);
                console.log(`  [RAW WATER ${i}] pts=${p.length}, signedArea=${area.toFixed(8)}, absArea=${absArea.toFixed(8)}, pct=${pct}%`);
                console.log(`    lat: ${Math.min(...lats).toFixed(6)} to ${Math.max(...lats).toFixed(6)}`);
                console.log(`    lon: ${Math.min(...lons).toFixed(6)} to ${Math.max(...lons).toFixed(6)}`);
            });
            console.log(`[RAW] Each land polygon:`);
            clippedLandPolygons.forEach((p, i) => {
                const area = signedArea(p);
                const absArea = Math.abs(area);
                const pct = (absArea / selectionArea * 100).toFixed(2);
                const lats = p.map(pt => pt.lat);
                const lons = p.map(pt => pt.lon);
                console.log(`  [RAW LAND ${i}] pts=${p.length}, signedArea=${area.toFixed(8)}, absArea=${absArea.toFixed(8)}, pct=${pct}%`);
                console.log(`    lat: ${Math.min(...lats).toFixed(6)} to ${Math.max(...lats).toFixed(6)}`);
                console.log(`    lon: ${Math.min(...lons).toFixed(6)} to ${Math.max(...lons).toFixed(6)}`);
            });
            
            // Calculate total coverage for water and land
            let totalWaterArea = 0, totalLandArea = 0;
            clippedWaterPolygons.forEach(p => { totalWaterArea += Math.abs(signedArea(p)); });
            clippedLandPolygons.forEach(p => { totalLandArea += Math.abs(signedArea(p)); });
            console.log(`[COAST] Selection area: ${selectionArea.toFixed(6)}`);
            console.log(`[COAST] Total water area: ${totalWaterArea.toFixed(6)} (${(totalWaterArea/selectionArea*100).toFixed(1)}%)`);
            console.log(`[COAST] Total land area: ${totalLandArea.toFixed(6)} (${(totalLandArea/selectionArea*100).toFixed(1)}%)`);
            console.log(`[COAST] ================================================`);
            
            // Return both water and land polygons
            console.log(`[RAW OUTPUT] ========== processCoastlines END ==========`);
            console.log(`[RAW OUTPUT] Returning: ${clippedWaterPolygons.length} water, ${clippedLandPolygons.length} land`);
            return { water: clippedWaterPolygons, land: clippedLandPolygons };
        }
        
        // Calculate signed area to determine winding direction
        // Positive = counter-clockwise (land inside), Negative = clockwise (water inside for OSM)
        function signedArea(polygon) {
            let area = 0;
            for (let i = 0; i < polygon.length; i++) {
                const j = (i + 1) % polygon.length;
                area += polygon[i].lon * polygon[j].lat;
                area -= polygon[j].lon * polygon[i].lat;
            }
            return area / 2;
        }

        function normalizeRingWinding(polygon, wantNegativeArea) {
            if (!polygon || polygon.length < 3) return polygon;
            const isClosed = polygon.length > 1 &&
                polygon[0].lat === polygon[polygon.length - 1].lat &&
                polygon[0].lon === polygon[polygon.length - 1].lon;
            const ring = isClosed ? polygon.slice(0, -1) : polygon.slice();
            const area = signedArea(ring);
            const shouldFlip = wantNegativeArea ? (area > 0) : (area < 0);
            const out = shouldFlip ? ring.slice().reverse() : ring;
            if (isClosed) out.push(out[0]);
            return out;
        }

        function snapToEdge(pt, edge, bounds) {
            const { minLat, maxLat, minLon, maxLon } = bounds;
            if (edge === 0) return { lat: maxLat, lon: pt.lon };
            if (edge === 1) return { lat: pt.lat, lon: maxLon };
            if (edge === 2) return { lat: minLat, lon: pt.lon };
            return { lat: pt.lat, lon: minLon };
        }
        
        // Clip a polygon to bounding box using Sutherland-Hodgman algorithm
        function clipPolygonToBounds(polygon, bounds) {
            const { minLat, maxLat, minLon, maxLon } = bounds;
            const inputLen = polygon.length;
            
            // Clip against each edge in sequence
            let output = polygon;
            
            // Helper: compute intersection of edge p1->p2 with clip boundary
            function intersect(p1, p2, edge) {
                const dx = p2.lon - p1.lon;
                const dy = p2.lat - p1.lat;
                let t;
                switch (edge) {
                    case 'left':   t = (minLon - p1.lon) / dx; break;
                    case 'right':  t = (maxLon - p1.lon) / dx; break;
                    case 'bottom': t = (minLat - p1.lat) / dy; break;
                    case 'top':    t = (maxLat - p1.lat) / dy; break;
                }
                return { lat: p1.lat + t * dy, lon: p1.lon + t * dx };
            }
            
            function inside(pt, edge) {
                switch (edge) {
                    case 'left':   return pt.lon >= minLon;
                    case 'right':  return pt.lon <= maxLon;
                    case 'bottom': return pt.lat >= minLat;
                    case 'top':    return pt.lat <= maxLat;
                }
            }
            
            // Clip against each of 4 edges
            for (const edge of ['left', 'right', 'bottom', 'top']) {
                if (output.length === 0) break;
                const input = output;
                output = [];
                
                for (let i = 0; i < input.length; i++) {
                    const current = input[i];
                    const next = input[(i + 1) % input.length];
                    
                    if (inside(current, edge)) {
                        output.push(current);
                        if (!inside(next, edge)) {
                            output.push(intersect(current, next, edge));
                        }
                    } else if (inside(next, edge)) {
                        output.push(intersect(current, next, edge));
                    }
                }
            }
            
            // Debug: log if polygon changed significantly
            if (inputLen > 100 && Math.abs(output.length - inputLen) > 10) {
                console.log(`[CLIP POLY DEBUG] ${inputLen} -> ${output.length} pts after Sutherland-Hodgman clip`);
            }
            return output;
        }
        
        // Clip a path to the selection bounds, keeping only points inside or on boundary
        // When path exits and re-enters on different edges, trace along boundary corners
        function clipPathToBounds(path, bounds) {
            const { minLat, maxLat, minLon, maxLon } = bounds;
            
            // Corners: NE=0, SE=1, SW=2, NW=3 (clockwise order)
            const corners = [
                { lat: maxLat, lon: maxLon },  // NE
                { lat: minLat, lon: maxLon },  // SE
                { lat: minLat, lon: minLon },  // SW
                { lat: maxLat, lon: minLon },  // NW
            ];
            
            function isInside(pt) {
                return pt.lat >= minLat && pt.lat <= maxLat && 
                       pt.lon >= minLon && pt.lon <= maxLon;
            }
            
            // Classify which edge a boundary point is on: N=0, E=1, S=2, W=3
            function getEdge(pt) {
                const distN = Math.abs(pt.lat - maxLat);
                const distS = Math.abs(pt.lat - minLat);
                const distE = Math.abs(pt.lon - maxLon);
                const distW = Math.abs(pt.lon - minLon);
                const minDist = Math.min(distN, distS, distE, distW);
                if (minDist === distN) return 0;
                if (minDist === distE) return 1;
                if (minDist === distS) return 2;
                return 3;
            }
            
            // Get corners to traverse CW from edge1 to edge2 (for land, we go CW keeping land on left)
            function getCornersCW(fromEdge, toEdge) {
                // Edge to corner mapping (CW direction): after N->NE, after E->SE, after S->SW, after W->NW
                const edgeToCorner = [0, 1, 2, 3]; // N->NE, E->SE, S->SW, W->NW
                const result = [];
                let e = fromEdge;
                while (e !== toEdge) {
                    result.push(corners[edgeToCorner[e]]);
                    e = (e + 1) % 4;
                    if (result.length > 4) break; // Safety
                }
                return result;
            }
            
            // Find intersection point of line segment with bbox edge
            function intersectBbox(p1, p2) {
                const dx = p2.lon - p1.lon;
                const dy = p2.lat - p1.lat;
                let tMin = 0, tMax = 1;
                
                if (dx !== 0) {
                    const t1 = (minLon - p1.lon) / dx;
                    const t2 = (maxLon - p1.lon) / dx;
                    tMin = Math.max(tMin, Math.min(t1, t2));
                    tMax = Math.min(tMax, Math.max(t1, t2));
                }
                if (dy !== 0) {
                    const t1 = (minLat - p1.lat) / dy;
                    const t2 = (maxLat - p1.lat) / dy;
                    tMin = Math.max(tMin, Math.min(t1, t2));
                    tMax = Math.min(tMax, Math.max(t1, t2));
                }
                
                if (tMin <= tMax && tMin <= 1 && tMax >= 0) {
                    const tEntry = Math.max(0, tMin);
                    const tExit = Math.min(1, tMax);
                    return {
                        entry: { lat: p1.lat + tEntry * dy, lon: p1.lon + tEntry * dx },
                        exit: { lat: p1.lat + tExit * dy, lon: p1.lon + tExit * dx }
                    };
                }
                return null;
            }
            
            const clipped = [];
            let wasInside = false;
            let lastExitPt = null;
            let lastExitEdge = -1;
            
            let cornersAdded = [];
            let crossings = [];
            
            for (let i = 0; i < path.length; i++) {
                const pt = path[i];
                const inside = isInside(pt);
                
                if (inside) {
                    // Entering from outside? Add intersection point and trace corners if needed
                    if (!wasInside && i > 0) {
                        const inter = intersectBbox(path[i-1], pt);
                        if (inter) {
                            const entryPt = inter.entry;
                            const entryEdge = getEdge(entryPt);
                            crossings.push({ type: 'entry', edge: entryEdge, pt: entryPt });
                            
                            // If we previously exited, trace corners from exit to entry
                            if (lastExitPt !== null && lastExitEdge !== entryEdge) {
                                // Trace CW from exit edge to entry edge (land on left = CW for OSM coastlines)
                                const cornerPts = getCornersCW(lastExitEdge, entryEdge);
                                for (const c of cornerPts) {
                                    clipped.push(c);
                                    cornersAdded.push({ from: lastExitEdge, to: entryEdge, corner: c });
                                }
                            }
                            clipped.push(entryPt);
                            lastExitPt = null;
                            lastExitEdge = -1;
                        }
                    }
                    clipped.push(pt);
                    wasInside = true;
                } else {
                    // Exiting from inside? Add intersection point
                    if (wasInside && i > 0) {
                        const inter = intersectBbox(path[i-1], pt);
                        if (inter) {
                            lastExitPt = inter.exit;
                            lastExitEdge = getEdge(lastExitPt);
                            clipped.push(lastExitPt);
                            crossings.push({ type: 'exit', edge: lastExitEdge, pt: lastExitPt });
                        }
                    }
                    wasInside = false;
                }
            }
            
            // RAW DATA: Always log clip results
            const edgeNames = ['N', 'E', 'S', 'W'];
            console.log(`[RAW CLIP] Input: ${path.length} pts, Output: ${clipped.length} pts`);
            console.log(`  [RAW CLIP] First input pt: (${path[0].lat.toFixed(6)}, ${path[0].lon.toFixed(6)})`);
            console.log(`  [RAW CLIP] Last input pt: (${path[path.length-1].lat.toFixed(6)}, ${path[path.length-1].lon.toFixed(6)})`);
            if (clipped.length > 0) {
                console.log(`  [RAW CLIP] First output pt: (${clipped[0].lat.toFixed(6)}, ${clipped[0].lon.toFixed(6)})`);
                console.log(`  [RAW CLIP] Last output pt: (${clipped[clipped.length-1].lat.toFixed(6)}, ${clipped[clipped.length-1].lon.toFixed(6)})`);
            }
            console.log(`  [RAW CLIP] Crossings (${crossings.length}): ${crossings.map(c => c.type + '@' + edgeNames[c.edge] + '(' + c.pt.lat.toFixed(4) + ',' + c.pt.lon.toFixed(4) + ')').join(' -> ')}`);
            console.log(`  [RAW CLIP] Corners added: ${cornersAdded.length}`);
            cornersAdded.forEach((c, i) => {
                console.log(`    [RAW CORNER ${i}] ${edgeNames[c.from]} -> ${edgeNames[c.to]}: (${c.corner.lat.toFixed(6)}, ${c.corner.lon.toFixed(6)})`);
            });
            
            return clipped;
        }
        
        // Classify which edge of bbox a point is on (N=0, E=1, S=2, W=3)
        function classifyEdge(pt, bounds) {
            const { minLat, maxLat, minLon, maxLon } = bounds;
            const distToN = Math.abs(pt.lat - maxLat);
            const distToS = Math.abs(pt.lat - minLat);
            const distToE = Math.abs(pt.lon - maxLon);
            const distToW = Math.abs(pt.lon - minLon);
            const minDist = Math.min(distToN, distToS, distToE, distToW);
            
            if (minDist === distToN) return 0;  // North
            if (minDist === distToE) return 1;  // East
            if (minDist === distToS) return 2;  // South
            return 3;  // West
        }
        
        // Get corner coordinates for bbox (indexed 0-3: NE, SE, SW, NW)
        // Use selection bounds directly - path is already clipped
        function getBboxCorners(bounds) {
            const { minLat, maxLat, minLon, maxLon } = bounds;
            return [
                { lat: maxLat, lon: maxLon },  // 0: NE
                { lat: minLat, lon: maxLon },  // 1: SE
                { lat: minLat, lon: minLon },  // 2: SW
                { lat: maxLat, lon: minLon },  // 3: NW
            ];
        }

        function pointInPolygon(pt, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].lon, yi = polygon[i].lat;
                const xj = polygon[j].lon, yj = polygon[j].lat;
                const intersect = ((yi > pt.lat) !== (yj > pt.lat)) &&
                    (pt.lon < (xj - xi) * (pt.lat - yi) / ((yj - yi) || 1e-12) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function getWaterSideProbePoints(path, bounds, desiredCount = 6) {
            const minDim = Math.min(bounds.maxLat - bounds.minLat, bounds.maxLon - bounds.minLon);
            if (!(minDim > 0)) return null;
            
            const offsetBase = minDim * 0.01;
            const n = path.length;
            if (n < 2) return null;
            
            const isInsideBounds = (pt) => (
                pt.lat >= bounds.minLat && pt.lat <= bounds.maxLat &&
                pt.lon >= bounds.minLon && pt.lon <= bounds.maxLon
            );
            
            const probes = [];
            const count = Math.max(1, Math.min(desiredCount, n - 1));
            for (let k = 1; k <= count; k++) {
                const i = Math.floor((k * (n - 2)) / (count + 1));
                if (i < 0 || i >= n - 1) continue;
                const p0 = path[i];
                const p1 = path[i + 1];
                const dx = p1.lon - p0.lon;
                const dy = p1.lat - p0.lat;
                const len = Math.hypot(dx, dy);
                if (!(len > 1e-12)) continue;
                
                const mx = (p0.lon + p1.lon) / 2;
                const my = (p0.lat + p1.lat) / 2;
                // Right-side normal for direction p0 -> p1
                const nx = (dy / len);
                const ny = (-dx / len);
                
                let off = offsetBase;
                for (let tries = 0; tries < 8; tries++) {
                    const probeRight = { lat: my + ny * off, lon: mx + nx * off };
                    if (isInsideBounds(probeRight)) {
                        probes.push(probeRight);
                        break;
                    }
                    off *= 0.5;
                }
            }
            
            return probes.length ? probes : null;
        }

        function getWaterSideProbePoint(path, bounds) {
            const probes = getWaterSideProbePoints(path, bounds, 1);
            return probes?.[0] || null;
        }
        
        // Create both water and land polygons from a coastline path
        // Returns { water: polygon, land: polygon } or null if invalid
        function createCoastlinePolygons(path, bounds) {
            if (path.length < 2) return null;
            
            const startPt = path[0];
            const endPt = path[path.length - 1];
            
            const startEdge = classifyEdge(startPt, bounds);
            const endEdge = classifyEdge(endPt, bounds);
            
            const edgeNames = ['N(top)', 'E(right)', 'S(bottom)', 'W(left)'];
            console.log(`  createCoastlinePolygons: startPt=${JSON.stringify(startPt)}, endPt=${JSON.stringify(endPt)}`);
            console.log(`  Edges: start=${edgeNames[startEdge]}, end=${edgeNames[endEdge]}`);
            console.log(`  Bounds: minLat=${bounds.minLat}, maxLat=${bounds.maxLat}, minLon=${bounds.minLon}, maxLon=${bounds.maxLon}`);
            
            const corners = getBboxCorners(bounds);
            console.log(`  [CORNERS] NE=(${corners[0].lat.toFixed(4)},${corners[0].lon.toFixed(4)}), SE=(${corners[1].lat.toFixed(4)},${corners[1].lon.toFixed(4)}), SW=(${corners[2].lat.toFixed(4)},${corners[2].lon.toFixed(4)}), NW=(${corners[3].lat.toFixed(4)},${corners[3].lon.toFixed(4)})`);
            console.log(`  Corners: NE=${JSON.stringify(corners[0])}, SE=${JSON.stringify(corners[1])}, SW=${JSON.stringify(corners[2])}, NW=${JSON.stringify(corners[3])}`);
            
            // SPECIAL CASE: Both endpoints on same edge
            // In this case, we don't need to trace around corners - just close directly
            // The polygon is just the path closed back to start
            if (startEdge === endEdge) {
                console.log(`  [RAW] SAME-EDGE CASE: startEdge=${startEdge}, endEdge=${endEdge}`);
                const snappedStart = snapToEdge(startPt, startEdge, bounds);
                const snappedEnd = snapToEdge(endPt, endEdge, bounds);
                const pathFixed = path.slice();
                pathFixed[0] = snappedStart;
                pathFixed[pathFixed.length - 1] = snappedEnd;

                const directPoly = [...pathFixed, pathFixed[0]];
                const directArea = signedArea(directPoly);
                console.log(`  [RAW] directPoly pts: ${directPoly.length}`);
                console.log(`  [RAW] directArea: ${directArea.toFixed(8)}`);
                console.log(`  [RAW] directArea < 0: ${directArea < 0}`);
                
                // Log polygon bounds
                const lats = directPoly.map(p => p.lat);
                const lons = directPoly.map(p => p.lon);
                console.log(`  [RAW] directPoly lat: ${Math.min(...lats).toFixed(6)} to ${Math.max(...lats).toFixed(6)}`);
                console.log(`  [RAW] directPoly lon: ${Math.min(...lons).toFixed(6)} to ${Math.max(...lons).toFixed(6)}`);

                const buildBoundaryCorners = (fromEdge, toEdge, clockwise, forceLoopIfSame) => {
                    const indices = [];
                    let current = fromEdge;
                    let safety = 0;
                    if (forceLoopIfSame && fromEdge === toEdge) {
                        if (clockwise) {
                            for (let k = 0; k < 4; k++) {
                                indices.push(current);
                                current = (current + 1) % 4;
                            }
                        } else {
                            for (let k = 0; k < 4; k++) {
                                current = (current + 3) % 4;
                                indices.push(current);
                            }
                        }
                        return indices.map(i => ({ ...corners[i] }));
                    }

                    while (current !== toEdge && safety < 5) {
                        if (clockwise) {
                            indices.push(current);
                            current = (current + 1) % 4;
                        } else {
                            current = (current + 3) % 4;
                            indices.push(current);
                        }
                        safety++;
                    }
                    return indices.map(i => ({ ...corners[i] }));
                };

                const chooseAroundClockwise = () => {
                    if (startEdge === 1) return snappedEnd.lat < snappedStart.lat;
                    if (startEdge === 3) return snappedEnd.lat > snappedStart.lat;
                    if (startEdge === 0) return snappedEnd.lon > snappedStart.lon;
                    return snappedEnd.lon < snappedStart.lon;
                };

                const aroundClockwise = chooseAroundClockwise();
                const aroundCorners = buildBoundaryCorners(endEdge, startEdge, aroundClockwise, true);
                const aroundPoly = [...pathFixed, ...aroundCorners, pathFixed[0]];
                const aroundArea = signedArea(aroundPoly);
                console.log(`  [RAW] aroundPoly pts: ${aroundPoly.length}`);
                console.log(`  [RAW] aroundArea: ${aroundArea.toFixed(8)}`);
                console.log(`  [RAW] aroundArea < 0: ${aroundArea < 0}`);

                const tallyVotes = (probePoints) => {
                    let directVotes = 0;
                    let aroundVotes = 0;
                    let ambiguous = 0;
                    for (const probe of probePoints) {
                        const inDirect = pointInPolygon(probe, directPoly);
                        const inAround = pointInPolygon(probe, aroundPoly);
                        if (inDirect && !inAround) directVotes++;
                        else if (inAround && !inDirect) aroundVotes++;
                        else ambiguous++;
                    }
                    let winner = null;
                    if (directVotes > aroundVotes) winner = 'DIRECT';
                    else if (aroundVotes > directVotes) winner = 'AROUND';
                    return { directVotes, aroundVotes, ambiguous, winner };
                };
                const pickByWinner = (winner) => {
                    if (winner === 'DIRECT') return { water: directPoly, land: aroundPoly };
                    if (winner === 'AROUND') return { water: aroundPoly, land: directPoly };
                    return null;
                };

                const probes = getWaterSideProbePoints(pathFixed, bounds, 4);
                let fwd = null;
                if (probes?.length) {
                    fwd = tallyVotes(probes);
                    console.log(`  [RAW] Probe points: ${probes.length}, directVotes=${fwd.directVotes}, aroundVotes=${fwd.aroundVotes}, ambiguous=${fwd.ambiguous}`);
                }
                const revProbes = getWaterSideProbePoints([...pathFixed].reverse(), bounds, 4);
                let rev = null;
                if (revProbes?.length) {
                    rev = tallyVotes(revProbes);
                    console.log(`  [RAW] Reverse probe points: ${revProbes.length}, directVotes=${rev.directVotes}, aroundVotes=${rev.aroundVotes}, ambiguous=${rev.ambiguous}`);
                }

                const fwdMargin = fwd ? Math.abs(fwd.directVotes - fwd.aroundVotes) : 0;
                const revMargin = rev ? Math.abs(rev.directVotes - rev.aroundVotes) : 0;
                if (fwd?.winner && fwdMargin > 0) {
                    console.log(`  [DECISION] SAME-EDGE: probe-vote forward accepted (${fwd.winner})`);
                    const picked = pickByWinner(fwd.winner);
                    return {
                        water: normalizeRingWinding(picked.water, true),
                        land: normalizeRingWinding(picked.land, false)
                    };
                }
                if (rev?.winner && revMargin > 0) {
                    console.log(`  [DECISION] SAME-EDGE: probe-vote reverse accepted (${rev.winner})`);
                    const picked = pickByWinner(rev.winner);
                    return {
                        water: normalizeRingWinding(picked.water, true),
                        land: normalizeRingWinding(picked.land, false)
                    };
                }

                if ((directArea < 0) !== (aroundArea < 0)) {
                    const water = directArea < 0 ? directPoly : aroundPoly;
                    const land = directArea < 0 ? aroundPoly : directPoly;
                    console.log(`  [DECISION] SAME-EDGE: signed-area selected ${directArea < 0 ? 'DIRECT' : 'AROUND'} as WATER`);
                    return {
                        water: normalizeRingWinding(water, true),
                        land: normalizeRingWinding(land, false)
                    };
                }

                const directAbs = Math.abs(directArea);
                const aroundAbs = Math.abs(aroundArea);
                const water = directAbs >= aroundAbs ? directPoly : aroundPoly;
                const land = directAbs >= aroundAbs ? aroundPoly : directPoly;
                console.log(`  [DECISION] SAME-EDGE: area-magnitude selected ${directAbs >= aroundAbs ? 'DIRECT' : 'AROUND'} as WATER`);
                return {
                    water: normalizeRingWinding(water, true),
                    land: normalizeRingWinding(land, false)
                };
            }
            
            // DIFFERENT-EDGE CASE: Start and end on different edges
            // Use signed area to determine which polygon is water vs land
            console.log(`  DIFFERENT-EDGE CASE: using signed area to determine water/land`);
            
            // Generate corner indices for CW and CCW traversal from end edge to start edge
            function getCornerIndices(fromEdge, toEdge, clockwise) {
                const indices = [];
                let current = fromEdge;
                let safety = 0;
                while (current !== toEdge && safety < 5) {
                    if (clockwise) {
                        indices.push(current);
                        current = (current + 1) % 4;
                    } else {
                        current = (current + 3) % 4;
                        indices.push(current);
                    }
                    safety++;
                }
                return indices;
            }
            
            const cwIndices = getCornerIndices(endEdge, startEdge, true);
            const ccwIndices = getCornerIndices(endEdge, startEdge, false);
            
            const cornerNames = ['NE', 'SE', 'SW', 'NW'];
            console.log(`  DIFFERENT-EDGE CASE:`);
            console.log(`  CW traversal from ${edgeNames[endEdge]} to ${edgeNames[startEdge]}: ${cwIndices.length} corners [${cwIndices.map(i => cornerNames[i]).join(', ')}]`);
            console.log(`  CCW traversal from ${edgeNames[endEdge]} to ${edgeNames[startEdge]}: ${ccwIndices.length} corners [${ccwIndices.map(i => cornerNames[i]).join(', ')}]`);
            
            // Build polygons: path + corners + close
            const cwCorners = cwIndices.map(i => ({ ...corners[i] }));
            const ccwCorners = ccwIndices.map(i => ({ ...corners[i] }));
            
            console.log(`  [BUILD POLY] Path: ${path.length} pts`);
            console.log(`  [BUILD POLY] CW adding ${cwCorners.length} corners: ${cwIndices.map(i => cornerNames[i]).join(', ')}`);
            console.log(`  [BUILD POLY] CCW adding ${ccwCorners.length} corners: ${ccwIndices.map(i => cornerNames[i]).join(', ')}`);
            
            const cwPoly = [...path, ...cwCorners, path[0]];
            const ccwPoly = [...path, ...ccwCorners, path[0]];
            
            console.log(`  [BUILD POLY] CW poly: ${cwPoly.length} pts = ${path.length} path + ${cwCorners.length} corners + 1 close`);
            console.log(`  [BUILD POLY] CCW poly: ${ccwPoly.length} pts = ${path.length} path + ${ccwCorners.length} corners + 1 close`);
            
            // Determine coastline direction to find which side is water
            // OSM convention: water is on the RIGHT when walking along coastline
            // Use multiple right-side probes along the path for robust classification
            const probes = getWaterSideProbePoints(path, bounds, 6);
            
            // CW corners go via west (SW, NW), CCW corners go via east (SE, NE)
            // For start=N,end=S: CW=[SW,NW], CCW=[SE,NE]
            // For start=S,end=N: CW=[NE,SE], CCW=[NW,SW]
            const cwGoesWest = cwIndices.includes(2) || cwIndices.includes(3);  // SW=2, NW=3
            
            const cwArea = signedArea(cwPoly);
            const ccwArea = signedArea(ccwPoly);
            console.log(`  CW polygon: ${cwPoly.length} pts, area=${cwArea.toFixed(6)}, goesWest=${cwGoesWest}`);
            console.log(`  CCW polygon: ${ccwPoly.length} pts, area=${ccwArea.toFixed(6)}, goesWest=${!cwGoesWest}`);
            console.log(`  [AREA SIGN] CW area ${cwArea < 0 ? 'NEGATIVE (water by OSM)' : 'POSITIVE (land by OSM)'}`);
            console.log(`  [AREA SIGN] CCW area ${ccwArea < 0 ? 'NEGATIVE (water by OSM)' : 'POSITIVE (land by OSM)'}`);
            
            // Validate polygons - check they don't share the same bounds
            const cwMinLat = Math.min(...cwPoly.map(p => p.lat));
            const cwMaxLat = Math.max(...cwPoly.map(p => p.lat));
            const cwMinLon = Math.min(...cwPoly.map(p => p.lon));
            const cwMaxLon = Math.max(...cwPoly.map(p => p.lon));
            const ccwMinLat = Math.min(...ccwPoly.map(p => p.lat));
            const ccwMaxLat = Math.max(...ccwPoly.map(p => p.lat));
            const ccwMinLon = Math.min(...ccwPoly.map(p => p.lon));
            const ccwMaxLon = Math.max(...ccwPoly.map(p => p.lon));
            console.log(`  [BOUNDS CHECK] CW: lat ${cwMinLat.toFixed(4)}-${cwMaxLat.toFixed(4)}, lon ${cwMinLon.toFixed(4)}-${cwMaxLon.toFixed(4)}`);
            console.log(`  [BOUNDS CHECK] CCW: lat ${ccwMinLat.toFixed(4)}-${ccwMaxLat.toFixed(4)}, lon ${ccwMinLon.toFixed(4)}-${ccwMaxLon.toFixed(4)}`);
            
            // RAW DATA: Coverage ratios (no interpretation)
            const fullLatRange = bounds.maxLat - bounds.minLat;
            const fullLonRange = bounds.maxLon - bounds.minLon;
            const cwLatCov = ((cwMaxLat - cwMinLat) / fullLatRange * 100).toFixed(1);
            const cwLonCov = ((cwMaxLon - cwMinLon) / fullLonRange * 100).toFixed(1);
            const ccwLatCov = ((ccwMaxLat - ccwMinLat) / fullLatRange * 100).toFixed(1);
            const ccwLonCov = ((ccwMaxLon - ccwMinLon) / fullLonRange * 100).toFixed(1);
            console.log(`  [RAW] CW covers: ${cwLatCov}% lat, ${cwLonCov}% lon`);
            console.log(`  [RAW] CCW covers: ${ccwLatCov}% lat, ${ccwLonCov}% lon`);
            
            // OSM CONVENTION: Water is on the RIGHT of coastline = clockwise = NEGATIVE signed area
            // Use whichever polygon has negative area - that's the water
            const bboxArea = (bounds.maxLat - bounds.minLat) * (bounds.maxLon - bounds.minLon);
            
            console.log(`  Bbox area: ${bboxArea.toFixed(6)}`);
            const cwPct = Math.abs(cwArea) / bboxArea * 100;
            const ccwPct = Math.abs(ccwArea) / bboxArea * 100;
            console.log(`  CW: ${cwArea.toFixed(6)} (${cwPct.toFixed(1)}%), CCW: ${ccwArea.toFixed(6)} (${ccwPct.toFixed(1)}%)`);
            
            // RAW DATA: Path length
            const pathLength = path.length;
            console.log(`  [RAW] Path length: ${pathLength}`);
            
            // Pick the polygon with negative area (water)
            // But override if the "water" polygon is unreasonably large for this path length
            
            // DEBUG: Log corner details for both polygons
            console.log(`  [POLYGON DEBUG] CW corners: [${cwIndices.map(i => cornerNames[i]).join(', ')}]`);
            console.log(`  [POLYGON DEBUG] CCW corners: [${ccwIndices.map(i => cornerNames[i]).join(', ')}]`);
            console.log(`  [POLYGON DEBUG] CW poly bounds: lat ${Math.min(...cwPoly.map(p=>p.lat)).toFixed(4)}-${Math.max(...cwPoly.map(p=>p.lat)).toFixed(4)}, lon ${Math.min(...cwPoly.map(p=>p.lon)).toFixed(4)}-${Math.max(...cwPoly.map(p=>p.lon)).toFixed(4)}`);
            console.log(`  [POLYGON DEBUG] CCW poly bounds: lat ${Math.min(...ccwPoly.map(p=>p.lat)).toFixed(4)}-${Math.max(...ccwPoly.map(p=>p.lat)).toFixed(4)}, lon ${Math.min(...ccwPoly.map(p=>p.lon)).toFixed(4)}-${Math.max(...ccwPoly.map(p=>p.lon)).toFixed(4)}`);
            
            // NO HEURISTICS - PURE SIGNED AREA DECISION
            // Negative signed area = clockwise = water (OSM convention)
            // Positive signed area = counter-clockwise = land
            console.log(`  [RAW] cwArea=${cwArea.toFixed(8)}, ccwArea=${ccwArea.toFixed(8)}`);
            console.log(`  [RAW] cwArea<0: ${cwArea < 0}, ccwArea<0: ${ccwArea < 0}`);
            
            // Probe-vote must respect the OSM invariant: WATER polygon should be the negative signed-area closure.
            // If the path direction is reversed, right-side probes would vote for the opposite polygon.
            // So we evaluate probes for both path and reversed(path), then accept the winner only if it selects
            // the negative-area polygon.
            const tallyVotes = (probePoints) => {
                let cwVotes = 0;
                let ccwVotes = 0;
                let ambiguous = 0;
                for (const probe of probePoints) {
                    const inCW = pointInPolygon(probe, cwPoly);
                    const inCCW = pointInPolygon(probe, ccwPoly);
                    if (inCW && !inCCW) cwVotes++;
                    else if (inCCW && !inCW) ccwVotes++;
                    else ambiguous++;
                }
                let winner = null;
                if (cwVotes > ccwVotes) winner = 'CW';
                else if (ccwVotes > cwVotes) winner = 'CCW';
                return { cwVotes, ccwVotes, ambiguous, winner };
            };
            const pickByWinner = (winner) => {
                if (winner === 'CW') return { water: cwPoly, land: ccwPoly };
                if (winner === 'CCW') return { water: ccwPoly, land: cwPoly };
                return null;
            };

            let fwd = null;
            if (probes?.length) {
                fwd = tallyVotes(probes);
                console.log(`  [RAW] Probe points: ${probes.length}, cwVotes=${fwd.cwVotes}, ccwVotes=${fwd.ccwVotes}, ambiguous=${fwd.ambiguous}`);
            }
            const revProbes = getWaterSideProbePoints([...path].reverse(), bounds, 6);
            let rev = null;
            if (revProbes?.length) {
                rev = tallyVotes(revProbes);
                console.log(`  [RAW] Reverse probe points: ${revProbes.length}, cwVotes=${rev.cwVotes}, ccwVotes=${rev.ccwVotes}, ambiguous=${rev.ambiguous}`);
            }

            // Use forward right-side probes as primary decision (OSM convention: water on right).
            // Only fall back to reverse probes if forward is ambiguous/no-winner.
            const fwdMargin = fwd ? Math.abs(fwd.cwVotes - fwd.ccwVotes) : 0;
            const revMargin = rev ? Math.abs(rev.cwVotes - rev.ccwVotes) : 0;
            if (fwd?.winner && fwdMargin > 0) {
                console.log(`  [DECISION] PROBE VOTE: forward accepted (${fwd.winner})`);
                const picked = pickByWinner(fwd.winner);
                return {
                    water: normalizeRingWinding(picked.water, true),
                    land: normalizeRingWinding(picked.land, false)
                };
            }
            if (rev?.winner && revMargin > 0) {
                console.log(`  [DECISION] PROBE VOTE: reverse accepted (${rev.winner})`);
                const picked = pickByWinner(rev.winner);
                return {
                    water: normalizeRingWinding(picked.water, true),
                    land: normalizeRingWinding(picked.land, false)
                };
            }
            
            if (cwArea < 0 && ccwArea >= 0) {
                console.log(`  [DECISION] CW is WATER (negative), CCW is LAND (positive)`);
                console.log(`  [DECISION] water=CW (${cwPoly.length} pts), land=CCW (${ccwPoly.length} pts)`);
                return { water: normalizeRingWinding(cwPoly, true), land: normalizeRingWinding(ccwPoly, false) };
            } else if (ccwArea < 0 && cwArea >= 0) {
                console.log(`  [DECISION] CCW is WATER (negative), CW is LAND (positive)`);
                console.log(`  [DECISION] water=CCW (${ccwPoly.length} pts), land=CW (${cwPoly.length} pts)`);
                return { water: normalizeRingWinding(ccwPoly, true), land: normalizeRingWinding(cwPoly, false) };
            } else if (cwArea < 0 && ccwArea < 0) {
                // Both negative - return both as water, no land
                console.log(`  [DECISION] BOTH NEGATIVE - both are water polygons`);
                console.log(`  [DECISION] water=CW (${cwPoly.length} pts), land=null`);
                const cwAbs = Math.abs(cwArea);
                const ccwAbs = Math.abs(ccwArea);
                const larger = cwAbs >= ccwAbs ? cwPoly : ccwPoly;
                const smaller = cwAbs >= ccwAbs ? ccwPoly : cwPoly;
                console.log(`  [RAW] Smaller area: ${Math.min(cwAbs, ccwAbs).toFixed(8)}`);
                console.log(`  [RAW] Larger area: ${Math.max(cwAbs, ccwAbs).toFixed(8)}`);
                return { water: normalizeRingWinding(larger, true), land: normalizeRingWinding(smaller, false) };
            } else {
                // Both positive - both are land, no water
                console.log(`  [DECISION] BOTH POSITIVE - both are land polygons, no water`);
                const larger = cwArea > ccwArea ? cwPoly : ccwPoly;
                console.log(`  [DECISION] water=null, land=${larger.length} pts`);
                return { water: null, land: normalizeRingWinding(larger, false) };
            }
        }
        
        async function generateMap() {
            if (!selectedBounds) {
                setStatus('error', 'Please select an area first');
                return;
            }

            const runId = ++generateRunId;
            const isStale = () => runId !== generateRunId;
            
            const btn = document.getElementById('generateBtn');
            btn.disabled = true;
            setStatus('working', 'Fetching map data from OpenStreetMap...');
            setProgress(10);
            
            debugLog('INIT', '=== Starting map generation ===');
            debugLog('BOUNDS', 'Selected bounds:', {
                sw: selectedBounds.getSouthWest(),
                ne: selectedBounds.getNorthEast()
            });
            
            try {
                // Build Overpass query
                const query = buildOverpassQuery();
                debugLog('QUERY', 'Overpass query:', query);
                setProgress(20);
                
                // Fetch data with retry
                debugLog('FETCH', 'Fetching from Overpass API...');
                const response = await fetchWithRetry(OVERPASS_SERVERS[currentServerIndex], {
                    method: 'POST',
                    body: query
                });

                if (isStale()) return;
                
                setStatus('working', 'Parsing response...');
                setProgress(50);
                
                const data = await response.json();

                if (isStale()) return;
                debugLog('FETCH', 'Received elements:', data.elements?.length || 0);
                
                // Extract metadata for display (same as preview)
                extractMetadataFromData(data);
                updateStats();
                
                setStatus('working', 'Preparing water/coastline context...');
                setProgress(70);
                
                const sw = selectedBounds.getSouthWest();
                const ne = selectedBounds.getNorthEast();
                const minLat = sw.lat, maxLat = ne.lat;
                const minLon = sw.lng, maxLon = ne.lng;
                const userBounds = { minLat, maxLat, minLon, maxLon };
                
                const WATER_BUFFER = 0.1;
                const expandedBounds = {
                    minLat: minLat - WATER_BUFFER,
                    maxLat: maxLat + WATER_BUFFER,
                    minLon: minLon - WATER_BUFFER,
                    maxLon: maxLon + WATER_BUFFER
                };
                
                let waterData = data.elements;
                let coastlineProcessingBounds = userBounds;
                const fetchCoastlines = document.getElementById('coastlines')?.checked;
                const fetchWaterBodies = document.getElementById('waterBodies')?.checked;
                
                if (fetchCoastlines || fetchWaterBodies) {
                    try {
                        let waterQuery = `[out:json][bbox:${expandedBounds.minLat},${expandedBounds.minLon},${expandedBounds.maxLat},${expandedBounds.maxLon}];(\n`;
                        
                        if (fetchCoastlines) {
                            waterQuery += `way["natural"="coastline"];\n`;
                        }
                        if (fetchWaterBodies) {
                            waterQuery += `way["natural"="water"];\n`;
                            waterQuery += `relation["natural"="water"];\n`;
                            waterQuery += `way["water"];\n`;
                            waterQuery += `relation["water"];\n`;
                            waterQuery += `way["waterway"="riverbank"];\n`;
                            waterQuery += `relation["waterway"="riverbank"];\n`;
                            waterQuery += `way["waterway"="dock"];\n`;
                            waterQuery += `way["landuse"~"basin|reservoir"];\n`;
                            waterQuery += `relation["natural"~"bay|strait"];\n`;
                            waterQuery += `way["harbour"];\n`;
                        }
                        waterQuery += `);out geom;`;
                        
                        const waterResponse = await fetchWithRetry(OVERPASS_SERVERS[currentServerIndex], {
                            method: 'POST',
                            body: waterQuery
                        });

                        if (isStale()) return;
                        const expandedWaterData = await waterResponse.json();

                        if (isStale()) return;
                        
                        const isWaterFeature = (el) => {
                            if (el.type !== 'way' && el.type !== 'relation') return false;
                            const tags = el.tags || {};
                            return tags.natural === 'coastline' || 
                                   tags.natural === 'water' ||
                                   tags.natural === 'bay' ||
                                   tags.natural === 'strait' ||
                                   tags.water ||
                                   tags.waterway === 'riverbank' ||
                                   tags.waterway === 'dock' ||
                                   tags.landuse === 'basin' ||
                                   tags.landuse === 'reservoir' ||
                                   tags.harbour;
                        };
                        const nonWaterElements = data.elements.filter(el => !isWaterFeature(el));
                        waterData = [...nonWaterElements, ...(expandedWaterData.elements || [])];
                        coastlineProcessingBounds = expandedBounds;
                    } catch (e) {
                        console.warn('[WATER] Expanded fetch failed during generate, using original bounds:', e.message);
                    }
                }
                
                const hwmapGenData = { ...data, elements: waterData };
                const outputVersion = 6;
                const hwmapResult = convertToHWMap(hwmapGenData, {
                    coastlineProcessingBounds,
                    coastlineClipBounds: userBounds,
                    outputVersion
                });

                if (isStale()) return;
                debugLog('OUTPUT', 'Generated blob size:', hwmapResult.blob.size + ' bytes');
                
                setProgress(90);
                
                // Download file
                const regionName = document.getElementById('regionName').value || 'map';
                const filename = regionName.toLowerCase().replace(/[^a-z0-9]/g, '_') + '.hwmap';
                
                downloadBlob(hwmapResult.blob, filename);
                
                // Display actual results
                displayActualResults(hwmapResult);
                
                // Collapse sidebar sections to reduce clutter
                collapseAllSections();
                
                setProgress(100);
                setStatus('success', 'Download started! Upload to device at /maps/');
                debugLog('DONE', '=== Map generation complete ===');
                
            } catch (error) {
                debugLog('ERROR', 'Generation failed:', {
                    message: error.message,
                    stack: error.stack
                });
                setStatus('error', 'Error: ' + error.message);
                console.error(error);
            } finally {
                btn.disabled = false;
                setTimeout(hideProgress, 1000);
            }
        }
        
        function buildOverpassQuery() {
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            const bbox = `${sw.lat},${sw.lng},${ne.lat},${ne.lng}`;
            
            let query = `[out:json][bbox:${bbox}];(\n`;
            
            // Highways
            if (document.getElementById('motorways').checked) {
                query += `way["highway"~"motorway|motorway_link"];\n`;
            }
            if (document.getElementById('trunkRoads').checked) {
                query += `way["highway"~"trunk|trunk_link"];\n`;
            }
            
            // Roads
            if (document.getElementById('primaryRoads').checked) {
                query += `way["highway"~"primary|primary_link"];\n`;
            }
            if (document.getElementById('secondaryRoads').checked) {
                query += `way["highway"~"secondary|secondary_link"];\n`;
            }
            if (document.getElementById('tertiaryRoads').checked) {
                query += `way["highway"~"tertiary|tertiary_link"];\n`;
            }
            if (document.getElementById('residentialRoads').checked) {
                query += `way["highway"~"residential|unclassified"];\n`;
            }
            if (document.getElementById('serviceRoads').checked) {
                query += `way["highway"="service"];\n`;
            }
            
            // Paths
            if (document.getElementById('footways').checked) {
                query += `way["highway"~"footway|pedestrian|steps"];\n`;
            }
            if (document.getElementById('cycleways').checked) {
                query += `way["highway"="cycleway"];\n`;
            }
            if (document.getElementById('tracks').checked) {
                query += `way["highway"~"track|path"];\n`;
            }
            
            // Water - fetch AREA polygons, not linear centerlines
            if (document.getElementById('waterBodies').checked) {
                // Lakes, ponds, harbors, bays as areas
                query += `way["natural"="water"];\n`;
                query += `relation["natural"="water"];\n`;
                // Additional water area tags
                query += `way["water"];\n`;  // Generic water areas (water=lake, water=river, water=harbour, etc.)
                query += `relation["water"];\n`;
                query += `way["waterway"="riverbank"];\n`;  // River area polygons (not centerlines!)
                query += `relation["waterway"="riverbank"];\n`;
                query += `way["waterway"="dock"];\n`;
                query += `way["landuse"="basin"];\n`;  // Basins, reservoirs
                query += `way["landuse"="reservoir"];\n`;
                // Bays, harbors, and other coastal water features
                query += `relation["natural"="bay"];\n`;
                query += `relation["natural"="strait"];\n`;
                query += `relation["place"="sea"];\n`;
                query += `way["harbour"];\n`;
                query += `relation["harbour"];\n`;
            }
            if (document.getElementById('waterways').checked) {
                // Linear waterways (rivers as lines - for showing flow, not filling)
                query += `way["waterway"~"river|stream|canal"];\n`;
            }
            if (document.getElementById('coastlines').checked) {
                // Coastlines are linear boundaries - won't fill as polygons
                query += `way["natural"="coastline"];\n`;
            }
            
            // Nature - include relations for large parks/forests and additional green area types
            if (document.getElementById('parks').checked) {
                // Parks, gardens, recreation grounds, playgrounds, village greens
                query += `way["leisure"~"park|garden|recreation_ground|playground"];\n`;
                query += `way["landuse"~"grass|village_green|recreation_ground|allotments"];\n`;
                query += `relation["leisure"~"park|garden|recreation_ground"];\n`;  // Large parks
                query += `relation["landuse"~"grass|village_green|recreation_ground"];\n`;
                // Golf courses and other leisure green areas
                query += `way["leisure"="golf_course"];\n`;
                // Protected areas (nature reserves, etc.)
                query += `way["leisure"="nature_reserve"];\n`;
                query += `relation["leisure"="nature_reserve"];\n`;
            }
            if (document.getElementById('forests').checked) {
                query += `way["landuse"~"forest|wood"];\nway["natural"="wood"];\n`;
                query += `relation["landuse"~"forest|wood"];\nrelation["natural"="wood"];\n`;
            }
            if (document.getElementById('grassland').checked) {
                query += `way["landuse"~"meadow|grassland|farmland"];\nway["natural"~"grassland|heath|scrub"];\n`;
                query += `relation["landuse"~"meadow|grassland"];\nrelation["natural"~"grassland|heath|scrub"];\n`;
            }
            
            // Infrastructure
            if (document.getElementById('railways').checked) {
                query += `way["railway"~"rail|light_rail|tram"];\n`;
            }
            if (document.getElementById('subways').checked) {
                // Direct subway track ways
                query += `way["railway"="subway"];\n`;
                // Subway route relations (NYC, London, etc store routes as relations)
                query += `relation["route"="subway"];\n`;
            }
            if (document.getElementById('busRoutes').checked) {
                // Bus route relations - contain the full route geometry
                query += `relation["route"="bus"];\n`;
                // Trolleybus routes
                query += `relation["route"="trolleybus"];\n`;
            }
            if (document.getElementById('ferryRoutes').checked) {
                // Ferry route relations and ways
                query += `relation["route"="ferry"];\n`;
                query += `way["route"="ferry"];\n`;
            }
            if (document.getElementById('transitStations').checked) {
                // Train/metro stations
                query += `node["railway"="station"];\n`;
                query += `node["railway"="halt"];\n`;
                // Bus stations (major)
                query += `node["amenity"="bus_station"];\n`;
                // Ferry terminals
                query += `node["amenity"="ferry_terminal"];\n`;
            }
            if (document.getElementById('bridges').checked) {
                query += `way["bridge"="yes"];\n`;
            }
            if (document.getElementById('powerlines').checked) {
                query += `way["power"~"line|minor_line"];\n`;
            }
            
            // Land Use
            if (document.getElementById('buildings').checked) {
                query += `way["building"];\n`;
            }
            if (document.getElementById('buildingsLargeOnly').checked && !document.getElementById('buildings').checked) {
                // Filter for large buildings: 3+ floors (regex match for levels 3-99+)
                query += `way["building"]["building:levels"~"^[3-9]$|^[1-9][0-9]+$"];\n`;
            }
            if (document.getElementById('industrial').checked) {
                query += `way["landuse"="industrial"];\n`;
            }
            if (document.getElementById('commercial').checked) {
                query += `way["landuse"~"commercial|retail"];\n`;
            }
            if (document.getElementById('residential').checked) {
                query += `way["landuse"="residential"];\n`;
            }
            
            // Use recursion to expand relation members into ways
            query += `);(._;>;);out geom;`;
            return query;
        }
        
        // =============================================================================
        // BINARY CONVERSION - HWMAP v3 FORMAT (with Spatial Index)
        // =============================================================================
        // 
        // v3 Format (backward compatible header with v2):
        //   Header (40 bytes):
        //     Magic: "HWMP" (4), Version: uint16 = 3 (2), Flags: uint16 (bit 0 = has spatial index) (2)
        //     Bounds: minLat, minLon, maxLat, maxLon (4×int32 = 16)
        //     FeatureCount: uint32 (4), NameCount: uint16 (2)
        //     RegionName: char[8] (8), Padding: 2 bytes
        //   
        //   Name Table (variable):
        //     For each name: Length: uint8, String: char[Length]
        //   
        //   Features (variable):
        //     Type: uint8, NameIndex: uint16 (0xFFFF = unnamed), PointCount: uint8
        //     FirstPoint: lat + lon (2×int32), DeltaPoints: (N-1) × (dLat + dLon as int16)
        //
        //   Spatial Index (v3 only):
        //     Header: gridSize: uint8, reserved: uint8, totalEntries: uint16
        //     For each cell (gridSize × gridSize cells, row-major):
        //       count: uint16, indices: uint16[count]
        //
        // =============================================================================
        
        const HWMAP_GRID_SIZE = 8;  // 8×8 = 64 cells
        
        // Feature types matching device-side enum
        const FEATURE_TYPES = {
            ROAD_HIGHWAY: 0x00,
            ROAD_MAJOR: 0x01,
            ROAD_MINOR: 0x02,
            ROAD_PATH: 0x03,
            WATER: 0x10,
            PARK: 0x11,
            LAND: 0x12,  // Land mask from coastlines
            RAILWAY: 0x20,
            BUS: 0x21,
            FERRY: 0x22,
            BUILDING: 0x30,
            STATION: 0x40
        };

        const FEATURE_SUBTYPES = {
            ROAD_HIGHWAY: { MOTORWAY: 0, TRUNK: 1 },
            ROAD_MAJOR: { PRIMARY: 0, SECONDARY: 1 },
            ROAD_MINOR: { TERTIARY: 0, RESIDENTIAL: 1, SERVICE: 2 },
            ROAD_PATH: { FOOTWAY: 0, CYCLEWAY: 1, TRACK: 2 },
            WATER: { LAKE: 0, RIVER: 1, COASTLINE: 2 },
            PARK: { PARK: 0, FOREST: 1, GRASSLAND: 2 },
            RAILWAY: { RAIL: 0, SUBWAY: 1 },
            BUILDING: { BUILDING: 0, INDUSTRIAL: 1, COMMERCIAL: 2, RESIDENTIAL: 3 }
        };
        
        const HWMAP_NO_NAME = 0xFFFF;  // Marker for unnamed features

        function getHWMapSubtype(tags, featureType) {
            const st = FEATURE_SUBTYPES;
            if (!tags) return 0;

            if (featureType === FEATURE_TYPES.ROAD_HIGHWAY) {
                if (['motorway', 'motorway_link'].includes(tags.highway)) return st.ROAD_HIGHWAY.MOTORWAY;
                if (['trunk', 'trunk_link'].includes(tags.highway)) return st.ROAD_HIGHWAY.TRUNK;
                return 0;
            }

            if (featureType === FEATURE_TYPES.ROAD_MAJOR) {
                if (['primary', 'primary_link'].includes(tags.highway)) return st.ROAD_MAJOR.PRIMARY;
                if (['secondary', 'secondary_link'].includes(tags.highway)) return st.ROAD_MAJOR.SECONDARY;
                return 0;
            }

            if (featureType === FEATURE_TYPES.ROAD_MINOR) {
                if (['tertiary', 'tertiary_link', 'unclassified'].includes(tags.highway)) return st.ROAD_MINOR.TERTIARY;
                if (['residential', 'living_street'].includes(tags.highway)) return st.ROAD_MINOR.RESIDENTIAL;
                if (tags.highway === 'service') return st.ROAD_MINOR.SERVICE;
                return 0;
            }

            if (featureType === FEATURE_TYPES.ROAD_PATH) {
                if (['footway', 'path', 'pedestrian', 'steps'].includes(tags.highway)) return st.ROAD_PATH.FOOTWAY;
                if (tags.highway === 'cycleway') return st.ROAD_PATH.CYCLEWAY;
                if (['track', 'bridleway'].includes(tags.highway)) return st.ROAD_PATH.TRACK;
                return 0;
            }

            if (featureType === FEATURE_TYPES.WATER) {
                if (tags.natural === 'coastline' || tags.water === 'coastline_generated' || tags.land === 'coastline_generated' ||
                    tags.natural === 'bay' || tags.natural === 'strait' || tags.harbour || tags.place === 'sea') {
                    return st.WATER.COASTLINE;
                }
                if (tags.waterway === 'riverbank' || (tags.waterway && ['river', 'stream', 'canal', 'drain', 'ditch'].includes(tags.waterway))) {
                    return st.WATER.RIVER;
                }
                return st.WATER.LAKE;
            }

            if (featureType === FEATURE_TYPES.PARK) {
                if (tags.natural === 'wood' || tags.landuse === 'forest' || tags.landuse === 'wood') return st.PARK.FOREST;
                if (tags.landuse === 'grass' || tags.natural === 'grassland' || tags.landuse === 'meadow' ||
                    tags.landuse === 'grassland' || tags.landuse === 'farmland' ||
                    tags.natural === 'heath' || tags.natural === 'scrub') {
                    return st.PARK.GRASSLAND;
                }
                return st.PARK.PARK;
            }

            if (featureType === FEATURE_TYPES.RAILWAY) {
                if (['subway', 'light_rail', 'tram'].includes(tags.railway)) return st.RAILWAY.SUBWAY;
                return st.RAILWAY.RAIL;
            }

            if (featureType === FEATURE_TYPES.BUILDING) {
                if (tags.landuse === 'industrial') return st.BUILDING.INDUSTRIAL;
                if (tags.landuse === 'commercial' || tags.landuse === 'retail') return st.BUILDING.COMMERCIAL;
                if (tags.landuse === 'residential') return st.BUILDING.RESIDENTIAL;
                return st.BUILDING.BUILDING;
            }

            return 0;
        }
        
        // Get granular source type name for breakdown display (matches estimate breakdown)
        function getGranularTypeName(tags, featureType) {
            if (!tags) {
                // Fallback based on feature type
                const fallbackNames = {
                    [FEATURE_TYPES.ROAD_HIGHWAY]: 'Highways',
                    [FEATURE_TYPES.ROAD_MAJOR]: 'Major Roads',
                    [FEATURE_TYPES.ROAD_MINOR]: 'Minor Roads',
                    [FEATURE_TYPES.ROAD_PATH]: 'Paths',
                    [FEATURE_TYPES.WATER]: 'Water',
                    [FEATURE_TYPES.PARK]: 'Parks/Nature',
                    [FEATURE_TYPES.LAND]: 'Land Mask',
                    [FEATURE_TYPES.RAILWAY]: 'Railways',
                    [FEATURE_TYPES.BUS]: 'Bus Routes',
                    [FEATURE_TYPES.FERRY]: 'Ferries',
                    [FEATURE_TYPES.BUILDING]: 'Buildings',
                    [FEATURE_TYPES.STATION]: 'Stations'
                };
                return fallbackNames[featureType] || 'Other';
            }
            
            // Roads - granular breakdown
            if (tags.highway) {
                if (['motorway', 'motorway_link'].includes(tags.highway)) return 'Motorways';
                if (['trunk', 'trunk_link'].includes(tags.highway)) return 'Trunk Roads';
                if (['primary', 'primary_link'].includes(tags.highway)) return 'Primary Roads';
                if (['secondary', 'secondary_link'].includes(tags.highway)) return 'Secondary Roads';
                if (['tertiary', 'tertiary_link', 'unclassified'].includes(tags.highway)) return 'Tertiary Roads';
                if (['residential', 'living_street'].includes(tags.highway)) return 'Residential Roads';
                if (tags.highway === 'service') return 'Service Roads';
                if (['footway', 'path', 'pedestrian', 'steps'].includes(tags.highway)) return 'Footways';
                if (tags.highway === 'cycleway') return 'Cycleways';
                if (['track', 'bridleway'].includes(tags.highway)) return 'Tracks';
            }
            
            // Water - granular breakdown
            if (tags.natural === 'water' || tags.water || tags.landuse === 'basin' || tags.landuse === 'reservoir' ||
                tags.waterway === 'riverbank' || tags.waterway === 'dock') return 'Lakes/Ponds';
            if (tags.waterway && ['river', 'stream', 'canal', 'drain', 'ditch'].includes(tags.waterway)) return 'Rivers';
            if (tags.natural === 'coastline') return 'Coastlines';
            if (tags.water === 'coastline_generated' || tags.land === 'coastline_generated') return 'Coastlines';
            if (tags.natural === 'bay' || tags.natural === 'strait' || tags.harbour || tags.place === 'sea') return 'Coastlines';
            
            // Nature - granular breakdown (expanded coverage)
            if (tags.leisure === 'park' || tags.leisure === 'garden' || tags.leisure === 'recreation_ground' ||
                tags.leisure === 'playground' || tags.leisure === 'golf_course' || tags.leisure === 'nature_reserve' ||
                tags.landuse === 'village_green' || tags.landuse === 'allotments' || 
                tags.landuse === 'recreation_ground') return 'Parks';
            if (tags.natural === 'wood' || tags.landuse === 'forest' || tags.landuse === 'wood') return 'Forests';
            if (tags.landuse === 'grass' || tags.natural === 'grassland' || tags.landuse === 'meadow' ||
                tags.landuse === 'grassland' || tags.landuse === 'farmland' ||
                tags.natural === 'heath' || tags.natural === 'scrub') return 'Grassland';
            
            // Infrastructure - granular breakdown
            if (tags.railway) {
                if (['station', 'halt'].includes(tags.railway)) return 'Transit Stations';
                if (['subway', 'light_rail', 'tram'].includes(tags.railway)) return 'Subways';
                return 'Railways';
            }
            if (tags.route === 'bus' || tags.route === 'trolleybus') return 'Bus Routes';
            if (tags.route === 'ferry') return 'Ferry Routes';
            if (tags.amenity === 'bus_station' || tags.amenity === 'ferry_terminal') return 'Transit Stations';
            
            // Landuse areas
            if (tags.landuse === 'industrial') return 'Industrial';
            if (tags.landuse === 'commercial' || tags.landuse === 'retail') return 'Commercial';
            if (tags.landuse === 'residential') return 'Residential Areas';
            
            // Buildings
            if (tags.building) return 'Buildings';
            
            // Land mask (for coastlines)
            if (featureType === FEATURE_TYPES.LAND) return 'Land Mask';
            
            return 'Other';
        }
        
        // Clip a line segment to bounds, returning intersection point if segment crosses boundary
        function lineSegmentClip(p1, p2, minLat, maxLat, minLon, maxLon) {
            // Cohen-Sutherland style clipping for line segment
            const INSIDE = 0, LEFT = 1, RIGHT = 2, BOTTOM = 4, TOP = 8;
            
            function code(p) {
                let c = INSIDE;
                if (p.lon < minLon) c |= LEFT;
                else if (p.lon > maxLon) c |= RIGHT;
                if (p.lat < minLat) c |= BOTTOM;
                else if (p.lat > maxLat) c |= TOP;
                return c;
            }
            
            let c1 = code(p1), c2 = code(p2);
            let x1 = p1.lon, y1 = p1.lat, x2 = p2.lon, y2 = p2.lat;
            
            while (true) {
                if (!(c1 | c2)) {
                    // Both inside
                    return [{ lat: y1, lon: x1 }, { lat: y2, lon: x2 }];
                }
                if (c1 & c2) {
                    // Both outside same region - reject
                    return null;
                }
                
                const cOut = c1 ? c1 : c2;
                let x, y;
                
                if (cOut & TOP) {
                    x = x1 + (x2 - x1) * (maxLat - y1) / (y2 - y1);
                    y = maxLat;
                } else if (cOut & BOTTOM) {
                    x = x1 + (x2 - x1) * (minLat - y1) / (y2 - y1);
                    y = minLat;
                } else if (cOut & RIGHT) {
                    y = y1 + (y2 - y1) * (maxLon - x1) / (x2 - x1);
                    x = maxLon;
                } else if (cOut & LEFT) {
                    y = y1 + (y2 - y1) * (minLon - x1) / (x2 - x1);
                    x = minLon;
                }
                
                if (cOut === c1) {
                    x1 = x; y1 = y;
                    c1 = code({ lat: y1, lon: x1 });
                } else {
                    x2 = x; y2 = y;
                    c2 = code({ lat: y2, lon: x2 });
                }
            }
        }
        
        // Clip a polyline to bounds, returning clipped segments
        function clipPolylineToBounds(points, minLat, maxLat, minLon, maxLon) {
            if (points.length < 2) return points;
            
            const result = [];
            let currentSegment = [];
            
            for (let i = 0; i < points.length - 1; i++) {
                const clipped = lineSegmentClip(points[i], points[i + 1], minLat, maxLat, minLon, maxLon);
                if (clipped) {
                    if (currentSegment.length === 0) {
                        currentSegment.push(clipped[0]);
                    }
                    currentSegment.push(clipped[1]);
                } else if (currentSegment.length > 0) {
                    // Segment rejected, start new segment
                    if (currentSegment.length >= 2) {
                        result.push(...currentSegment);
                    }
                    currentSegment = [];
                }
            }
            
            if (currentSegment.length >= 2) {
                result.push(...currentSegment);
            }
            
            return result.length >= 2 ? result : [];
        }
        
        function convertToHWMap(osmData, options = {}) {
            const sw = selectedBounds.getSouthWest();
            const ne = selectedBounds.getNorthEast();
            const regionName = document.getElementById('regionName').value.substring(0, 7); // Max 7 chars + null
            const outputVersion = options.outputVersion ?? 6;

            if (outputVersion !== 5 && outputVersion !== 6) {
                throw new Error(`Unsupported HWMAP output version: ${outputVersion}`);
            }
            
            // Bounds for clipping
            const clipBounds = {
                minLat: sw.lat, maxLat: ne.lat,
                minLon: sw.lng, maxLon: ne.lng
            };

            const exportLayers = {
                motorways: document.getElementById('motorways')?.checked ?? false,
                trunk: document.getElementById('trunkRoads')?.checked ?? false,
                primary: document.getElementById('primaryRoads')?.checked ?? false,
                secondary: document.getElementById('secondaryRoads')?.checked ?? false,
                tertiary: document.getElementById('tertiaryRoads')?.checked ?? false,
                residentialRoads: document.getElementById('residentialRoads')?.checked ?? false,
                serviceRoads: document.getElementById('serviceRoads')?.checked ?? false,
                footways: document.getElementById('footways')?.checked ?? false,
                cycleways: document.getElementById('cycleways')?.checked ?? false,
                tracks: document.getElementById('tracks')?.checked ?? false,
                waterBodies: document.getElementById('waterBodies')?.checked ?? false,
                waterways: document.getElementById('waterways')?.checked ?? false,
                coastlines: document.getElementById('coastlines')?.checked ?? false,
                landMask: document.getElementById('landMask')?.checked ?? false,
                parks: document.getElementById('parks')?.checked ?? false,
                forests: document.getElementById('forests')?.checked ?? false,
                grassland: document.getElementById('grassland')?.checked ?? false,
                railways: document.getElementById('railways')?.checked ?? false,
                subways: document.getElementById('subways')?.checked ?? false,
                busRoutes: document.getElementById('busRoutes')?.checked ?? false,
                ferryRoutes: document.getElementById('ferryRoutes')?.checked ?? false,
                transitStations: document.getElementById('transitStations')?.checked ?? false,
                buildings: document.getElementById('buildings')?.checked ?? false,
                buildingsLargeOnly: document.getElementById('buildingsLargeOnly')?.checked ?? false,
                industrial: document.getElementById('industrial')?.checked ?? false,
                commercial: document.getElementById('commercial')?.checked ?? false,
                residential: document.getElementById('residential')?.checked ?? false
            };

            function exportLayerEnabledForFeature(tags, featureType) {
                if (!tags) return false;

                if (featureType === FEATURE_TYPES.ROAD_HIGHWAY) {
                    if (['motorway', 'motorway_link'].includes(tags.highway)) return exportLayers.motorways;
                    if (['trunk', 'trunk_link'].includes(tags.highway)) return exportLayers.trunk;
                    return exportLayers.motorways || exportLayers.trunk;
                }
                if (featureType === FEATURE_TYPES.ROAD_MAJOR) {
                    if (['primary', 'primary_link'].includes(tags.highway)) return exportLayers.primary;
                    if (['secondary', 'secondary_link'].includes(tags.highway)) return exportLayers.secondary;
                    return exportLayers.primary || exportLayers.secondary;
                }
                if (featureType === FEATURE_TYPES.ROAD_MINOR) {
                    if (['tertiary', 'tertiary_link', 'unclassified'].includes(tags.highway)) return exportLayers.tertiary;
                    if (['residential', 'living_street'].includes(tags.highway)) return exportLayers.residentialRoads;
                    if (tags.highway === 'service') return exportLayers.serviceRoads;
                    return exportLayers.tertiary || exportLayers.residentialRoads || exportLayers.serviceRoads;
                }
                if (featureType === FEATURE_TYPES.ROAD_PATH) {
                    if (['footway', 'path', 'pedestrian', 'steps'].includes(tags.highway)) return exportLayers.footways;
                    if (tags.highway === 'cycleway') return exportLayers.cycleways;
                    if (['track', 'bridleway'].includes(tags.highway)) return exportLayers.tracks;
                    return exportLayers.footways || exportLayers.cycleways || exportLayers.tracks;
                }
                if (featureType === FEATURE_TYPES.WATER) {
                    const isCoastline = tags.natural === 'coastline' || tags.water === 'coastline_generated' || tags.land === 'coastline_generated' ||
                        tags.natural === 'bay' || tags.natural === 'strait' || tags.harbour || tags.place === 'sea';
                    if (isCoastline) return exportLayers.coastlines;
                    const isWaterwayLine = !!tags.waterway && tags.waterway !== 'riverbank' && tags.natural !== 'coastline' && tags.water !== 'coastline_generated';
                    if (isWaterwayLine) return exportLayers.waterways;
                    return exportLayers.waterBodies;
                }
                if (featureType === FEATURE_TYPES.PARK) {
                    const isForest = tags.natural === 'wood' || tags.landuse === 'forest' || tags.landuse === 'wood';
                    if (isForest) return exportLayers.forests;
                    const isGrassland = tags.landuse === 'grass' || tags.natural === 'grassland' || tags.landuse === 'meadow' ||
                        tags.landuse === 'grassland' || tags.landuse === 'farmland' || tags.natural === 'heath' || tags.natural === 'scrub';
                    if (isGrassland) return exportLayers.grassland;
                    return exportLayers.parks;
                }
                if (featureType === FEATURE_TYPES.LAND) {
                    return exportLayers.landMask && exportLayers.coastlines;
                }
                if (featureType === FEATURE_TYPES.RAILWAY) {
                    if (tags.railway === 'subway') return exportLayers.subways;
                    return exportLayers.railways;
                }
                if (featureType === FEATURE_TYPES.BUS) return exportLayers.busRoutes;
                if (featureType === FEATURE_TYPES.FERRY) return exportLayers.ferryRoutes;
                if (featureType === FEATURE_TYPES.STATION) return exportLayers.transitStations;
                if (featureType === FEATURE_TYPES.BUILDING) {
                    if (tags.building) {
                        return exportLayers.buildings || exportLayers.buildingsLargeOnly;
                    }
                    if (tags.landuse === 'industrial') return exportLayers.industrial;
                    if (tags.landuse === 'commercial' || tags.landuse === 'retail') return exportLayers.commercial;
                    if (tags.landuse === 'residential') return exportLayers.residential;
                    return false;
                }

                return true;
            }
            
            function pointOnSegment2D(p, a, b, eps) {
                const abx = b[0] - a[0];
                const aby = b[1] - a[1];
                const apx = p[0] - a[0];
                const apy = p[1] - a[1];
                const cross = abx * apy - aby * apx;
                if (Math.abs(cross) > eps) return false;
                const dot = apx * abx + apy * aby;
                if (dot < -eps) return false;
                const abLen2 = abx * abx + aby * aby;
                if (dot > abLen2 + eps) return false;
                return true;
            }
            
            function pointOnPolygonBoundary2D(p, poly, eps) {
                if (!poly || poly.length < 2) return false;
                for (let i = 0; i < poly.length; i++) {
                    const a = poly[i];
                    const b = poly[(i + 1) % poly.length];
                    if (pointOnSegment2D(p, a, b, eps)) return true;
                }
                return false;
            }
            
            function polygonSignedArea2D(poly) {
                let a = 0;
                for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                    a += poly[j][0] * poly[i][1] - poly[i][0] * poly[j][1];
                }
                return a * 0.5;
            }
            
            function isConvexPolygon2D(poly) {
                if (!poly || poly.length < 3) return false;
                let sign = 0;
                for (let i = 0; i < poly.length; i++) {
                    const a = poly[i];
                    const b = poly[(i + 1) % poly.length];
                    const c = poly[(i + 2) % poly.length];
                    const abx = b[0] - a[0];
                    const aby = b[1] - a[1];
                    const bcx = c[0] - b[0];
                    const bcy = c[1] - b[1];
                    const cross = abx * bcy - aby * bcx;
                    if (Math.abs(cross) < 1e-15) continue;
                    const s = cross > 0 ? 1 : -1;
                    if (sign === 0) sign = s;
                    else if (sign !== s) return false;
                }
                return true;
            }
            
            function clipPolygonToConvexClip(subject, clipPoly) {
                if (!subject || subject.length < 3) return [];
                if (!clipPoly || clipPoly.length < 3) return subject;
                const clipArea = polygonSignedArea2D(clipPoly);
                const clipIsCCW = clipArea > 0;
                const inside = (p, a, b) => {
                    const cross = (b[0] - a[0]) * (p[1] - a[1]) - (b[1] - a[1]) * (p[0] - a[0]);
                    return clipIsCCW ? cross >= 0 : cross <= 0;
                };
                const intersect = (s, e, a, b) => {
                    const x1 = s[0], y1 = s[1];
                    const x2 = e[0], y2 = e[1];
                    const x3 = a[0], y3 = a[1];
                    const x4 = b[0], y4 = b[1];
                    const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                    if (Math.abs(den) < 1e-20) return e;
                    const px = ((x1*y2 - y1*x2) * (x3 - x4) - (x1 - x2) * (x3*y4 - y3*x4)) / den;
                    const py = ((x1*y2 - y1*x2) * (y3 - y4) - (y1 - y2) * (x3*y4 - y3*x4)) / den;
                    return [px, py];
                };
                
                let output = subject;
                for (let i = 0; i < clipPoly.length; i++) {
                    const a = clipPoly[i];
                    const b = clipPoly[(i + 1) % clipPoly.length];
                    const input = output;
                    output = [];
                    if (!input.length) break;
                    let S = input[input.length - 1];
                    for (const E of input) {
                        const Ein = inside(E, a, b);
                        const Sin = inside(S, a, b);
                        if (Ein) {
                            if (!Sin) output.push(intersect(S, E, a, b));
                            output.push(E);
                        } else if (Sin) {
                            output.push(intersect(S, E, a, b));
                        }
                        S = E;
                    }
                }
                return output;
            }
            
            // Point-in-polygon test for circle/polygon selections
            function pointInPolygon(lon, lat, polygon) {
                if (!polygon || polygon.length < 3) return true;
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const yi = polygon[i][0], xi = polygon[i][1]; // [lat, lng]
                    const yj = polygon[j][0], xj = polygon[j][1];
                    if (((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }
                return inside;
            }
            
            // Check if point is inside selection (polygon or bounds)
            function inSelection(lon, lat) {
                if (lon < clipBounds.minLon || lon > clipBounds.maxLon || 
                    lat < clipBounds.minLat || lat > clipBounds.maxLat) return false;
                if (selectedPolygon) {
                    const eps = Math.min(clipBounds.maxLat - clipBounds.minLat, clipBounds.maxLon - clipBounds.minLon) * 0.0005;
                    const polyLonLat = selectedPolygon.map(p => [p[1], p[0]]);
                    return pointInPolygon(lon, lat, selectedPolygon) || pointOnPolygonBoundary2D([lon, lat], polyLonLat, eps);
                }
                return true;
            }
            
            debugLog('CONVERT', `=== Starting HWMAP v${outputVersion} conversion ===`);
            debugLog('CONVERT', 'Input elements:', osmData.elements?.length || 0);
            
            // Process coastlines into water AND land polygons
            const coastlineBounds = {
                minLat: sw.lat, maxLat: ne.lat,
                minLon: sw.lng, maxLon: ne.lng
            };
            const coastlineProcessingBounds = options.coastlineProcessingBounds || coastlineBounds;
            const coastlineClipBounds = options.coastlineClipBounds || coastlineBounds;
            const coastlineResult = processCoastlines(osmData.elements, coastlineProcessingBounds, coastlineClipBounds);
            const coastlineWaterPolygons = coastlineResult.water || [];
            const coastlineLandPolygons = coastlineResult.land || [];
            debugLog('CONVERT', 'Coastline water polygons:', coastlineWaterPolygons.length);
            debugLog('CONVERT', 'Coastline land polygons:', coastlineLandPolygons.length);
            
            // Add coastline water polygons as synthetic elements
            const elementsWithCoastlineData = [...osmData.elements];
            // Add land mask polygons if enabled
            const includeLandMask = document.getElementById('landMask')?.checked && 
                                    document.getElementById('coastlines')?.checked;
            
            // Add coastline water polygons - they carve out water areas
            // When land mask is enabled, we use INVERTED approach:
            // - Background is LAND color
            // - Water polygons carve out water areas
            // So we ALWAYS need water polygons (they define where water is)
            console.log(`[RAW CONVERT] ========== ADDING COASTLINE POLYGONS ==========`);
            console.log(`[RAW CONVERT] includeLandMask: ${includeLandMask}`);
            console.log(`[RAW CONVERT] coastlineWaterPolygons: ${coastlineWaterPolygons.length}`);
            console.log(`[RAW CONVERT] coastlineLandPolygons: ${coastlineLandPolygons.length}`);
            
            const clipPolyLonLat = selectedPolygon ? selectedPolygon.map(p => [p[1], p[0]]) : null;
            const canPolyClip = !!clipPolyLonLat && isConvexPolygon2D(clipPolyLonLat);
            if (selectedPolygon && !canPolyClip) {
                console.log(`[RAW CONVERT] Polygon selection is non-convex; skipping polygon clipping for coastline-generated polygons`);
            }
            const clipPoly = canPolyClip ? clipPolyLonLat : null;

            const coastlineBBoxArea = (coastlineClipBounds.maxLat - coastlineClipBounds.minLat) * (coastlineClipBounds.maxLon - coastlineClipBounds.minLon);
            
            for (let i = 0; i < coastlineWaterPolygons.length; i++) {
                let polygon = coastlineWaterPolygons[i];
                if (clipPoly) {
                    const ring = polygon.length > 2 && polygon[0].lat === polygon[polygon.length - 1].lat && polygon[0].lon === polygon[polygon.length - 1].lon
                        ? polygon.slice(0, -1)
                        : polygon;
                    const clipped2D = clipPolygonToConvexClip(ring.map(p => [p.lon, p.lat]), clipPoly);
                    polygon = clipped2D.length >= 3 ? clipped2D.map(p => ({ lon: p[0], lat: p[1] })).concat([{ lon: clipped2D[0][0], lat: clipped2D[0][1] }]) : [];
                }
                if (!polygon || polygon.length < 3) continue;

                const ring2 = polygon[0].lat === polygon[polygon.length - 1].lat && polygon[0].lon === polygon[polygon.length - 1].lon
                    ? polygon.slice(0, -1)
                    : polygon;
                const signedArea = polygonSignedArea2D(ring2.map(p => [p.lon, p.lat]));
                const absArea = Math.abs(signedArea);
                if (coastlineBBoxArea > 0 && absArea > coastlineBBoxArea * 1.05) {
                    console.log(`[RAW CONVERT] Skipping invalid coastline water polygon: pts=${polygon.length}, absArea=${absArea.toFixed(6)} (${(absArea / coastlineBBoxArea * 100).toFixed(1)}% of bbox)`);
                    continue;
                }

                const lats = polygon.map(p => p.lat);
                const lons = polygon.map(p => p.lon);
                console.log(`[RAW ADD WATER ${i}] pts=${polygon.length}`);
                console.log(`  lat: ${Math.min(...lats).toFixed(6)} to ${Math.max(...lats).toFixed(6)}`);
                console.log(`  lon: ${Math.min(...lons).toFixed(6)} to ${Math.max(...lons).toFixed(6)}`);
                console.log(`  first: (${polygon[0]?.lat?.toFixed(6)}, ${polygon[0]?.lon?.toFixed(6)})`);
                console.log(`  last: (${polygon[polygon.length-1]?.lat?.toFixed(6)}, ${polygon[polygon.length-1]?.lon?.toFixed(6)})`);
                elementsWithCoastlineData.push({
                    type: 'way',
                    tags: { natural: 'water', water: 'coastline_generated' },
                    geometry: polygon
                });
            }
            if (includeLandMask) {
                for (let i = 0; i < coastlineLandPolygons.length; i++) {
                    let polygon = coastlineLandPolygons[i];
                    if (clipPoly) {
                        const ring = polygon.length > 2 && polygon[0].lat === polygon[polygon.length - 1].lat && polygon[0].lon === polygon[polygon.length - 1].lon
                            ? polygon.slice(0, -1)
                            : polygon;
                        const clipped2D = clipPolygonToConvexClip(ring.map(p => [p.lon, p.lat]), clipPoly);
                        polygon = clipped2D.length >= 3 ? clipped2D.map(p => ({ lon: p[0], lat: p[1] })).concat([{ lon: clipped2D[0][0], lat: clipped2D[0][1] }]) : [];
                    }
                    if (!polygon || polygon.length < 3) continue;
                    const lats = polygon.map(p => p.lat);
                    const lons = polygon.map(p => p.lon);
                    console.log(`[RAW ADD LAND ${i}] pts=${polygon.length}`);
                    console.log(`  lat: ${Math.min(...lats).toFixed(6)} to ${Math.max(...lats).toFixed(6)}`);
                    console.log(`  lon: ${Math.min(...lons).toFixed(6)} to ${Math.max(...lons).toFixed(6)}`);
                    console.log(`  first: (${polygon[0]?.lat?.toFixed(6)}, ${polygon[0]?.lon?.toFixed(6)})`);
                    console.log(`  last: (${polygon[polygon.length-1]?.lat?.toFixed(6)}, ${polygon[polygon.length-1]?.lon?.toFixed(6)})`);
                    elementsWithCoastlineData.push({
                        type: 'way',
                        tags: { landuse: 'land_mask', land: 'coastline_generated' },
                        geometry: polygon
                    });
                }
                console.log(`[RAW CONVERT] Added ${coastlineLandPolygons.length} land mask polygons`);
            }
            console.log(`[RAW CONVERT] ================================================`);
            
            // Process features
            let features = [];
            // Full detail mode - no global quality clamping
            const maxPointsPerFeature = 2048; // Effectively unlimited - type-specific simplification handles limits
            const autoFitBudget = document.getElementById('autoFitBudget').checked;
            const budgetBytes = parseInt(document.getElementById('sizeBudget').value) * 1024;
            
            // Use finest tolerance for maximum detail
            const tolerance = 0.00005;
            
            debugLog('CONVERT', 'Full detail mode - type-specific simplification handles reduction');
            debugLog('CONVERT', 'Auto-fit budget:', autoFitBudget, 'Budget:', budgetBytes, 'bytes');
            
            // Name detail level: 0=none, 1=highways, 2=major roads, 3=all roads, 4=everything
            const nameDetailLevel = parseInt(document.getElementById('nameDetail').value);
            debugLog('CONVERT', 'Name detail level:', nameDetailLevel);
            
            // Name table: map name string -> index, and list of unique names
            const nameMap = new Map();  // name -> index
            const nameList = [];        // ordered list of unique names
            
            // Check if a feature type should get a name based on name detail level
            const includeBuildingNames = document.getElementById('buildingNames')?.checked || false;
            
            function shouldIncludeName(featureType) {
                // Building names controlled by separate checkbox
                if (featureType === FEATURE_TYPES.BUILDING) {
                    return includeBuildingNames;
                }
                
                if (nameDetailLevel === 0) return false;  // None
                if (nameDetailLevel === 1) {
                    // Highways only
                    return featureType === FEATURE_TYPES.ROAD_HIGHWAY;
                }
                if (nameDetailLevel === 2) {
                    // Major roads (highways + major)
                    return featureType === FEATURE_TYPES.ROAD_HIGHWAY || 
                           featureType === FEATURE_TYPES.ROAD_MAJOR;
                }
                if (nameDetailLevel === 3) {
                    // All roads
                    return featureType === FEATURE_TYPES.ROAD_HIGHWAY || 
                           featureType === FEATURE_TYPES.ROAD_MAJOR ||
                           featureType === FEATURE_TYPES.ROAD_MINOR ||
                           featureType === FEATURE_TYPES.ROAD_PATH;
                }
                // Level 4 = everything (except buildings, handled above)
                return true;
            }
            
            function getOrAddName(name, featureType) {
                if (!name || name.length === 0) return HWMAP_NO_NAME;
                if (!shouldIncludeName(featureType)) return HWMAP_NO_NAME;
                
                // Truncate to 63 chars max (stored as uint8 length)
                const truncated = name.substring(0, 63);
                if (nameMap.has(truncated)) {
                    return nameMap.get(truncated);
                }
                const idx = nameList.length;
                nameMap.set(truncated, idx);
                nameList.push(truncated);
                return idx;
            }
            
            let skippedNoGeom = 0;
            let skippedNoType = 0;
            let skippedTooShort = 0;
            let skippedDisabled = 0;
            
            // Feature priority (lower = more important, keep first)
            const typePriority = {
                0x12: 0,  // Land mask - HIGHEST priority (essential for water rendering)
                0x00: 1,  // Highway - most important
                0x01: 2,  // Major road
                0x10: 3,  // Water (landmarks)
                0x20: 4,  // Railway
                0x40: 4,  // Transit station (same priority as railway)
                0x22: 5,  // Ferry (useful landmark)
                0x02: 6,  // Minor road
                0x11: 7,  // Park
                0x03: 8,  // Path - least important road
                0x21: 9,  // Bus route - low priority (many routes)
                0x30: 10  // Building - least important
            };
            
            // Helper to extract geometries from element (handles both ways and relations)
            // Track processed way refs to avoid duplicates from shared relation members
            const convertProcessedRefs = new Set();
            
            function getConvertGeometries(element) {
                if (element.type === 'way' && element.geometry) {
                    return [{ geometry: element.geometry, tags: element.tags }];
                }
                if (element.type === 'relation' && element.members) {
                    const geometries = [];
                    const MAX_MEMBERS_PER_RELATION = 50;  // Limit complexity, but allow dense areas
                    let memberCount = 0;
                    
                    for (const member of element.members) {
                        if (memberCount >= MAX_MEMBERS_PER_RELATION) break;
                        if (!member.geometry || member.role === 'inner') continue;
                        if (member.geometry.length < 4) continue;  // Skip tiny fragments
                        
                        // Skip if this way was already processed (deduplication)
                        if (member.ref && convertProcessedRefs.has(member.ref)) continue;
                        if (member.ref) convertProcessedRefs.add(member.ref);
                        
                        geometries.push({ geometry: member.geometry, tags: element.tags });
                        memberCount++;
                    }
                    return geometries;
                }
                return [];
            }
            
            for (const element of elementsWithCoastlineData) {
                const elementGeometries = getConvertGeometries(element);
                if (elementGeometries.length === 0) {
                    skippedNoGeom++;
                    continue;
                }
                
                for (const { geometry: elemGeom, tags: elemTags } of elementGeometries) {
                const featureType = classifyFeature(elemTags);
                if (featureType === null) {
                    skippedNoType++;
                    continue;
                }

                if (!exportLayerEnabledForFeature(elemTags, featureType)) {
                    skippedDisabled++;
                    continue;
                }
                
                // Simplify geometry based on detail level
                // LAND MASK and COASTLINE WATER features are kept RAW - need full detail for accurate rendering
                const isLandMask = featureType === FEATURE_TYPES.LAND;
                const isCoastlineWater = featureType === FEATURE_TYPES.WATER && elemTags?.water === 'coastline_generated';
                
                // RAW DATA: Log every water and land feature being processed
                if ((elemTags?.water === 'coastline_generated' || elemTags?.land === 'coastline_generated') && DEBUG && LOG_LEVEL >= 2) {
                    const lats = elemGeom.map(p => p.lat);
                    const lons = elemGeom.map(p => p.lon);
                    const isWater = elemTags?.water === 'coastline_generated';
                    console.log(`[RAW FEATURE] ${isWater ? 'WATER' : 'LAND'} coastline_generated`);
                    console.log(`  featureType: ${featureType}`);
                    console.log(`  pts: ${elemGeom?.length}`);
                    console.log(`  lat: ${Math.min(...lats).toFixed(6)} to ${Math.max(...lats).toFixed(6)}`);
                    console.log(`  lon: ${Math.min(...lons).toFixed(6)} to ${Math.max(...lons).toFixed(6)}`);
                }
                
                let points;
                if (isLandMask || isCoastlineWater) {
                    // Keep coastline geometry raw - need full detail for proper water/land boundaries
                    points = elemGeom.map(p => ({ lat: p.lat, lon: p.lon }));
                } else {
                    points = simplifyPoints(elemGeom, tolerance);
                }
                if (points.length < 2) {
                    skippedTooShort++;
                    continue;
                }
                
                // Clip linear features (roads, paths, rails, transit) to selection bounds
                const isWaterwayLine = featureType === FEATURE_TYPES.WATER &&
                    elemTags?.waterway &&
                    elemTags.waterway !== 'riverbank' &&
                    elemTags.natural !== 'coastline' &&
                    elemTags.water !== 'coastline_generated';
                const isLinearFeature = featureType === FEATURE_TYPES.ROAD_HIGHWAY ||
                    featureType === FEATURE_TYPES.ROAD_MAJOR ||
                    featureType === FEATURE_TYPES.ROAD_MINOR ||
                    featureType === FEATURE_TYPES.ROAD_PATH ||
                    featureType === FEATURE_TYPES.RAILWAY ||
                    featureType === FEATURE_TYPES.BUS ||
                    featureType === FEATURE_TYPES.FERRY ||
                    isWaterwayLine;
                
                if (isLinearFeature) {
                    points = clipPolylineToBounds(points, clipBounds.minLat, clipBounds.maxLat, clipBounds.minLon, clipBounds.maxLon);
                    if (points.length < 2) {
                        skippedTooShort++;
                        continue;
                    }
                    // For polygon/circle selections, filter to only points inside selection
                    if (selectedPolygon) {
                        points = points.filter(p => inSelection(p.lon, p.lat));
                        if (points.length < 2) {
                            skippedTooShort++;
                            continue;
                        }
                    }
                } else if (selectedPolygon && !isLandMask && !isCoastlineWater) {
                    // For non-linear features with polygon selection, filter points
                    // SKIP for land mask and coastline water - they're already clipped during coastline processing
                    points = points.filter(p => inSelection(p.lon, p.lat));
                    if (points.length < 2) {
                        skippedTooShort++;
                        continue;
                    }
                }
                
                // === LARGE BUILDINGS ONLY FILTER ===
                // Skip small buildings when "Large only" is checked
                const buildingsLargeOnlyChecked = document.getElementById('buildingsLargeOnly')?.checked;
                if (featureType === FEATURE_TYPES.BUILDING && buildingsLargeOnlyChecked && elemTags?.building) {
                    const minFloors = parseInt(document.getElementById('buildingMinFloors')?.value || 3);
                    const minAreaM2 = parseInt(document.getElementById('buildingMinArea')?.value || 200);
                    // Check building:levels tag first
                    const levels = parseInt(elemTags?.['building:levels'] || '0');
                    if (levels >= minFloors) {
                        // Keep - has enough floors
                    } else {
                        // Calculate polygon area in m² to filter by size
                        let areaM2 = 0;
                        if (points.length >= 3) {
                            // Shoelace formula for polygon area
                            let sum = 0;
                            for (let i = 0; i < points.length; i++) {
                                const j = (i + 1) % points.length;
                                // Convert to approximate meters
                                const lat1 = points[i].lat * Math.PI / 180;
                                const lat2 = points[j].lat * Math.PI / 180;
                                const lon1 = points[i].lon * Math.PI / 180;
                                const lon2 = points[j].lon * Math.PI / 180;
                                // Use spherical excess formula approximation
                                const x1 = lon1 * Math.cos((lat1 + lat2) / 2) * 6371000;
                                const y1 = lat1 * 6371000;
                                const x2 = lon2 * Math.cos((lat1 + lat2) / 2) * 6371000;
                                const y2 = lat2 * 6371000;
                                sum += (x1 * y2 - x2 * y1);
                            }
                            areaM2 = Math.abs(sum / 2);
                        }
                        // Skip buildings smaller than threshold
                        if (areaM2 < minAreaM2) {
                            skippedTooShort++;
                            continue;
                        }
                    }
                }
                
                // === TYPE-SPECIFIC SIMPLIFICATION ===
                // Highways - Motorways
                const simplifyMotorwaysChecked = document.getElementById('simplifyMotorways')?.checked;
                const motorwaysSimplifyPts = parseInt(document.getElementById('motorwaysSimplifyPoints')?.value || 15);
                if (featureType === FEATURE_TYPES.ROAD_HIGHWAY && simplifyMotorwaysChecked && 
                    elemTags?.highway === 'motorway' && points.length > motorwaysSimplifyPts) {
                    points = simplifyRoad(points, motorwaysSimplifyPts, tolerance * 2);
                }
                
                // Highways - Trunk
                const simplifyTrunkChecked = document.getElementById('simplifyTrunk')?.checked;
                const trunkSimplifyPts = parseInt(document.getElementById('trunkSimplifyPoints')?.value || 12);
                if (featureType === FEATURE_TYPES.ROAD_HIGHWAY && simplifyTrunkChecked && 
                    elemTags?.highway === 'trunk' && points.length > trunkSimplifyPts) {
                    points = simplifyRoad(points, trunkSimplifyPts, tolerance * 2);
                }
                
                // Roads - Primary
                const simplifyPrimaryChecked = document.getElementById('simplifyPrimary')?.checked;
                const primarySimplifyPts = parseInt(document.getElementById('primarySimplifyPoints')?.value || 10);
                if (featureType === FEATURE_TYPES.ROAD_MAJOR && simplifyPrimaryChecked && 
                    elemTags?.highway === 'primary' && points.length > primarySimplifyPts) {
                    points = simplifyRoad(points, primarySimplifyPts, tolerance * 2);
                }
                
                // Roads - Secondary
                const simplifySecondaryChecked = document.getElementById('simplifySecondary')?.checked;
                const secondarySimplifyPts = parseInt(document.getElementById('secondarySimplifyPoints')?.value || 8);
                if (featureType === FEATURE_TYPES.ROAD_MAJOR && simplifySecondaryChecked && 
                    elemTags?.highway === 'secondary' && points.length > secondarySimplifyPts) {
                    points = simplifyRoad(points, secondarySimplifyPts, tolerance * 2);
                }
                
                // Roads - Tertiary
                const simplifyTertiaryChecked = document.getElementById('simplifyTertiary')?.checked;
                const tertiarySimplifyPts = parseInt(document.getElementById('tertiarySimplifyPoints')?.value || 6);
                if (featureType === FEATURE_TYPES.ROAD_MINOR && simplifyTertiaryChecked && 
                    elemTags?.highway === 'tertiary' && points.length > tertiarySimplifyPts) {
                    points = simplifyRoad(points, tertiarySimplifyPts, tolerance * 2);
                }
                
                // Roads - Residential
                const simplifyResidentialChecked = document.getElementById('simplifyResidential')?.checked;
                const residentialSimplifyPts = parseInt(document.getElementById('residentialSimplifyPoints')?.value || 4);
                if (featureType === FEATURE_TYPES.ROAD_MINOR && simplifyResidentialChecked && 
                    elemTags?.highway === 'residential' && points.length > residentialSimplifyPts) {
                    points = simplifyRoad(points, residentialSimplifyPts, tolerance * 3);
                }
                
                // Roads - Service
                const simplifyServiceChecked = document.getElementById('simplifyService')?.checked;
                const serviceSimplifyPts = parseInt(document.getElementById('serviceSimplifyPoints')?.value || 4);
                if (featureType === FEATURE_TYPES.ROAD_MINOR && simplifyServiceChecked && 
                    elemTags?.highway === 'service' && points.length > serviceSimplifyPts) {
                    points = simplifyRoad(points, serviceSimplifyPts, tolerance * 3);
                }
                
                // Paths (with min length filter)
                const simplifyPathsChecked = document.getElementById('simplifyPaths')?.checked;
                const pathsSimplifyPts = parseInt(document.getElementById('pathsSimplifyPoints')?.value || 6);
                if (featureType === FEATURE_TYPES.ROAD_PATH) {
                    // Min length filter (independent of simplification)
                    const minPathLength = parseInt(document.getElementById('pathMinLength')?.value || 0);
                    if (minPathLength > 0) {
                        let pathLengthM = 0;
                        for (let i = 1; i < points.length; i++) {
                            const dLat = (points[i].lat - points[i-1].lat) * 111000;
                            const dLon = (points[i].lon - points[i-1].lon) * 111000 * Math.cos(points[i].lat * Math.PI / 180);
                            pathLengthM += Math.sqrt(dLat*dLat + dLon*dLon);
                        }
                        if (pathLengthM < minPathLength) {
                            skippedTooShort++;
                            continue;
                        }
                    }
                    // Simplification
                    if (simplifyPathsChecked && points.length > pathsSimplifyPts) {
                        points = simplifyRoad(points, pathsSimplifyPts, tolerance * 3);
                    }
                }
                
                // Bus routes
                const simplifyBusChecked = document.getElementById('simplifyBus')?.checked;
                const busSimplifyPts = parseInt(document.getElementById('busSimplifyPoints')?.value || 12);
                if (featureType === FEATURE_TYPES.BUS && simplifyBusChecked && points.length > busSimplifyPts) {
                    points = simplifyRoad(points, busSimplifyPts, tolerance * 3);
                }
                
                // Rail routes
                const simplifyRailChecked = document.getElementById('simplifyRail')?.checked;
                const railSimplifyPts = parseInt(document.getElementById('railSimplifyPoints')?.value || 12);
                if (featureType === FEATURE_TYPES.RAILWAY && simplifyRailChecked && points.length > railSimplifyPts) {
                    points = simplifyRoad(points, railSimplifyPts, tolerance * 2);
                }
                
                // Ferry routes
                const simplifyFerryChecked = document.getElementById('simplifyFerry')?.checked;
                const ferrySimplifyPts = parseInt(document.getElementById('ferrySimplifyPoints')?.value || 12);
                if (featureType === FEATURE_TYPES.FERRY && simplifyFerryChecked && points.length > ferrySimplifyPts) {
                    points = simplifyRoad(points, ferrySimplifyPts, tolerance * 2);
                }
                
                // Transit stations
                const simplifyStationsChecked = document.getElementById('simplifyStations')?.checked;
                const stationsSimplifyPts = parseInt(document.getElementById('stationsSimplifyPoints')?.value || 12);
                if (featureType === FEATURE_TYPES.STATION && simplifyStationsChecked && points.length > stationsSimplifyPts) {
                    points = simplifyRoad(points, stationsSimplifyPts, tolerance * 2);
                }
                
                // Bridges
                const simplifyBridgesChecked = document.getElementById('simplifyBridges')?.checked;
                const bridgesSimplifyPts = parseInt(document.getElementById('bridgesSimplifyPoints')?.value || 12);
                if (elemTags?.bridge && simplifyBridgesChecked && points.length > bridgesSimplifyPts) {
                    points = simplifyRoad(points, bridgesSimplifyPts, tolerance * 2);
                }
                
                // Industrial areas
                const simplifyIndustrialChecked = document.getElementById('simplifyIndustrial')?.checked;
                const industrialSimplifyPts = parseInt(document.getElementById('industrialSimplifyPoints')?.value || 12);
                if (featureType === FEATURE_TYPES.BUILDING && elemTags?.landuse === 'industrial' && simplifyIndustrialChecked && points.length > industrialSimplifyPts) {
                    points = simplifyRoad(points, industrialSimplifyPts, tolerance * 2);
                }
                
                // Commercial areas
                const simplifyCommercialChecked = document.getElementById('simplifyCommercial')?.checked;
                const commercialSimplifyPts = parseInt(document.getElementById('commercialSimplifyPoints')?.value || 12);
                if (featureType === FEATURE_TYPES.BUILDING && (elemTags?.landuse === 'commercial' || elemTags?.landuse === 'retail') && simplifyCommercialChecked && points.length > commercialSimplifyPts) {
                    points = simplifyRoad(points, commercialSimplifyPts, tolerance * 2);
                }
                
                // Residential areas
                const simplifyResidentialAreaChecked = document.getElementById('simplifyResidentialArea')?.checked;
                const residentialAreaSimplifyPts = parseInt(document.getElementById('residentialAreaSimplifyPoints')?.value || 12);
                if (featureType === FEATURE_TYPES.BUILDING && elemTags?.landuse === 'residential' && simplifyResidentialAreaChecked && points.length > residentialAreaSimplifyPts) {
                    points = simplifyRoad(points, residentialAreaSimplifyPts, tolerance * 2);
                }
                
                // Limit points per feature (applied AFTER all specific simplifications)
                // This acts as a final cap on complexity
                // Land mask and coastline water - keep full detail to preserve coastline shape
                // This format allows up to 65535 points per feature
                // Resampling coastlines was causing visual artifacts (diagonal lines, distorted shapes)
                if (isLandMask || isCoastlineWater) {
                    const typeStr = isCoastlineWater ? 'COASTLINE_WATER' : 'LAND_MASK';
                    debugLog('SIMPLIFY', `${typeStr}: keeping full detail (no resampling, no point limit)`);
                    // Keep full detail
                    const COASTLINE_MAX = 2048; // Higher limit, only resample very large polygons
                    if (points.length > COASTLINE_MAX) {
                        const fp = points[0], lp = points[points.length-1];
                        const latDiff = Math.abs(fp.lat - lp.lat);
                        const lonDiff = Math.abs(fp.lon - lp.lon);
                        console.log(`[${typeStr} RESAMPLE] BEFORE: ${points.length} pts, first=(${fp.lat?.toFixed(6)},${fp.lon?.toFixed(6)}), last=(${lp.lat?.toFixed(6)},${lp.lon?.toFixed(6)}), closed=${latDiff < 0.00001 && lonDiff < 0.00001}`);
                        points = resamplePoints(points, 512);
                        const fp2 = points[0], lp2 = points[points.length-1];
                        const latDiff2 = Math.abs(fp2.lat - lp2.lat);
                        const lonDiff2 = Math.abs(fp2.lon - lp2.lon);
                        console.log(`[${typeStr} RESAMPLE] AFTER: ${points.length} pts, first=(${fp2.lat?.toFixed(6)},${fp2.lon?.toFixed(6)}), last=(${lp2.lat?.toFixed(6)},${lp2.lon?.toFixed(6)}), closed=${latDiff2 < 0.00001 && lonDiff2 < 0.00001}`);
                    } else {
                        console.log(`[${typeStr}] ${points.length} pts (no resample needed)`);
                    }
                } else {
                    // Type-specific simplification handles all reduction based on checkbox state
                    // No forced global simplification
                }
                
                // Extract name from OSM tags (ref takes priority for highways)
                let featureName = null;
                if (elemTags) {
                    if (elemTags.ref && elemTags.name) {
                        featureName = elemTags.ref + ' ' + elemTags.name;
                    } else {
                        featureName = elemTags.ref || elemTags.name || null;
                    }
                }
                const nameIndex = getOrAddName(featureName, featureType);
                
                // Calculate feature length for priority sorting
                let length = 0;
                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].lon - points[i-1].lon;
                    const dy = points[i].lat - points[i-1].lat;
                    length += Math.sqrt(dx*dx + dy*dy);
                }
                
                features.push({
                    type: featureType,
                    subtype: getHWMapSubtype(elemTags, featureType),
                    points: points,
                    nameIndex: nameIndex,
                    priority: typePriority[featureType] || 99,
                    length: length,
                    sourceType: getGranularTypeName(elemTags, featureType)  // Granular type for breakdown display
                });
                }  // end elementGeometries loop
            }
            
            debugLog('CONVERT', 'Skipped - no geometry:', skippedNoGeom);
            debugLog('CONVERT', 'Skipped - no type match:', skippedNoType);
            debugLog('CONVERT', 'Skipped - disabled by checkbox:', skippedDisabled);
            debugLog('CONVERT', 'Skipped - too short:', skippedTooShort);
            debugLog('CONVERT', 'Features before trimming:', features.length);
            debugLog('CONVERT', 'Unique names collected:', nameList.length);
            
            // RAW DATA: Log final feature counts by type
            console.log(`[RAW FEATURES] ========== FINAL FEATURE COUNTS ==========`);
            const featureTypeCounts = {};
            const featureTypeNames = {
                0x00: 'HIGHWAY', 0x01: 'MAJOR', 0x02: 'MINOR', 0x03: 'PATH',
                0x10: 'WATER', 0x11: 'PARK', 0x12: 'LAND', 0x20: 'RAILWAY',
                0x21: 'BUS', 0x22: 'FERRY', 0x30: 'BUILDING', 0x40: 'STATION'
            };
            features.forEach(f => {
                const name = featureTypeNames[f.type] || `0x${f.type.toString(16)}`;
                featureTypeCounts[name] = (featureTypeCounts[name] || 0) + 1;
            });
            Object.entries(featureTypeCounts).forEach(([name, count]) => {
                console.log(`  [RAW] ${name}: ${count}`);
            });
            console.log(`[RAW FEATURES] Total: ${features.length}`);
            console.log(`[RAW FEATURES] ==========================================`);
            
            // Track pre-trimming counts by type
            const preTrimTypeNames = {
                [FEATURE_TYPES.ROAD_HIGHWAY]: 'Highways',
                [FEATURE_TYPES.ROAD_MAJOR]: 'Major Roads',
                [FEATURE_TYPES.ROAD_MINOR]: 'Minor Roads',
                [FEATURE_TYPES.ROAD_PATH]: 'Paths',
                [FEATURE_TYPES.WATER]: 'Water',
                [FEATURE_TYPES.PARK]: 'Parks/Nature',
                [FEATURE_TYPES.LAND]: 'Land Mask',
                [FEATURE_TYPES.RAILWAY]: 'Railways',
                [FEATURE_TYPES.BUS]: 'Bus Routes',
                [FEATURE_TYPES.FERRY]: 'Ferries',
                [FEATURE_TYPES.BUILDING]: 'Buildings',
                [FEATURE_TYPES.STATION]: 'Stations'
            };
            const preTrimCounts = {};
            for (const f of features) {
                const typeName = preTrimTypeNames[f.type] || 'Other';
                preTrimCounts[typeName] = (preTrimCounts[typeName] || 0) + 1;
            }
            const totalBeforeTrim = features.length;
            
            // Sort by priority (important first), then by length (longer = more important)
            features.sort((a, b) => {
                if (a.priority !== b.priority) return a.priority - b.priority;
                return b.length - a.length; // Longer roads first within same priority
            });
            
            // Note: No max features limit - user controls exactly what they want via checkboxes
            
            // Calculate name table size
            let nameTableSize = 0;
            for (const name of nameList) {
                nameTableSize += 1 + name.length; // length byte + string bytes
            }
            
            // Auto-fit to budget by dropping least important features
            // Feature size: type(1) + nameIndex(2) + pointCount(1) + firstPoint(8) + deltas((n-1)*4)
            let trimmedFeatures = features;
            if (autoFitBudget) {
                let currentSize = 40 + nameTableSize; // Header + name table
                trimmedFeatures = [];
                for (const f of features) {
                    const featureSize = 4 + 8 + (f.points.length - 1) * 4; // type + nameIdx + count + points
                    if (currentSize + featureSize <= budgetBytes) {
                        trimmedFeatures.push(f);
                        currentSize += featureSize;
                    }
                }
                debugLog('CONVERT', 'Trimmed to budget:', trimmedFeatures.length, 'features,', currentSize, 'bytes');
            }
            
            debugLog('CONVERT', 'Final feature count:', trimmedFeatures.length);
            
            // Rebuild name table with only names used by trimmed features
            const usedNameIndices = new Set();
            for (const f of trimmedFeatures) {
                if (f.nameIndex !== HWMAP_NO_NAME) {
                    usedNameIndices.add(f.nameIndex);
                }
            }
            
            // Create compact name list and remap indices
            const finalNameList = [];
            const indexRemap = new Map();
            for (const oldIdx of Array.from(usedNameIndices).sort((a, b) => a - b)) {
                indexRemap.set(oldIdx, finalNameList.length);
                finalNameList.push(nameList[oldIdx]);
            }
            
            // Update feature name indices
            for (const f of trimmedFeatures) {
                if (f.nameIndex !== HWMAP_NO_NAME) {
                    f.nameIndex = indexRemap.get(f.nameIndex);
                }
            }
            
            debugLog('CONVERT', 'Names after trimming:', finalNameList.length);
            
            // Log point distribution and track bytes per feature type (using granular sourceType)
            let totalPoints = 0;
            let maxPts = 0;
            let namedCount = 0;
            const typeBreakdown = {};
            for (const f of trimmedFeatures) {
                totalPoints += f.points.length;
                if (f.points.length > maxPts) maxPts = f.points.length;
                if (f.nameIndex !== HWMAP_NO_NAME) namedCount++;
                // Track bytes per type: type(1) + nameIdx(2) + count(2) + firstPt(8) + deltas((n-1)*4)
                const featureBytes = 5 + 8 + (f.points.length - 1) * 4;
                // Use granular sourceType for breakdown display (matches estimate breakdown)
                const typeName = f.sourceType || 'Other';
                if (!typeBreakdown[typeName]) typeBreakdown[typeName] = { bytes: 0, count: 0 };
                typeBreakdown[typeName].bytes += featureBytes;
                typeBreakdown[typeName].count++;
            }
            debugLog('CONVERT', 'Total points:', totalPoints, 'Max points per feature:', maxPts);
            debugLog('CONVERT', 'Named features:', namedCount, '/', trimmedFeatures.length);
            
            // Update feature count display
            document.getElementById('featureCount').textContent = trimmedFeatures.length;
            
            // Calculate name table size (final)
            let finalNameTableSize = 0;
            for (const name of finalNameList) {
                finalNameTableSize += 1 + name.length;
            }

            if (outputVersion === 5 || outputVersion === 6) {
                // Read v5 format settings from UI
                const tileGridSize = parseInt(document.getElementById('v5TileGrid')?.value || '32');
                const haloPct = parseInt(document.getElementById('v5HaloPct')?.value || '10');
                const haloFraction = haloPct / 100;
                const quantBits = parseInt(document.getElementById('v5QuantBits')?.value || '16');
                const tileCount = tileGridSize * tileGridSize;
                
                // Compute flags bitfield for v5 header
                const tileGridCode = tileGridSize === 16 ? 0 : tileGridSize === 64 ? 2 : 1;
                const haloPctClamped = Math.max(0, Math.min(31, haloPct));
                const quantBitsEnc = Math.max(0, Math.min(15, quantBits - 10));
                const v5Flags = tileGridCode | (haloPctClamped << 2) | (quantBitsEnc << 7);

                const tileWidth = (ne.lng - sw.lng) / tileGridSize;
                const tileHeight = (ne.lat - sw.lat) / tileGridSize;
                const haloLon = tileWidth * haloFraction;
                const haloLat = tileHeight * haloFraction;

                const closeEps = 1e-12;
                const clampU16 = (v) => (v < 0 ? 0 : v > 65535 ? 65535 : v);
                const isClosedRing = (pts) => {
                    if (!pts || pts.length < 3) return false;
                    const a = pts[0];
                    const b = pts[pts.length - 1];
                    return Math.abs(a.lat - b.lat) < closeEps && Math.abs(a.lon - b.lon) < closeEps;
                };

                const rectPoly = (minLon, minLat, maxLon, maxLat) => [
                    [minLon, minLat],
                    [maxLon, minLat],
                    [maxLon, maxLat],
                    [minLon, maxLat]
                ];

                const clipPolygonToRect = (pts, minLon, minLat, maxLon, maxLat) => {
                    const ring = isClosedRing(pts) ? pts.slice(0, -1) : pts;
                    if (!ring || ring.length < 3) return [];
                    const clipped2D = clipPolygonToConvexClip(
                        ring.map(p => [p.lon, p.lat]),
                        rectPoly(minLon, minLat, maxLon, maxLat)
                    );
                    if (!clipped2D || clipped2D.length < 3) return [];
                    const out = clipped2D.map(p => ({ lon: p[0], lat: p[1] }));
                    out.push({ ...out[0] });
                    return out;
                };

                const clipPolylineToRectSegments = (pts, minLon, minLat, maxLon, maxLat) => {
                    if (!pts || pts.length < 2) return [];
                    const segments = [];
                    let current = [];
                    for (let i = 0; i < pts.length - 1; i++) {
                        const clipped = lineSegmentClip(pts[i], pts[i + 1], minLat, maxLat, minLon, maxLon);
                        if (clipped) {
                            if (current.length === 0) current.push(clipped[0]);
                            current.push(clipped[1]);
                        } else {
                            if (current.length >= 2) segments.push(current);
                            current = [];
                        }
                    }
                    if (current.length >= 2) segments.push(current);
                    return segments;
                };

                const quantizePoints = (pts, minLon, minLat, maxLon, maxLat) => {
                    const lonRange = maxLon - minLon;
                    const latRange = maxLat - minLat;
                    if (lonRange <= 0 || latRange <= 0) return [];
                    
                    // Quantization snapping based on quantBits setting
                    const qMax = (1 << quantBits) - 1;
                    const scale = 65535 / qMax;
                    
                    const out = [];
                    let lastLat = -1;
                    let lastLon = -1;
                    for (const p of pts) {
                        // Compute raw uint16 value
                        const rawLat = clampU16(Math.round(((p.lat - minLat) / latRange) * 65535));
                        const rawLon = clampU16(Math.round(((p.lon - minLon) / lonRange) * 65535));
                        
                        // Snap to quantization grid (lower quantBits = coarser grid = blockier)
                        const qLat = clampU16(Math.round(Math.round(rawLat / scale) * scale));
                        const qLon = clampU16(Math.round(Math.round(rawLon / scale) * scale));
                        
                        if (qLat === lastLat && qLon === lastLon) continue;
                        out.push({ lat: qLat, lon: qLon });
                        lastLat = qLat;
                        lastLon = qLon;
                    }
                    return out;
                };

                const tiles = Array(tileCount).fill(null).map(() => []);

                for (const f of trimmedFeatures) {
                    const pts = f.points;
                    if (!pts || pts.length < 2) continue;

                    let fMinLat = Infinity, fMaxLat = -Infinity;
                    let fMinLon = Infinity, fMaxLon = -Infinity;
                    for (const p of pts) {
                        if (p.lat < fMinLat) fMinLat = p.lat;
                        if (p.lat > fMaxLat) fMaxLat = p.lat;
                        if (p.lon < fMinLon) fMinLon = p.lon;
                        if (p.lon > fMaxLon) fMaxLon = p.lon;
                    }

                    let minTileX = Math.floor(((fMinLon - haloLon) - sw.lng) / tileWidth);
                    let maxTileX = Math.floor(((fMaxLon + haloLon) - sw.lng) / tileWidth);
                    let minTileY = Math.floor(((fMinLat - haloLat) - sw.lat) / tileHeight);
                    let maxTileY = Math.floor(((fMaxLat + haloLat) - sw.lat) / tileHeight);

                    minTileX = Math.max(0, Math.min(tileGridSize - 1, minTileX));
                    maxTileX = Math.max(0, Math.min(tileGridSize - 1, maxTileX));
                    minTileY = Math.max(0, Math.min(tileGridSize - 1, minTileY));
                    maxTileY = Math.max(0, Math.min(tileGridSize - 1, maxTileY));

                    const isPoly = isClosedRing(pts);

                    for (let ty = minTileY; ty <= maxTileY; ty++) {
                        const tileMinLat = sw.lat + ty * tileHeight;
                        const tileMaxLat = tileMinLat + tileHeight;
                        const haloMinLat = tileMinLat - haloLat;
                        const haloMaxLat = tileMaxLat + haloLat;

                        for (let tx = minTileX; tx <= maxTileX; tx++) {
                            const tileMinLon = sw.lng + tx * tileWidth;
                            const tileMaxLon = tileMinLon + tileWidth;
                            const haloMinLon = tileMinLon - haloLon;
                            const haloMaxLon = tileMaxLon + haloLon;

                            if (fMaxLon < haloMinLon || fMinLon > haloMaxLon || fMaxLat < haloMinLat || fMinLat > haloMaxLat) continue;

                            const tileIdx = ty * tileGridSize + tx;

                            if (isPoly) {
                                const clipped = clipPolygonToRect(pts, haloMinLon, haloMinLat, haloMaxLon, haloMaxLat);
                                if (!clipped || clipped.length < 4) continue;
                                let q = quantizePoints(clipped, haloMinLon, haloMinLat, haloMaxLon, haloMaxLat);
                                if (!q || q.length < 3) continue;
                                const first = q[0];
                                const last = q[q.length - 1];
                                if (first.lat !== last.lat || first.lon !== last.lon) q.push({ ...first });
                                if (q.length < 4) continue;
                                tiles[tileIdx].push({ type: f.type, subtype: f.subtype ?? 0, nameIndex: f.nameIndex, points: q, sourceType: f.sourceType });
                            } else {
                                const segments = clipPolylineToRectSegments(pts, haloMinLon, haloMinLat, haloMaxLon, haloMaxLat);
                                for (const seg of segments) {
                                    if (!seg || seg.length < 2) continue;
                                    const q = quantizePoints(seg, haloMinLon, haloMinLat, haloMaxLon, haloMaxLat);
                                    if (!q || q.length < 2) continue;
                                    tiles[tileIdx].push({ type: f.type, subtype: f.subtype ?? 0, nameIndex: f.nameIndex, points: q, sourceType: f.sourceType });
                                }
                            }
                        }
                    }
                }

                const tilePayloadSizes = new Array(tileCount).fill(0);
                const typeBreakdownV5 = {};
                let featureCountV5 = 0;
                let namedCountV5 = 0;
                let totalPointsV5 = 0;
                let maxPointsV5 = 0;

                for (let i = 0; i < tileCount; i++) {
                    const feats = tiles[i];
                    if (!feats || feats.length === 0) continue;
                    let size = 2;
                    for (const tf of feats) {
                        featureCountV5++;
                        if (tf.nameIndex !== HWMAP_NO_NAME) namedCountV5++;
                        totalPointsV5 += tf.points.length;
                        if (tf.points.length > maxPointsV5) maxPointsV5 = tf.points.length;

                        const featureBytes = (outputVersion === 6 ? 6 : 5) + tf.points.length * 4;
                        size += featureBytes;

                        // Use granular sourceType for breakdown display (matches estimate breakdown)
                        const typeName = tf.sourceType || 'Other';
                        if (!typeBreakdownV5[typeName]) typeBreakdownV5[typeName] = { bytes: 0, count: 0 };
                        typeBreakdownV5[typeName].bytes += featureBytes;
                        typeBreakdownV5[typeName].count++;
                    }
                    tilePayloadSizes[i] = size;
                }

                const headerSize = 40;
                const tileDirectorySize = tileCount * 8;
                const tilePayloadBase = headerSize + finalNameTableSize + tileDirectorySize;
                const tileOffsets = new Array(tileCount).fill(0);
                let cursor = tilePayloadBase;
                for (let i = 0; i < tileCount; i++) {
                    if (tilePayloadSizes[i] > 0) {
                        tileOffsets[i] = cursor;
                        cursor += tilePayloadSizes[i];
                    }
                }
                const bufferSizeV5 = cursor;

                const buffer = new ArrayBuffer(bufferSizeV5);
                const view = new DataView(buffer);
                let offset = 0;

                view.setUint8(offset++, 0x48);
                view.setUint8(offset++, 0x57);
                view.setUint8(offset++, 0x4D);
                view.setUint8(offset++, 0x50);

                view.setUint16(offset, outputVersion, true);
                offset += 2;

                view.setUint16(offset, v5Flags, true);
                offset += 2;

                view.setInt32(offset, Math.round(sw.lat * 10000000), true);
                offset += 4;
                view.setInt32(offset, Math.round(sw.lng * 10000000), true);
                offset += 4;
                view.setInt32(offset, Math.round(ne.lat * 10000000), true);
                offset += 4;
                view.setInt32(offset, Math.round(ne.lng * 10000000), true);
                offset += 4;

                view.setUint32(offset, featureCountV5, true);
                offset += 4;

                view.setUint16(offset, finalNameList.length, true);
                offset += 2;

                for (let i = 0; i < 8; i++) {
                    view.setUint8(offset++, i < regionName.length ? regionName.charCodeAt(i) : 0);
                }

                view.setUint16(offset, 0, true);
                offset += 2;

                for (const name of finalNameList) {
                    view.setUint8(offset++, name.length);
                    for (let i = 0; i < name.length; i++) {
                        view.setUint8(offset++, name.charCodeAt(i) & 0xFF);
                    }
                }

                for (let i = 0; i < tileCount; i++) {
                    view.setUint32(offset, tileOffsets[i], true);
                    offset += 4;
                    view.setUint32(offset, tilePayloadSizes[i], true);
                    offset += 4;
                }

                for (let i = 0; i < tileCount; i++) {
                    const feats = tiles[i];
                    const payloadSize = tilePayloadSizes[i];
                    if (!payloadSize || !feats || feats.length === 0) continue;

                    let pOff = tileOffsets[i];
                    view.setUint16(pOff, feats.length, true);
                    pOff += 2;

                    for (const tf of feats) {
                        view.setUint8(pOff++, tf.type);
                        if (outputVersion === 6) {
                            view.setUint8(pOff++, tf.subtype ?? 0);
                        }
                        view.setUint16(pOff, tf.nameIndex, true);
                        pOff += 2;
                        view.setUint16(pOff, tf.points.length, true);
                        pOff += 2;
                        for (const qp of tf.points) {
                            view.setUint16(pOff, qp.lat, true);
                            pOff += 2;
                            view.setUint16(pOff, qp.lon, true);
                            pOff += 2;
                        }
                    }
                }

                return {
                    blob: new Blob([buffer], { type: 'application/octet-stream' }),
                    stats: {
                        formatVersion: outputVersion,
                        fileSize: bufferSizeV5,
                        featureCount: featureCountV5,
                        namedCount: namedCountV5,
                        nameCount: finalNameList.length,
                        totalPoints: totalPointsV5,
                        maxPoints: maxPointsV5,
                        typeBreakdown: typeBreakdownV5,
                        nameTableSize: finalNameTableSize,
                        spatialIndexSize: 0,
                        gridSize: 0,
                        tileGridSize,
                        tileDirectorySize
                    }
                };
            }
        }
        
        function classifyFeature(tags) {
            if (!tags) return null;
            
            // Roads - check highway tag
            if (tags.highway) {
                // Highways (motorways, trunk roads)
                if (['motorway', 'motorway_link', 'trunk', 'trunk_link'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_HIGHWAY;
                }
                // Major roads (primary, secondary)
                if (['primary', 'secondary', 'primary_link', 'secondary_link'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_MAJOR;
                }
                // Minor roads (tertiary, residential, service, unclassified)
                if (['tertiary', 'tertiary_link', 'residential', 'unclassified', 'service', 'living_street'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_MINOR;
                }
                // Paths (footways, cycleways, tracks, etc.)
                if (['footway', 'path', 'cycleway', 'track', 'pedestrian', 'steps', 'bridleway'].includes(tags.highway)) {
                    return FEATURE_TYPES.ROAD_PATH;
                }
            }
            
            // Railways
            if (tags.railway) {
                if (['rail', 'light_rail', 'subway', 'tram', 'narrow_gauge'].includes(tags.railway)) {
                    return FEATURE_TYPES.RAILWAY;
                }
                // Transit stations (nodes with railway=station or halt)
                if (['station', 'halt'].includes(tags.railway)) {
                    return FEATURE_TYPES.STATION;
                }
            }
            
            // Bus routes (from relations expanded to ways)
            if (tags.route === 'bus' || tags.route === 'trolleybus') {
                return FEATURE_TYPES.BUS;
            }
            
            // Ferry routes
            if (tags.route === 'ferry') {
                return FEATURE_TYPES.FERRY;
            }
            
            // Transit stations (amenity-based)
            if (tags.amenity === 'bus_station' || tags.amenity === 'ferry_terminal') {
                return FEATURE_TYPES.STATION;
            }
            
            // Water - area polygons and linear waterways
            if (tags.natural === 'water' || tags.natural === 'bay' || tags.natural === 'strait' ||
                tags.water || tags.harbour || tags.place === 'sea' ||
                tags.waterway === 'riverbank' || tags.waterway === 'dock' ||
                tags.landuse === 'basin' || tags.landuse === 'reservoir' ||
                tags.waterway) {
                return FEATURE_TYPES.WATER;
            }
            
            // Parks and green areas - expanded coverage
            if (tags.leisure === 'park' || tags.leisure === 'garden' || tags.leisure === 'recreation_ground' ||
                tags.leisure === 'playground' || tags.leisure === 'golf_course' || tags.leisure === 'nature_reserve' ||
                ['grass', 'forest', 'meadow', 'wood', 'village_green', 'allotments', 'grassland', 'farmland'].includes(tags.landuse) || 
                ['wood', 'grassland', 'heath', 'scrub'].includes(tags.natural)) {
                return FEATURE_TYPES.PARK;
            }
            
            // Land mask (from coastline processing)
            if (tags.landuse === 'land_mask' || tags.land === 'coastline_generated') {
                return FEATURE_TYPES.LAND;
            }
            
            // Buildings - ONLY actual building tags, NOT landuse areas
            if (tags.building) {
                return FEATURE_TYPES.BUILDING;
            }

            if (tags.landuse === 'industrial' || tags.landuse === 'commercial' || tags.landuse === 'retail' || tags.landuse === 'residential') {
                return FEATURE_TYPES.BUILDING;
            }
            
            return null;
        }
        
        function simplifyPoints(geometry, tolerance) {
            // Douglas-Peucker simplification
            if (geometry.length <= 2) return geometry;
            
            const points = geometry.map(p => ({ lat: p.lat, lon: p.lon }));
            return douglasPeucker(points, tolerance);
        }
        
        // Resample points to a maximum count while preserving start/end
        // For CLOSED polygons (first == last), ensures the output remains closed
        function resamplePoints(points, maxCount) {
            if (points.length <= maxCount) return points;
            
            // Check if polygon is closed (first and last point are the same or very close)
            const firstPt = points[0];
            const lastPt = points[points.length - 1];
            const latDiff = Math.abs(firstPt.lat - lastPt.lat);
            const lonDiff = Math.abs(firstPt.lon - lastPt.lon);
            const isClosed = points.length >= 3 && latDiff < 0.00001 && lonDiff < 0.00001;
            
            // Note: caller should log feature type before calling resamplePoints
            
            if (isClosed) {
                // For closed polygons, resample interior points and ensure closure
                // Exclude the duplicate last point when calculating step
                const interiorCount = points.length - 1; // Don't count duplicate last point
                const result = [{ lat: firstPt.lat, lon: firstPt.lon }];
                const step = interiorCount / (maxCount - 1);
                
                for (let i = 1; i < maxCount - 1; i++) {
                    const idx = Math.min(Math.round(i * step), interiorCount - 1);
                    result.push(points[idx]);
                }
                
                // Close the polygon by duplicating the first point exactly
                result.push({ lat: firstPt.lat, lon: firstPt.lon });
                
                // Closure preserved
                return result;
            }
            
            // For open polylines, keep first and last point
            const result = [points[0]];
            const step = (points.length - 1) / (maxCount - 1);
            
            for (let i = 1; i < maxCount - 1; i++) {
                const idx = Math.round(i * step);
                result.push(points[idx]);
            }
            
            result.push(points[points.length - 1]);
            
                // Open polyline preserved
            return result;
        }
        
        function douglasPeucker(points, tolerance) {
            if (points.length <= 2) return points;
            
            let maxDist = 0;
            let maxIndex = 0;
            
            const start = points[0];
            const end = points[points.length - 1];
            
            for (let i = 1; i < points.length - 1; i++) {
                const dist = perpendicularDistance(points[i], start, end);
                if (dist > maxDist) {
                    maxDist = dist;
                    maxIndex = i;
                }
            }
            
            if (maxDist > tolerance) {
                const left = douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
                const right = douglasPeucker(points.slice(maxIndex), tolerance);
                return left.slice(0, -1).concat(right);
            }
            
            return [start, end];
        }
        
        function perpendicularDistance(point, lineStart, lineEnd) {
            const dx = lineEnd.lon - lineStart.lon;
            const dy = lineEnd.lat - lineStart.lat;
            
            const norm = Math.sqrt(dx * dx + dy * dy);
            if (norm === 0) return Math.sqrt(
                Math.pow(point.lon - lineStart.lon, 2) + 
                Math.pow(point.lat - lineStart.lat, 2)
            );
            
            return Math.abs(dy * point.lon - dx * point.lat + 
                          lineEnd.lon * lineStart.lat - lineEnd.lat * lineStart.lon) / norm;
        }
        
        // =============================================================================
        // TYPE-SPECIFIC SIMPLIFICATION FUNCTIONS
        // =============================================================================
        
        // Calculate angle at vertex (in radians) - used for corner detection
        function vertexAngle(prev, curr, next) {
            const v1x = prev.lon - curr.lon;
            const v1y = prev.lat - curr.lat;
            const v2x = next.lon - curr.lon;
            const v2y = next.lat - curr.lat;
            
            const dot = v1x * v2x + v1y * v2y;
            const cross = v1x * v2y - v1y * v2x;
            
            return Math.abs(Math.atan2(cross, dot));
        }
        
        // Simplify roads/paths - standard Douglas-Peucker with even resampling fallback
        function simplifyRoad(points, targetCount, tolerance) {
            if (points.length <= targetCount) return points;
            
            // Douglas-Peucker first
            let simplified = douglasPeucker(points.map(p => ({ lat: p.lat, lon: p.lon })), tolerance);
            
            if (simplified.length <= targetCount) return simplified;
            
            // Fall back to even resampling for roads (less critical to preserve exact shape)
            return resamplePoints(simplified, targetCount);
        }
        
        // Parse .hwmap binary blob back into renderable data structure
        // This mirrors how the device reads the file
        async function parseHWMapBlob(blob) {
            const buffer = await blob.arrayBuffer();
            const view = new DataView(buffer);
            let offset = 0;
            
            // Read header (40 bytes)
            const magic = String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3));
            if (magic !== 'HWMP') throw new Error('Invalid HWMAP magic');
            offset = 4;
            
            const version = view.getUint16(offset, true); offset += 2;
            const flags = view.getUint16(offset, true); offset += 2;
            
            const minLat = view.getInt32(offset, true); offset += 4;
            const minLon = view.getInt32(offset, true); offset += 4;
            const maxLat = view.getInt32(offset, true); offset += 4;
            const maxLon = view.getInt32(offset, true); offset += 4;
            
            const featureCount = view.getUint32(offset, true); offset += 4;
            const nameCount = view.getUint16(offset, true); offset += 2;
            
            // Region name (8 bytes)
            let regionName = '';
            for (let i = 0; i < 8; i++) {
                const c = view.getUint8(offset + i);
                if (c === 0) break;
                regionName += String.fromCharCode(c);
            }
            offset += 8;
            offset += 2; // padding
            
            // Read name table
            const names = [];
            for (let i = 0; i < nameCount; i++) {
                const len = view.getUint8(offset++);
                let name = '';
                for (let j = 0; j < len; j++) {
                    name += String.fromCharCode(view.getUint8(offset++));
                }
                names.push(name);
            }

            if (version === 5 || version === 6) {
                // Decode v5 format settings from flags bitfield
                const tileGridCode = flags & 0x3;
                const tileGridSize = tileGridCode === 0 ? 16 : tileGridCode === 2 ? 64 : 32;
                const haloPct = (flags >>> 2) & 0x1F;
                const haloFraction = haloPct / 100;
                const quantBits = Math.min(16, 10 + ((flags >>> 7) & 0x0F));
                const qMax = (1 << quantBits) - 1;
                const tileCount = tileGridSize * tileGridSize;

                const mapMinLat = minLat / 10000000;
                const mapMinLon = minLon / 10000000;
                const mapMaxLat = maxLat / 10000000;
                const mapMaxLon = maxLon / 10000000;

                const tileWidth = (mapMaxLon - mapMinLon) / tileGridSize;
                const tileHeight = (mapMaxLat - mapMinLat) / tileGridSize;
                const haloLon = tileWidth * haloFraction;
                const haloLat = tileHeight * haloFraction;

                const tileOffsets = new Array(tileCount).fill(0);
                const tileLengths = new Array(tileCount).fill(0);
                for (let i = 0; i < tileCount; i++) {
                    tileOffsets[i] = view.getUint32(offset, true);
                    offset += 4;
                    tileLengths[i] = view.getUint32(offset, true);
                    offset += 4;
                }

                const features = [];

                for (let tileIdx = 0; tileIdx < tileCount; tileIdx++) {
                    const len = tileLengths[tileIdx];
                    const off = tileOffsets[tileIdx];
                    if (!len || !off) continue;

                    const tx = tileIdx % tileGridSize;
                    const ty = Math.floor(tileIdx / tileGridSize);
                    const tileMinLon = mapMinLon + tx * tileWidth;
                    const tileMaxLon = tileMinLon + tileWidth;
                    const tileMinLat = mapMinLat + ty * tileHeight;
                    const tileMaxLat = tileMinLat + tileHeight;
                    const haloMinLon = tileMinLon - haloLon;
                    const haloMaxLon = tileMaxLon + haloLon;
                    const haloMinLat = tileMinLat - haloLat;
                    const haloMaxLat = tileMaxLat + haloLat;
                    const lonRange = haloMaxLon - haloMinLon;
                    const latRange = haloMaxLat - haloMinLat;

                    let pOff = off;
                    const tileFeatureCount = view.getUint16(pOff, true);
                    pOff += 2;

                    for (let i = 0; i < tileFeatureCount; i++) {
                        const type = view.getUint8(pOff++);
                        const subtype = version === 6 ? view.getUint8(pOff++) : 0;
                        const nameIndex = view.getUint16(pOff, true); pOff += 2;
                        const pointCount = view.getUint16(pOff, true); pOff += 2;

                        const qPoints = new Array(pointCount);
                        for (let j = 0; j < pointCount; j++) {
                            const qLat = view.getUint16(pOff, true); pOff += 2;
                            const qLon = view.getUint16(pOff, true); pOff += 2;
                            qPoints[j] = { qLat, qLon };
                        }

                        const points = qPoints.map(qp => ({
                            lat: haloMinLat + (qp.qLat / qMax) * latRange,
                            lon: haloMinLon + (qp.qLon / qMax) * lonRange
                        }));

                        features.push({
                            type,
                            subtype,
                            name: nameIndex !== 0xFFFF ? names[nameIndex] : null,
                            points
                        });
                    }
                }

                const buildSpatialIndex = () => {
                    const gridSize = HWMAP_GRID_SIZE;
                    const cellWidth = (mapMaxLon - mapMinLon) / gridSize;
                    const cellHeight = (mapMaxLat - mapMinLat) / gridSize;
                    const cells = Array(gridSize * gridSize).fill(null).map(() => []);

                    for (let fi = 0; fi < features.length; fi++) {
                        const f = features[fi];
                        if (!f || !f.points || f.points.length < 2) continue;
                        let fMinLat = Infinity, fMaxLat = -Infinity;
                        let fMinLon = Infinity, fMaxLon = -Infinity;
                        for (const p of f.points) {
                            if (p.lat < fMinLat) fMinLat = p.lat;
                            if (p.lat > fMaxLat) fMaxLat = p.lat;
                            if (p.lon < fMinLon) fMinLon = p.lon;
                            if (p.lon > fMaxLon) fMaxLon = p.lon;
                        }

                        let minCellX = Math.floor((fMinLon - mapMinLon) / cellWidth);
                        let maxCellX = Math.floor((fMaxLon - mapMinLon) / cellWidth);
                        let minCellY = Math.floor((fMinLat - mapMinLat) / cellHeight);
                        let maxCellY = Math.floor((fMaxLat - mapMinLat) / cellHeight);

                        minCellX = Math.max(0, Math.min(gridSize - 1, minCellX));
                        maxCellX = Math.max(0, Math.min(gridSize - 1, maxCellX));
                        minCellY = Math.max(0, Math.min(gridSize - 1, minCellY));
                        maxCellY = Math.max(0, Math.min(gridSize - 1, maxCellY));

                        for (let cy = minCellY; cy <= maxCellY; cy++) {
                            for (let cx = minCellX; cx <= maxCellX; cx++) {
                                cells[cy * gridSize + cx].push(fi);
                            }
                        }
                    }

                    return { gridSize, cells };
                };

                return {
                    version,
                    regionName,
                    minLat: mapMinLat,
                    minLon: mapMinLon,
                    maxLat: mapMaxLat,
                    maxLon: mapMaxLon,
                    features,
                    names,
                    spatialIndex: buildSpatialIndex()
                };
            }

            throw new Error(`Unsupported HWMAP version: ${version}`);
        }
        
        // ========== MODULAR RENDERING FUNCTIONS ==========
        
        // Fill background with LAND color - water polygons will carve out rivers
        function fillBackground(ctx, canvas, toCanvas, m, hasLandMask) {
            ctx.fillStyle = '#c9b896';  // tan land color - water carves out rivers
            ctx.beginPath();
            const corners = [
                toCanvas(m.minLat, m.minLon),
                toCanvas(m.minLat, m.maxLon),
                toCanvas(m.maxLat, m.maxLon),
                toCanvas(m.maxLat, m.minLon)
            ];
            ctx.moveTo(corners[0].x, corners[0].y);
            for (let i = 1; i < corners.length; i++) ctx.lineTo(corners[i].x, corners[i].y);
            ctx.closePath();
            ctx.fill();
        }
        
        // Draw building clusters when zoomed out
        function drawBuildingClusters(ctx, toCanvas, m, zoom, mapWidth, mapHeight, layers) {
            if (zoom >= 1.2 || !m.spatialIndex) return;
            // Only draw clusters if actual buildings layer is enabled (not just industrial/commercial/residential)
            if (layers && !layers.buildings) return;
            
            ctx.fillStyle = 'rgba(128, 128, 128, 0.4)';
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            
            const si = m.spatialIndex;
            for (let cellIdx = 0; cellIdx < si.cells.length; cellIdx++) {
                let cMinLat = Infinity, cMaxLat = -Infinity;
                let cMinLon = Infinity, cMaxLon = -Infinity;
                let buildingCount = 0;
                
                for (const fi of si.cells[cellIdx]) {
                    const f = m.features[fi];
                    if (f && f.type === 0x30 && (m.version < 6 || (f.subtype ?? 0) === FEATURE_SUBTYPES.BUILDING.BUILDING) && f.points.length >= 2) {
                        for (const pt of f.points) {
                            if (pt.lat < cMinLat) cMinLat = pt.lat;
                            if (pt.lat > cMaxLat) cMaxLat = pt.lat;
                            if (pt.lon < cMinLon) cMinLon = pt.lon;
                            if (pt.lon > cMaxLon) cMaxLon = pt.lon;
                        }
                        buildingCount++;
                    }
                }
                
                if (buildingCount === 0) continue;
                
                const c1 = toCanvas(cMaxLat, cMinLon);
                const c2 = toCanvas(cMinLat, cMaxLon);
                const x = Math.min(c1.x, c2.x);
                const y = Math.min(c1.y, c2.y);
                const w = Math.abs(c2.x - c1.x);
                const h = Math.abs(c2.y - c1.y);
                
                if (w > 4 && h > 4) {
                    const r = Math.min(4, w / 4, h / 4);
                    ctx.beginPath();
                    ctx.roundRect(x, y, w, h, r);
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }
        
        // Draw highway casings (dark outline under highways)
        function drawHighwayCasings(ctx, toCanvas, m, zoom, COLORS, layers) {
            // Skip if highways are disabled
            if (m.version >= 6) {
                if (!layers || (!layers.motorways && !layers.trunk)) return;
            } else {
                if (layers && !layers.highways) return;
            }
            
            ctx.beginPath();
            ctx.strokeStyle = '#8b0000';
            // Scale line width: reduce when zoomed out, and progressively thinner when zoomed in
            let lineScale = 1;
            if (zoom > 1) {
                // Reduce line width progressively as zoom increases (thinner at high zoom for better definition)
                lineScale = Math.max(0.3, 1 / Math.sqrt(zoom));
            } else if (zoom < 1) {
                lineScale = Math.max(0.4, zoom);
            }
            ctx.lineWidth = (COLORS[0x00].width + 4) * lineScale;
            ctx.setLineDash([]);
            for (const feature of m.features) {
                if (feature.type !== 0x00 || feature.points.length < 2) continue;
                if (m.version >= 6) {
                    const st = feature.subtype ?? 0;
                    if (st === FEATURE_SUBTYPES.ROAD_HIGHWAY.MOTORWAY && !layers.motorways) continue;
                    if (st === FEATURE_SUBTYPES.ROAD_HIGHWAY.TRUNK && !layers.trunk) continue;
                }
                const first = toCanvas(feature.points[0].lat, feature.points[0].lon);
                ctx.moveTo(first.x, first.y);
                for (let i = 1; i < feature.points.length; i++) {
                    const p = toCanvas(feature.points[i].lat, feature.points[i].lon);
                    ctx.lineTo(p.x, p.y);
                }
            }
            ctx.stroke();
        }
        
        // Draw ALL water polygons to carve out rivers from land background
        // Skip polygons with diagonal segments (corner-to-corner closure artifacts)
        function drawAllWater(ctx, toCanvas, m, mapWidth, mapHeight, hasLandMask, COLORS, layers) {
            let fillCount = 0;
            let skippedDiagonal = 0;
            let skippedFullCoverage = 0;
            const waterFeatures = m.features.filter(f => f.type === 0x10);
            
            // Thresholds for detecting diagonal segments
            // Use smaller of 30% of map OR absolute max (0.02 degrees ≈ 2km)
            // This ensures diagonal artifacts are caught at any scale
            const latThreshold = Math.min(mapHeight * 0.3, 0.02);
            const lonThreshold = Math.min(mapWidth * 0.3, 0.02);
            
            console.log(`[WATER] Map size: ${mapHeight.toFixed(4)} x ${mapWidth.toFixed(4)} deg, thresholds: ${latThreshold.toFixed(4)} x ${lonThreshold.toFixed(4)}`);
            
            for (const feature of waterFeatures) {
                const pts = feature.points;
                if (pts.length < 3) continue;  // Need at least 3 points for a polygon
                
                // Check subtype and layer visibility for v6
                if (m.version >= 6) {
                    const st = feature.subtype ?? 0;
                    if (st === FEATURE_SUBTYPES.WATER.LAKE && layers && !layers.lakes) continue;
                    if (st === FEATURE_SUBTYPES.WATER.RIVER && layers && !layers.rivers) continue;
                    if (st === FEATURE_SUBTYPES.WATER.COASTLINE && layers && !layers.coastlines) continue;
                }
                
                const EDGE_EPS = 0.001;
                const isNearBoundary = (pt) => (
                    Math.abs(pt.lat - m.minLat) < EDGE_EPS ||
                    Math.abs(pt.lat - m.maxLat) < EDGE_EPS ||
                    Math.abs(pt.lon - m.minLon) < EDGE_EPS ||
                    Math.abs(pt.lon - m.maxLon) < EDGE_EPS
                );
                
                // Detect diagonal segments - segments that span large distances in BOTH lat AND lon
                // Only treat as artifact if both endpoints are near the selection boundary
                let hasDiagonal = false;
                for (let i = 1; i < pts.length; i++) {
                    const latDiff = Math.abs(pts[i].lat - pts[i-1].lat);
                    const lonDiff = Math.abs(pts[i].lon - pts[i-1].lon);
                    if (latDiff > latThreshold && lonDiff > lonThreshold && isNearBoundary(pts[i]) && isNearBoundary(pts[i-1])) {
                        hasDiagonal = true;
                        break;
                    }
                }
                
                if (hasDiagonal) {
                    skippedDiagonal++;
                    continue;
                }

                if (m.version >= 5) {
                    let minLat = Infinity, maxLat = -Infinity;
                    let minLon = Infinity, maxLon = -Infinity;
                    for (const pt of pts) {
                        if (pt.lat < minLat) minLat = pt.lat;
                        if (pt.lat > maxLat) maxLat = pt.lat;
                        if (pt.lon < minLon) minLon = pt.lon;
                        if (pt.lon > maxLon) maxLon = pt.lon;
                    }

                    const polyLatCoverage = (maxLat - minLat) / mapHeight;
                    const polyLonCoverage = (maxLon - minLon) / mapWidth;
                    const coversEssentiallyAll = polyLatCoverage > 0.995 && polyLonCoverage > 0.995;

                    const FULL_EPS = Math.min(mapHeight, mapWidth) * 0.005;
                    const touchesNorth = pts.some(p => Math.abs(p.lat - m.maxLat) < FULL_EPS);
                    const touchesSouth = pts.some(p => Math.abs(p.lat - m.minLat) < FULL_EPS);
                    const touchesWest = pts.some(p => Math.abs(p.lon - m.minLon) < FULL_EPS);
                    const touchesEast = pts.some(p => Math.abs(p.lon - m.maxLon) < FULL_EPS);
                    const touchesAllEdges = touchesNorth && touchesSouth && touchesWest && touchesEast;

                    if (touchesAllEdges && coversEssentiallyAll) {
                        skippedFullCoverage++;
                        continue;
                    }
                }
                
                // Draw water polygon
                ctx.beginPath();
                ctx.fillStyle = COLORS[0x10].fill;
                const first = toCanvas(pts[0].lat, pts[0].lon);
                ctx.moveTo(first.x, first.y);
                for (let i = 1; i < pts.length; i++) {
                    const p = toCanvas(pts[i].lat, pts[i].lon);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
                ctx.fill();
                const prevStrokeStyle = ctx.strokeStyle;
                const prevLineWidth = ctx.lineWidth;
                ctx.strokeStyle = COLORS[0x10].fill;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.strokeStyle = prevStrokeStyle;
                ctx.lineWidth = prevLineWidth;
                // NOTE: No stroke for filled water polygons - stroking causes visible
                // tile boundary artifacts when polygons are clipped across tiles
                fillCount++;
            }
            
            if (skippedDiagonal > 0 || skippedFullCoverage > 0) {
                console.log(`[WATER] Skipped: ${skippedDiagonal} diagonal, ${skippedFullCoverage} full-coverage`);
            }
            
            return fillCount;
        }
        
        // Draw land masks ON TOP of water to restore land areas
        // Skip polygons with diagonal segments (corner-to-corner closure artifacts)
        function drawLandMasks(ctx, toCanvas, m, mapWidth, mapHeight, hasLandMask, COLORS) {
            if (!hasLandMask) return 0;
            
            let fillCount = 0;
            let skippedDiagonal = 0;
            const landMaskFeatures = m.features.filter(f => f.type === 0x12);
            const validLandMasks = [];
            
            // Thresholds for detecting diagonal segments
            // Use smaller of 30% of map OR absolute max (0.02 degrees ≈ 2km)
            const latThreshold = Math.min(mapHeight * 0.3, 0.02);
            const lonThreshold = Math.min(mapWidth * 0.3, 0.02);
            
            console.log(`[LAND] Map size: ${mapHeight.toFixed(4)} x ${mapWidth.toFixed(4)} deg, thresholds: ${latThreshold.toFixed(4)} x ${lonThreshold.toFixed(4)}`);
            
            let skippedFullCoverage = 0;
            
            for (const feature of landMaskFeatures) {
                const pts = feature.points;
                if (pts.length < 3) continue;
                
                // Check if closed
                const isClosed = Math.abs(pts[0].lat - pts[pts.length-1].lat) < 0.01 &&
                                 Math.abs(pts[0].lon - pts[pts.length-1].lon) < 0.01;
                if (!isClosed) continue;
                
                // Calculate polygon bounds to detect full-coverage artifacts
                let minLat = Infinity, maxLat = -Infinity;
                let minLon = Infinity, maxLon = -Infinity;
                for (const pt of pts) {
                    if (pt.lat < minLat) minLat = pt.lat;
                    if (pt.lat > maxLat) maxLat = pt.lat;
                    if (pt.lon < minLon) minLon = pt.lon;
                    if (pt.lon > maxLon) maxLon = pt.lon;
                }
                
                const polyLatCoverage = (maxLat - minLat) / mapHeight;
                const polyLonCoverage = (maxLon - minLon) / mapWidth;
                const coversNearlyAll = polyLatCoverage > 0.98 && polyLonCoverage > 0.98;
                
                // Calculate actual polygon area (inline to avoid scope issues)
                let polyArea = 0;
                for (let i = 0; i < pts.length; i++) {
                    const j = (i + 1) % pts.length;
                    polyArea += pts[i].lon * pts[j].lat;
                    polyArea -= pts[j].lon * pts[i].lat;
                }
                polyArea = Math.abs(polyArea / 2);
                const selectionArea = mapHeight * mapWidth;
                const areaRatio = polyArea / selectionArea;
                
                // Skip land polygons that cover >98% bbox in BOTH dimensions AND >40% actual area
                // These are artifacts from coastline clipping that would cover water areas
                const FULL_EPS = Math.min(mapHeight, mapWidth) * 0.005;
                const touchesNorth = pts.some(p => Math.abs(p.lat - m.maxLat) < FULL_EPS);
                const touchesSouth = pts.some(p => Math.abs(p.lat - m.minLat) < FULL_EPS);
                const touchesWest = pts.some(p => Math.abs(p.lon - m.minLon) < FULL_EPS);
                const touchesEast = pts.some(p => Math.abs(p.lon - m.maxLon) < FULL_EPS);
                const touchesAllEdges = touchesNorth && touchesSouth && touchesWest && touchesEast;

                if (touchesAllEdges && coversNearlyAll && areaRatio > 0.40) {
                    skippedFullCoverage++;
                    console.log(`[LAND] Skipping large land polygon: ${pts.length} pts, ${(polyLatCoverage*100).toFixed(1)}% lat x ${(polyLonCoverage*100).toFixed(1)}% lon, area=${(areaRatio*100).toFixed(1)}%`);
                    continue;
                }
                
                const EDGE_EPS = 0.001;
                const isNearBoundary = (pt) => (
                    Math.abs(pt.lat - m.minLat) < EDGE_EPS ||
                    Math.abs(pt.lat - m.maxLat) < EDGE_EPS ||
                    Math.abs(pt.lon - m.minLon) < EDGE_EPS ||
                    Math.abs(pt.lon - m.maxLon) < EDGE_EPS
                );
                
                // Detect diagonal segments - segments that span large distances in BOTH lat AND lon
                let hasDiagonal = false;
                for (let i = 1; i < pts.length; i++) {
                    const latDiff = Math.abs(pts[i].lat - pts[i-1].lat);
                    const lonDiff = Math.abs(pts[i].lon - pts[i-1].lon);
                    if (latDiff > latThreshold && lonDiff > lonThreshold && isNearBoundary(pts[i]) && isNearBoundary(pts[i-1])) {
                        hasDiagonal = true;
                        break;
                    }
                }
                
                if (hasDiagonal) {
                    skippedDiagonal++;
                    continue;
                }
                
                // Collect valid land mask for combined drawing
                validLandMasks.push(pts);
                fillCount++;
            }
            
            if (skippedDiagonal > 0 || skippedFullCoverage > 0) {
                console.log(`[LAND] Skipped: ${skippedDiagonal} diagonal, ${skippedFullCoverage} full-coverage`);
            }
            
            // Draw ALL land masks as a single combined path to eliminate internal edge artifacts
            // When polygons are drawn individually, antialiasing creates visible seams between them
            if (validLandMasks.length > 0) {
                ctx.beginPath();
                ctx.fillStyle = COLORS[0x12].fill;
                
                for (const pts of validLandMasks) {
                    const first = toCanvas(pts[0].lat, pts[0].lon);
                    ctx.moveTo(first.x, first.y);
                    for (let i = 1; i < pts.length; i++) {
                        const p = toCanvas(pts[i].lat, pts[i].lon);
                        ctx.lineTo(p.x, p.y);
                    }
                    ctx.closePath();
                }
                
                ctx.fill();
            }
            
            return fillCount;
        }
        
        // Draw parks on top of water background (green areas)
        function drawParks(ctx, toCanvas, m, hasLandMask, COLORS, layers) {
            
            let fillCount = 0;
            const parkFeatures = m.features.filter(f => f.type === 0x11);
            
            for (const feature of parkFeatures) {
                const pts = feature.points;
                if (pts.length < 3) continue;

                if (m.version >= 6) {
                    const st = feature.subtype ?? 0;
                    if (st === FEATURE_SUBTYPES.PARK.PARK && layers && !layers.parks) continue;
                    if (st === FEATURE_SUBTYPES.PARK.FOREST && layers && !layers.forests) continue;
                    if (st === FEATURE_SUBTYPES.PARK.GRASSLAND && layers && !layers.grassland) continue;
                }
                
                // Check if closed
                const isClosed = Math.abs(pts[0].lat - pts[pts.length-1].lat) < 0.01 &&
                                 Math.abs(pts[0].lon - pts[pts.length-1].lon) < 0.01;
                if (!isClosed) continue;
                
                // Draw park
                ctx.beginPath();
                ctx.fillStyle = COLORS[0x11].fill;
                const first = toCanvas(pts[0].lat, pts[0].lon);
                ctx.moveTo(first.x, first.y);
                for (let i = 1; i < pts.length; i++) {
                    const p = toCanvas(pts[i].lat, pts[i].lon);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
                ctx.fill();
                fillCount++;
            }
            
            return fillCount;
        }
        
        // Draw coastline water boundaries (strokes only, for visual definition)
        // NOTE: Disabled because coastline polygons are clipped to tiles, and stroking
        // includes tile boundary edges, creating a visible grid pattern. The water fill
        // already defines the coastline boundary against land.
        function drawCoastlineStrokes(ctx, toCanvas, m, hasLandMask, COLORS, layers) {
            // Disabled - stroking clipped coastline polygons creates tile boundary artifacts
            return;
        }
        
        // Draw other map features (roads, buildings - parks handled separately)
        function drawMapFeatures(ctx, toCanvas, m, zoom, hasLandMask, COLORS, layers, centerLat, centerLon, mapWidth, mapHeight) {
            // Render order: buildings, paths, minor, major, ferry, bus, railway, highways, stations
            const renderOrder = [0x30, 0x03, 0x02, 0x01, 0x22, 0x21, 0x20, 0x00, 0x40];
            let featureCount = 0;
            const isV6 = m.version >= 6;
            
            // Map feature types to layer toggles
            const typeToLayer = {
                0x00: 'highways',    // Highway
                0x01: 'major',       // Major road
                0x02: 'minor',       // Minor road
                0x03: 'paths',       // Path
                0x20: 'railway',     // Railway
                0x21: 'bus',         // Bus route
                0x22: 'ferry',       // Ferry
                0x30: 'buildings',   // Building
                0x40: 'stations'     // Transit station
            };
            
            for (const targetType of renderOrder) {
                // Check layer toggle for this type
                if (isV6) {
                    if (targetType === 0x00 && layers && !layers.motorways && !layers.trunk) continue;
                    if (targetType === 0x01 && layers && !layers.primary && !layers.secondary) continue;
                    if (targetType === 0x02 && layers && !layers.tertiary && !layers.residential && !layers.service) continue;
                    if (targetType === 0x03 && layers && !layers.footways && !layers.cycleways && !layers.tracks) continue;
                    if (targetType === 0x20 && layers && !layers.railway && !layers.subways) continue;
                    if (targetType === 0x21 && layers && !layers.bus) continue;
                    if (targetType === 0x22 && layers && !layers.ferry) continue;
                    if (targetType === 0x30 && layers && !layers.buildings && !layers.industrial && !layers.commercial && !layers.residentialArea) continue;
                    if (targetType === 0x40 && layers && !layers.stations) continue;
                } else {
                    const layerKey = typeToLayer[targetType];
                    if (layerKey && layers && !layers[layerKey]) continue;
                }
                
                for (const feature of m.features) {
                    if (feature.type !== targetType) continue;
                    if (feature.points.length < 2) continue;

                    if (isV6) {
                        const st = feature.subtype ?? 0;
                        if (feature.type === 0x00) {
                            if (st === FEATURE_SUBTYPES.ROAD_HIGHWAY.MOTORWAY && !layers.motorways) continue;
                            if (st === FEATURE_SUBTYPES.ROAD_HIGHWAY.TRUNK && !layers.trunk) continue;
                        } else if (feature.type === 0x01) {
                            if (st === FEATURE_SUBTYPES.ROAD_MAJOR.PRIMARY && !layers.primary) continue;
                            if (st === FEATURE_SUBTYPES.ROAD_MAJOR.SECONDARY && !layers.secondary) continue;
                        } else if (feature.type === 0x02) {
                            if (st === FEATURE_SUBTYPES.ROAD_MINOR.TERTIARY && !layers.tertiary) continue;
                            if (st === FEATURE_SUBTYPES.ROAD_MINOR.RESIDENTIAL && !layers.residential) continue;
                            if (st === FEATURE_SUBTYPES.ROAD_MINOR.SERVICE && !layers.service) continue;
                        } else if (feature.type === 0x03) {
                            if (st === FEATURE_SUBTYPES.ROAD_PATH.FOOTWAY && !layers.footways) continue;
                            if (st === FEATURE_SUBTYPES.ROAD_PATH.CYCLEWAY && !layers.cycleways) continue;
                            if (st === FEATURE_SUBTYPES.ROAD_PATH.TRACK && !layers.tracks) continue;
                        } else if (feature.type === 0x20) {
                            if (st === FEATURE_SUBTYPES.RAILWAY.RAIL && !layers.railway) continue;
                            if (st === FEATURE_SUBTYPES.RAILWAY.SUBWAY && !layers.subways) continue;
                        } else if (feature.type === 0x30) {
                            if (st === FEATURE_SUBTYPES.BUILDING.BUILDING && !layers.buildings) continue;
                            if (st === FEATURE_SUBTYPES.BUILDING.INDUSTRIAL && !layers.industrial) continue;
                            if (st === FEATURE_SUBTYPES.BUILDING.COMMERCIAL && !layers.commercial) continue;
                            if (st === FEATURE_SUBTYPES.BUILDING.RESIDENTIAL && !layers.residentialArea) continue;
                        }
                    }
                    
                    // LOD with smooth fade-in transitions instead of hard pop-in
                    // Define fade zones: features fade in gradually as you zoom in
                    let fadeOpacity = 1.0;
                    let fadeLineScale = 1.0;
                    
                    // Minor roads (0x02): fade in from 0.2 to 0.4
                    if (feature.type === 0x02) {
                        if (zoom < 0.2) continue;
                        if (zoom < 0.4) {
                            const t = (zoom - 0.2) / 0.2; // 0 at 0.2, 1 at 0.4
                            fadeOpacity = t * t; // Ease-in curve
                            fadeLineScale = 0.3 + t * 0.7; // Start at 30% width
                        }
                    }
                    
                    // Paths (0x03): fade in from 0.7 to 1.2
                    if (feature.type === 0x03) {
                        if (zoom < 0.7) continue;
                        if (zoom < 1.2) {
                            const t = (zoom - 0.7) / 0.5; // 0 at 0.7, 1 at 1.2
                            fadeOpacity = t * t;
                            fadeLineScale = 0.2 + t * 0.8; // Start at 20% width
                        }
                    }
                    
                    // Buildings (0x30): only show when zoomed in enough to see individual buildings
                    // At low zoom, buildings overlap and create ugly blobs
                    if (feature.type === 0x30) {
                        if (zoom < 2.0) continue;  // Hide buildings until zoomed in
                        if (zoom < 3.0) {
                            const t = (zoom - 2.0) / 1.0; // 0 at 2.0, 1 at 3.0
                            fadeOpacity = t * t;
                            fadeLineScale = 0.3 + t * 0.7;
                        }
                    }
                    
                    const style = COLORS[feature.type] || { stroke: '#888', width: 1 };
                    const pts = feature.points;
                    
                    ctx.beginPath();
                    ctx.strokeStyle = style.stroke;
                    // Scale line width based on zoom
                    let lineScale = 1;
                    // Only apply thinning to highways/trunk (0x00, 0x01) - paths should stay visible
                    if (feature.type === 0x00 || feature.type === 0x01) {
                        if (zoom > 1) {
                            // Reduce line width progressively as zoom increases for highways
                            lineScale = Math.max(0.3, 1 / Math.sqrt(zoom));
                        } else if (zoom < 1) {
                            lineScale = Math.max(0.4, zoom);
                        }
                    } else if (feature.type === 0x22) {
                        if (zoom > 1) {
                            lineScale = Math.max(0.25, 1 / Math.sqrt(zoom));
                        } else if (zoom < 1) {
                            lineScale = Math.max(0.35, zoom);
                        }
                    } else if (feature.type === 0x03) {
                        // Paths: keep full width or slightly thicker when zoomed in
                        if (zoom < 1) {
                            lineScale = Math.max(0.5, zoom);
                        }
                    } else if (zoom < 1) {
                        // Other features: reduce when zoomed out
                        lineScale = Math.max(0.4, zoom);
                    }
                    ctx.lineWidth = style.width * lineScale * fadeLineScale;
                    const alpha = feature.type === 0x22 ? (fadeOpacity * 0.55) : fadeOpacity;
                    ctx.globalAlpha = alpha;
                    if (style.dash) ctx.setLineDash(style.dash);
                    else ctx.setLineDash([]);
                    
                    const first = toCanvas(pts[0].lat, pts[0].lon);
                    ctx.moveTo(first.x, first.y);
                    
                    for (let i = 1; i < pts.length; i++) {
                        const p = toCanvas(pts[i].lat, pts[i].lon);
                        ctx.lineTo(p.x, p.y);
                    }
                    
                    // Fill closed polygons (buildings only - parks handled separately)
                    const isClosed = pts.length >= 3 && (
                        Math.abs(pts[0].lat - pts[pts.length-1].lat) < 0.01 &&
                        Math.abs(pts[0].lon - pts[pts.length-1].lon) < 0.01
                    );
                    
                    if (style.fill && isClosed && feature.type === 0x30) {
                        ctx.closePath();
                        ctx.fillStyle = style.fill;
                        ctx.globalAlpha = fadeOpacity * 0.6; // Apply fade to fill too
                        ctx.fill();
                        // NOTE: Don't stroke filled building polygons - stroking causes visible
                        // tile boundary artifacts for large landuse areas (industrial, commercial, residential)
                        // that span multiple tiles. The fill alone defines the area.
                        ctx.globalAlpha = 1.0;
                        featureCount++;
                        continue;  // Skip the stroke below
                    }
                    
                    if (style.width > 0) ctx.stroke();
                    ctx.globalAlpha = 1.0; // Reset alpha after each feature
                    featureCount++;
                }
            }
            
            return featureCount;
        }
        
        // ========== END MODULAR RENDERING FUNCTIONS ==========
        
        // Render parsed HWMAP data to preview canvas - EXACTLY like device WebPage_Maps.h
        function renderHWMapPreview() {
            const canvas = document.getElementById('previewCanvas');
            if (!canvas || !window.hwmapData) return;
            
            // Ensure canvas is properly sized
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = 400;
            
            const ctx = canvas.getContext('2d');
            const m = window.hwmapData;
            const zoom = window.previewZoom || 1.0;
            const panX = window.previewPanX || 0;
            const panY = window.previewPanY || 0;
            
            // Check granular layer toggles
            const layers = {
                // Roads
                motorways: document.getElementById('layerMotorways')?.checked ?? true,
                trunk: document.getElementById('layerTrunk')?.checked ?? true,
                primary: document.getElementById('layerPrimary')?.checked ?? true,
                secondary: document.getElementById('layerSecondary')?.checked ?? true,
                tertiary: document.getElementById('layerTertiary')?.checked ?? true,
                residential: document.getElementById('layerResidential')?.checked ?? true,
                service: document.getElementById('layerService')?.checked ?? true,
                // Paths
                footways: document.getElementById('layerFootways')?.checked ?? true,
                cycleways: document.getElementById('layerCycleways')?.checked ?? true,
                tracks: document.getElementById('layerTracks')?.checked ?? true,
                // Water
                lakes: document.getElementById('layerLakes')?.checked ?? true,
                rivers: document.getElementById('layerRivers')?.checked ?? true,
                coastlines: document.getElementById('layerCoastlines')?.checked ?? true,
                // Nature
                parks: document.getElementById('layerParks')?.checked ?? true,
                forests: document.getElementById('layerForests')?.checked ?? true,
                grassland: document.getElementById('layerGrassland')?.checked ?? true,
                // Infrastructure
                railway: document.getElementById('layerRailway')?.checked ?? true,
                subways: document.getElementById('layerSubways')?.checked ?? true,
                bus: document.getElementById('layerBus')?.checked ?? true,
                ferry: document.getElementById('layerFerry')?.checked ?? true,
                stations: document.getElementById('layerStations')?.checked ?? true,
                buildings: document.getElementById('layerBuildings')?.checked ?? true,
                industrial: document.getElementById('layerIndustrial')?.checked ?? true,
                commercial: document.getElementById('layerCommercial')?.checked ?? true,
                residentialArea: document.getElementById('layerResidentialArea')?.checked ?? true
            };
            
            // Create grouped layer checks for HWMAP types (which use grouped categories)
            const groupedLayers = {
                highways: layers.motorways || layers.trunk,
                major: layers.primary || layers.secondary,
                minor: layers.tertiary || layers.residential || layers.service,
                paths: layers.footways || layers.cycleways || layers.tracks,
                water: layers.lakes || layers.rivers || layers.coastlines,
                parks: layers.parks || layers.forests || layers.grassland,
                railway: layers.railway || layers.subways,
                bus: layers.bus,
                ferry: layers.ferry,
                stations: layers.stations,
                buildings: layers.buildings || layers.industrial || layers.commercial || layers.residentialArea
            };
            
            // Clear with dark background
            ctx.fillStyle = '#0a0a14';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Bounds are already in degrees (converted in parseHWMapBlob)
            const minLat = m.minLat;
            const maxLat = m.maxLat;
            const minLon = m.minLon;
            const maxLon = m.maxLon;
            const mapWidth = maxLon - minLon;
            const mapHeight = maxLat - minLat;
            const centerLat = (minLat + maxLat) / 2;
            const centerLon = (minLon + maxLon) / 2;
            
            // Calculate scale to fit map in canvas
            const scaleX = (canvas.width * 0.9) / mapWidth;
            const scaleY = (canvas.height * 0.9) / mapHeight;
            const baseScale = Math.min(scaleX, scaleY);
            const scale = baseScale * zoom;
            
            // Convert geo to canvas coords (match device logic)
            // Coordinates are now in degrees (converted from microdegrees in parseHWMapBlob)
            const toCanvas = (lat, lon) => {
                let x = (lon - centerLon) * scale;
                let y = -(lat - centerLat) * scale;
                x += canvas.width / 2 + panX;
                y += canvas.height / 2 + panY;
                return { x, y };
            };

            // If a polygon (e.g. circle) selection exists, clip the preview rendering to it.
            // This is a preview-only visual clip; the underlying map bounds remain rectangular.
            const hasSelectionPolygon = Array.isArray(selectedPolygon) && selectedPolygon.length >= 3;
            if (hasSelectionPolygon) {
                ctx.save();
                ctx.beginPath();
                const first = toCanvas(selectedPolygon[0][0], selectedPolygon[0][1]);
                ctx.moveTo(first.x, first.y);
                for (let i = 1; i < selectedPolygon.length; i++) {
                    const p = toCanvas(selectedPolygon[i][0], selectedPolygon[i][1]);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
                ctx.clip();
            }
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Colors matching device
            const COLORS = {
                0x00: { stroke: '#ff6b6b', width: 6 },
                0x01: { stroke: '#ffd93d', width: 4 },
                0x02: { stroke: '#ffffff', width: 3 },
                0x03: { stroke: '#aaaaaa', width: 2, dash: [8,8] },
                0x10: { stroke: '#4dabf7', width: 2, fill: '#1864ab' },
                0x11: { stroke: '#69db7c', width: 1, fill: '#2b8a3e' },
                0x12: { stroke: '#c9b896', width: 0, fill: '#c9b896' },
                0x20: { stroke: '#da77f2', width: 4, dash: [16,8] },
                0x21: { stroke: '#fab005', width: 3, dash: [12,6] },
                0x22: { stroke: '#15aabf', width: 4, dash: [16,8] },
                0x30: { stroke: '#868e96', width: 2, fill: '#495057' },
                0x40: { stroke: '#f06595', width: 0, radius: 6 }
            };
            
            // Check for land mask
            const hasLandMask = m.features.some(f => f.type === 0x12);
            const waterFeatures = m.features.filter(f => f.type === 0x10);
            const landMaskFeatures = m.features.filter(f => f.type === 0x12);
            console.log('[HWMAP PREVIEW] hasLandMask:', hasLandMask, 'landMaskFeatures:', landMaskFeatures.length, 'waterFeatures:', waterFeatures.length);
            console.log('[HWMAP PREVIEW] Feature types:', [...new Set(m.features.map(f => '0x' + f.type.toString(16)))]);
            
            // ========== MODULAR RENDERING PIPELINE ==========
            // Strategy: LAND background -> ALL water polygons -> ALL land masks
            // Water polygon SHAPES follow coastlines, land masks restore land areas
            
            // 1. Fill background with LAND color (tan)
            fillBackground(ctx, canvas, toCanvas, m, hasLandMask);
            
            // 2. Draw ALL water polygons (carve out rivers/bays from land)
            const waterCount = groupedLayers.water ? drawAllWater(ctx, toCanvas, m, mapWidth, mapHeight, hasLandMask, COLORS, layers) : 0;
            
            // 3. Draw ALL land masks on top (restore land areas)
            const landMaskCount = drawLandMasks(ctx, toCanvas, m, mapWidth, mapHeight, hasLandMask, COLORS);
            
            // 4. Draw building clusters when zoomed out (BEFORE parks so parks show on top)
            if (groupedLayers.buildings) drawBuildingClusters(ctx, toCanvas, m, zoom, mapWidth, mapHeight, layers);
            
            // 5. Draw parks (green areas on top of building clusters)
            const parkCount = groupedLayers.parks ? drawParks(ctx, toCanvas, m, hasLandMask, COLORS, layers) : 0;
            
            // 6. Draw coastline strokes (water boundaries for definition)
            if (groupedLayers.water) drawCoastlineStrokes(ctx, toCanvas, m, hasLandMask, COLORS, layers);
            
            // 7. Draw highway casings
            drawHighwayCasings(ctx, toCanvas, m, zoom, COLORS, m.version >= 6 ? layers : groupedLayers);
            
            // 8. Draw all other map features (roads, buildings)
            const featureCount = drawMapFeatures(ctx, toCanvas, m, zoom, hasLandMask, COLORS, m.version >= 6 ? layers : groupedLayers, centerLat, centerLon, mapWidth, mapHeight);
            
            window.previewFeatureCount = featureCount;
            
            // Log render summary
            console.log(`[RENDER SUMMARY] ========================================`);
            console.log(`[RENDER SUMMARY] Features rendered: ${featureCount}`);
            console.log(`[RENDER SUMMARY] Water filled: ${waterCount}`);
            console.log(`[RENDER SUMMARY] Land masks filled: ${landMaskCount}`);
            console.log(`[RENDER SUMMARY] Parks filled: ${parkCount}`);
            console.log(`[RENDER SUMMARY] hasLandMask: ${hasLandMask}`);
            console.log(`[RENDER SUMMARY] Strategy: LAND bg -> water -> land masks`);
            console.log(`[RENDER SUMMARY] ========================================`);

            if (hasSelectionPolygon) {
                ctx.restore();
            }
            
            // Draw zoom indicator
            ctx.fillStyle = '#fff';
            ctx.font = '14px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`Zoom: ${zoom.toFixed(1)}x`, 10, canvas.height - 10);
            ctx.fillText(`Features: ${m.features.length}`, 10, canvas.height - 30);
        }
        
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Update stats when checkboxes change
        document.querySelectorAll('.checkbox-group input').forEach(cb => {
            cb.addEventListener('change', updateStats);
        });
        
        // Slider event listeners
        document.getElementById('sizeBudget').addEventListener('input', () => {
            updateBudgetLabel();
            updateStats();
            triggerAutoPreview();
        });
        
        // Name detail slider
        document.getElementById('nameDetail').addEventListener('input', () => {
            updateNameDetailLabel();
            updateStats();
            triggerAutoPreview();
        });
        
        // Building names checkbox
        document.getElementById('buildingNames')?.addEventListener('change', () => {
            const level = parseInt(document.getElementById('nameDetail').value);
            updateNameDetailLabel();
            updateFilteredFeatureList(level);
            updateStats();
        });
        
        // v5 format controls
        document.getElementById('v5TileGrid')?.addEventListener('change', () => {
            const val = document.getElementById('v5TileGrid').value;
            document.getElementById('v5TileGridValue').textContent = val + '×' + val;
            updateStats();
            triggerAutoPreview();
        });
        
        document.getElementById('v5HaloPct')?.addEventListener('input', () => {
            const val = document.getElementById('v5HaloPct').value;
            document.getElementById('v5HaloValue').textContent = val + '%';
            updateStats();
            triggerAutoPreview();
        });
        
        document.getElementById('v5QuantBits')?.addEventListener('input', () => {
            const val = document.getElementById('v5QuantBits').value;
            document.getElementById('v5QuantValue').textContent = val + '-bit';
            updateStats();
            triggerAutoPreview();
        });
        
        document.getElementById('v5ShowTileBounds')?.addEventListener('change', () => {
            if (window.hwmapData) renderHWMapPreview();
        });
        
        function updateNameDetailLabel() {
            const level = parseInt(document.getElementById('nameDetail').value);
            const labels = ['None', 'Highways Only', 'Major Roads', 'All Roads', 'Everything'];
            const descs = [
                'No names included - smallest file size',
                'Only highway/motorway names for basic context',
                'Highways + major roads get names for "where am I" context',
                'All road types get names for detailed context',
                'All features including parks, water, railways get names'
            ];
            document.getElementById('nameDetailValue').textContent = labels[level];
            document.getElementById('nameDetailDesc').textContent = descs[level];
            
            // Hide/show Map Features panel based on name detail level OR building names checkbox
            const featuresPanel = document.getElementById('mapFeaturesPanel');
            const buildingNamesChecked = document.getElementById('buildingNames')?.checked || false;
            if (featuresPanel) {
                featuresPanel.style.display = (level === 0 && !buildingNamesChecked) ? 'none' : 'block';
            }
            
            // Update the feature list to show only what will be included
            updateFilteredFeatureList(level);
        }
        
        function updateFilteredFeatureList(level) {
            const buildingNamesChecked = document.getElementById('buildingNames')?.checked || false;
            if (!window.extractedMetadata) return;
            // Allow showing list if building names checked even when level is 0
            if (level === 0 && !buildingNamesChecked) return;
            
            const featuresList = document.getElementById('mapFeaturesList');
            const metadataSizeEl = document.getElementById('metadataSizeEst');
            if (!featuresList) return;
            
            const { namedFeatures } = window.extractedMetadata;
            let html = '';
            let totalBytes = 0;
            let totalCount = 0;
            
            // Track unique names to avoid counting duplicates
            const uniqueNames = new Set();
            
            const addSection = (title, items, color) => {
                if (items.length === 0) return;
                totalCount += items.length;
                // Only count bytes for unique names (deduplication)
                for (const f of items) {
                    if (!uniqueNames.has(f.label)) {
                        uniqueNames.add(f.label);
                        totalBytes += (f.bytes || 20);
                    }
                }
                
                html += `<div style="margin-bottom:8px;">`;
                html += `<div style="color:${color};font-weight:bold;margin-bottom:4px;">${title} (${items.length})</div>`;
                html += `<div style="color:#aaa;padding-left:8px;">`;
                const shown = items.slice(0, 10);
                html += shown.map(f => `<div style="margin:1px 0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${f.label}">${f.label}</div>`).join('');
                if (items.length > 10) {
                    html += `<div style="color:#666;font-style:italic;">...and ${items.length - 10} more</div>`;
                }
                html += `</div></div>`;
            };
            
            // Level 1: Highways only
            // Level 2: Highways + major roads  
            // Level 3: All roads
            // Level 4: Everything
            // Building names: separate checkbox
            
            if (level >= 1) addSection('Highways', namedFeatures.highways || [], '#ff6b6b');
            if (level >= 2) addSection('Roads', namedFeatures.roads || [], '#ffd93d');
            if (level >= 4) {
                addSection('Water', namedFeatures.water || [], '#4dabf7');
                addSection('Parks', namedFeatures.parks || [], '#69db7c');
                addSection('Railways', namedFeatures.railways || [], '#da77f2');
            }
            
            // Building names shown if checkbox is checked (use variable from top of function)
            if (buildingNamesChecked && namedFeatures.buildings) {
                addSection('Buildings', namedFeatures.buildings, '#b197fc');
            }
            
            featuresList.innerHTML = html || '<div style="color:#666;font-style:italic;">No names match current settings</div>';
            
            // Calculate building names separately
            let buildingCount = 0;
            let buildingBytes = 0;
            if (buildingNamesChecked && namedFeatures.buildings) {
                buildingCount = namedFeatures.buildings.length;
                for (const f of namedFeatures.buildings) buildingBytes += (f.bytes || 20);
            }
            
            // Non-building totals
            const otherCount = totalCount - buildingCount;
            const otherBytes = totalBytes - buildingBytes;
            
            // Update summary with actual counts - split buildings from others
            const nameSummary = document.getElementById('nameSummary');
            const buildingNameSummary = document.getElementById('buildingNameSummary');
            
            if (otherCount > 0) {
                const otherKB = (otherBytes / 1024).toFixed(1);
                if (metadataSizeEl) metadataSizeEl.textContent = `+${otherKB} KB if included`;
                if (nameSummary) nameSummary.textContent = `Roads/Terrain: ${otherCount} names (~${otherKB} KB)`;
            } else {
                if (metadataSizeEl) metadataSizeEl.textContent = '';
                if (nameSummary) nameSummary.textContent = '';
            }
            
            if (buildingCount > 0) {
                const buildingKB = (buildingBytes / 1024).toFixed(1);
                if (buildingNameSummary) buildingNameSummary.textContent = `Buildings: ${buildingCount} names (+${buildingKB} KB if included)`;
            } else {
                if (buildingNameSummary) buildingNameSummary.textContent = '';
            }
        }
        
        // Initialize
        updateNameDetailLabel();
        updateSimplifySliders();
        updateCoastlineSubOptions();
        updateBuildingSubOptions();
    </script>
    
    <!-- Text Editor Modal -->
    <div id="textEditorModal" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:10000;align-items:center;justify-content:center;">
        <div style="background:#1a1a2e;border-radius:8px;padding:20px;width:90%;max-width:400px;border:1px solid #333;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
                <span id="textEditorTitle" style="font-weight:bold;color:#eee;">Edit</span>
                <button onclick="closeTextEditor()" style="background:none;border:none;color:#888;font-size:1.2em;cursor:pointer;">&times;</button>
            </div>
            <textarea id="textEditorArea" style="width:100%;height:120px;background:#16213e;border:1px solid #333;border-radius:4px;color:#eee;padding:8px;font-family:inherit;font-size:0.9em;resize:vertical;"></textarea>
            <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px;">
                <button onclick="closeTextEditor()" style="padding:6px 16px;background:#333;color:#aaa;border:none;border-radius:4px;cursor:pointer;">Cancel</button>
                <button onclick="saveTextEditor()" style="padding:6px 16px;background:#4cc9f0;color:#000;border:none;border-radius:4px;cursor:pointer;font-weight:bold;">Save</button>
            </div>
        </div>
    </div>
</body>
</html>
